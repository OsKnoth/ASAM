MODULE Function_Mod
  USE DataType_Mod
  USE Names_Mod
  USE Physics_Mod
  USE Emission_Mod
  USE Koagulation_Mod
  USE CondenAdvect_Mod
  USE Ansatz_Mod 
  USE Adiabatic_Mod
  USE Parameter_Mod
  USE BoundaryCond_Mod
  USE Example_Mod
  USE Activity_Mod
  USE Radiation_Mod
  USE Shadow_Mod
  USE DiffKoeff_Mod
  USE Turbulence_Mod
  USE Operator_Mod
  USE Wall_Mod
  USE BulkMicroPhysics_Mod
  USE TwoMomentBulkMicroPhysics_Mod
  USE LSCMicroPhysics_Mod
  USE SpectralMicro_Mod
  USE Canopy_Mod
  USE WindFarm_Mod

  USE ReadProfile_Mod

  IMPLICIT NONE

  INTEGER, PRIVATE :: i,j,k
  INTEGER, PRIVATE :: ib
  INTEGER, PRIVATE :: ic,icE
  INTEGER, PRIVATE :: uPosJac,vPosJac,wPosJac
  REAL(RealKind), PRIVATE, POINTER :: c(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: cB(:,:)
  REAL(RealKind), PRIVATE, POINTER :: Acc(:,:)
  REAL(RealKind), PRIVATE, POINTER :: ce1(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: ce2(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: th(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: thProf(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: WaterLiq(:,:,:,:) 
  REAL(RealKind), PRIVATE, POINTER :: the(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: tke(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: dis(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: ome(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qv(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qc(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qr(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qi(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoV(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoL(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoI(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoS(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: Nvap(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: Ncloud(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: Nrain(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: Nice(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: Nsnow(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: ThetaV(:)
  REAL(RealKind), PRIVATE, POINTER :: Rho(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoD(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: p(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: Sound(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: Weight(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: T(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: KinEn(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: E(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: EnergyStart(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: PressureStart(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: SoS(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: HeightC(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: DivC(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: dpdTheta(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: DH(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: DV(:,:,:,:)  
  REAL(RealKind), PRIVATE, POINTER :: uF(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uFOld(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vFOld(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wFOld(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vF(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wF(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: cFU(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: cFV(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: cFW(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: pFU(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: pFV(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: pFW(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: DUU(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: DUV(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: DUW(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uC(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vC(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wC(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uCL(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vCL(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wCL(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uCR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vCR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wCR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uE(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vE(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wE(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: f(:,:,:,:),fL(:,:,:,:),fR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uFPGrad(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vFPGrad(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wFPGrad(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uFRhs(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vFRhs(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wFRhs(:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uRhsL(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vRhsL(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wRhsL(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: uRhsR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: vRhsR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: wRhsR(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: thRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: tkeRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: disRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: omeRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qvRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoVRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qcRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoLRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qiRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: qrRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: RhoRhs(:,:,:,:)
  REAL(RealKind), PRIVATE, POINTER :: DampKoeff(:,:,:,:)
  TYPE(SpDiag), PRIVATE, POINTER :: AT
  TYPE(SpDiag), PRIVATE, POINTER :: ATMom
  TYPE(SpDiag), PRIVATE, POINTER :: ATPot
  TYPE(SpDiag), PRIVATE, POINTER :: AFall
  TYPE(SpDiag), PRIVATE, POINTER :: AFallRhoL
  TYPE(Vec4_T), PRIVATE, POINTER :: AS(:)
  TYPE(BoundaryCon_T), PRIVATE, POINTER :: BC 
  REAL(RealKind), PRIVATE :: vFall=0.0d0
  REAL(RealKind) :: dtAdvec
  INTEGER, PRIVATE, POINTER :: DiagP(:)
  INTEGER, PRIVATE, POINTER :: Permu(:)
  INTEGER, PRIVATE :: Diag
  Real(RealKind), TARGET, PUBLIC, ALLOCATABLE :: AccRain(:,:)

  INTERFACE Fcn
    MODULE PROCEDURE FcnMet
  END INTERFACE
  INTERFACE FcnG
    MODULE PROCEDURE FcnMetG
  END INTERFACE
  INTERFACE Update
    MODULE PROCEDURE UpdateScalarCell,UpdateVectorCell
  END INTERFACE
  INTERFACE ScaleV
    MODULE PROCEDURE ScaleScalarCell,ScaleVectorCell
  END INTERFACE
  INTERFACE Jac
    MODULE PROCEDURE JacMeteo
  END INTERFACE
  INTERFACE BoundaryVelocity
    MODULE PROCEDURE BoundaryVelocityFace,BoundaryVelocityCell
  END INTERFACE

CONTAINS

FUNCTION TotalValues(VectorCell,Velocityface)
  REAL(RealKind) :: TotalValues(1:6)
  TYPE(Vector4Cell_T) :: VectorCell(:)
  TYPE(VelocityFace_T) :: VelocityFace(:)

  INTEGER :: ibLoc,ic
  INTEGER :: ix,iy,iz 
  REAL(RealKind) :: PotMLoc,RhoLoc,RhoVLoc,RhoLLoc,RhoDloc,pLoc,TLoc
  REAL(RealKind) :: Cvml,Lv
  REAL(RealKind) :: TotalEnergy,KineticEnergy,RhoTotal,PotentialEnergy
  REAL(RealKind) :: TotalEntropy
  REAL(RealKind) :: InternalEnergy


  TotalValues=Zero
  TotalEnergy=Zero
  KineticEnergy=Zero
  RhoTotal=Zero
  PotentialEnergy=Zero
  InternalEnergy=Zero
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
    IF (qcPos>0) THEN 
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
    ELSE
      RhoL=>RhoLCell(ibLoc)%c
    END IF
    RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
    Th=>VectorCell(ibLoc)%Vec(ThPos)%c
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          PotMLoc=Th(ix,iy,iz,1)
          RhoLoc=Rho(ix,iy,iz,1)
          RhoVLoc=RhoV(ix,iy,iz,1)
          RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
          RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc
          pLoc=PressureTheta(RhoDLoc,RhoVLoc,RhoLLoc,PotMLoc)
          TLoc=AbsTemp(RhoDLoc,RhoVLoc,pLoc)
          Cvml=Cvd*RhoDLoc+Cvv*RhoVLoc+Cpl*RhoLLoc
          Lv=LatHeat(TLoc)
          RhoVLoc=RhoV(ix,iy,iz,1)
          TotalEnergy=TotalEnergy &
          +Cvml*TLoc-Lv*RhoLLoc &
          +Half*(FaceToCell(uF(ix-1,iy,iz),uF(ix,iy,iz),FU(ix-1,iy,iz),FU(ix,iy,iz))**2 &
           +FaceToCell(vF(ix,iy-1,iz),vF(ix,iy,iz),FV(ix,iy-1,iz),FV(ix,iy,iz))**2 &
           +FaceToCell(wF(ix,iy,iz-1),wF(ix,iy,iz),FW(ix,iy,iz-1),FW(ix,iy,iz))**2 &
           )/(RhoLoc+Eps) &
          +Half*RhoLoc*(zP(iz-1)+zP(iz))*Grav
          InternalEnergy=InternalEnergy&
           +Cvml*TLoc-Lv*RhoLLoc
          KineticEnergy=KineticEnergy &
            +Half*(FaceToCell(uF(ix-1,iy,iz),uF(ix,iy,iz),FU(ix-1,iy,iz),FU(ix,iy,iz))**2 &
           +FaceToCell(vF(ix,iy-1,iz),vF(ix,iy,iz),FV(ix,iy-1,iz),FV(ix,iy,iz))**2 &
           +FaceToCell(wF(ix,iy,iz-1),wF(ix,iy,iz),FW(ix,iy,iz-1),FW(ix,iy,iz))**2 &
           )/(RhoLoc+Eps)
          PotentialEnergy=PotentialEnergy &
           +Half*RhoLoc*(zP(iz-1)+zP(iz))*Grav
          RhoTotal=RhoTotal &
           +RhoLoc   
          TotalEntropy=TotalEntropy+PotMLoc
        END DO
      END DO
    END DO
  END DO
  TotalValues(1)=TotalEnergy
  TotalValues(2)=KineticEnergy
  TotalValues(3)=InternalEnergy
  TotalValues(4)=PotentialEnergy
  TotalValues(5)=RhoTotal
  TotalValues(6)=TotalEntropy
END FUNCTION TotalValues

FUNCTION KineticEnergy(VectorCell)
  REAL(RealKind) :: KineticEnergy
  TYPE(Vector4Cell_T) :: VectorCell(:)

  INTEGER :: ibLoc,ic

  KineticEnergy=Zero
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    Rho=>RhoCell(ibLoc)%c
    DO ic=1,3
      c=>VectorCell(ibLoc)%Vec(ic)%c
      KineticEnergy=KineticEnergy &
         +SUM(c(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,1) &          
         *c(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,1) &          
         /(Rho(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,1)+Eps))           
    END DO
  END DO
END FUNCTION KineticEnergy

FUNCTION Momentum(VelocityFace)
  REAL(RealKind) :: Momentum
  TYPE(VelocityFace_T) :: VelocityFace(:)

  INTEGER :: ibLoc

  Momentum=Zero
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    Momentum=Momentum+Half*SUM(VelocityFace(ibLoc)%uF(ix0:ix1-1,iy0+1:iy1,iz0+1:iz1) &
            *VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1))
    Momentum=Momentum+Half*SUM(VelocityFace(ibLoc)%uF(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1) &
            *VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1))
    Momentum=Momentum+Half*SUM(VelocityFace(ibLoc)%vF(ix0:ix1,iy0:iy1-1,iz0+1:iz1) &
            *VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1))
    Momentum=Momentum+Half*SUM(VelocityFace(ibLoc)%vF(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1) &
            *VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1))
    Momentum=Momentum+Half*SUM(VelocityFace(ibLoc)%wF(ix0:ix1,iy0:iy1,iz0:iz1-1) &
            *VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1))
    Momentum=Momentum+Half*SUM(VelocityFace(ibLoc)%wF(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1) &
            *VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1))
  END DO
END FUNCTION Momentum

FUNCTION TotalDensity(VectorCell)
  REAL(RealKind) :: TotalDensity
  TYPE(Vector4Cell_T) :: VectorCell(:)

  INTEGER :: ibLoc

  TotalDensity=Zero
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    TotalDensity=TotalDensity+SUM(VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1) &
                *VectorCell(ibLoc)%Vec(RhoPos)%c(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,1))
  END DO
END FUNCTION TotalDensity


FUNCTION TotalEntropy(VectorCell)
  REAL(RealKind) :: TotalEntropy
  TYPE(Vector4Cell_T) :: VectorCell(:)

  INTEGER :: ibLoc

  TotalEntropy=Zero
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    TotalEntropy=TotalEntropy+SUM(VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1) &
                *VectorCell(ibLoc)%Vec(ThPos)%c(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,1))
  END DO
END FUNCTION TotalEntropy

SUBROUTINE RhoTotal(VectorCell)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)

  INTEGER :: ibLoc

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    Rho=>RhoCell(ibLoc)%c
    RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
    CALL RhoTotalCompute
  END DO
  CALL ExchangeCell(RhoCell) 
END SUBROUTINE RhoTotal

SUBROUTINE PressureG(Press,VectorCell)

  TYPE(ScalarCell_T), POINTER :: Press(:)
  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)

  INTEGER :: ibLoc

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    p=>Press(ibLoc)%c
    Th=>VectorCell(ibLoc)%Vec(ThPos)%c
    T=>TAbsCell(ibLoc)%Vec(1)%c
    Rho=>RhoCell(ibLoc)%c
    RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
    RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
    IF (qcPos>0) THEN 
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
    ELSE
      RhoL=>RhoLCell(ibLoc)%c
    END IF
    RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
    CALL AbsTCompute
    IF (ThetaKind=='Energy') THEN
      KinEn=>KinEnCell(ibLoc)%c
      CALL KinEnCompute
    END IF
    CALL PreCompute
  END DO
  CALL ExchangeCell(Press)
END SUBROUTINE PressureG


SUBROUTINE PrepareEn(VectorCell,VelocityFace,Time)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc

  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
    RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
    IF (qcPos>0) THEN 
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
    ELSE
      RhoL=>RhoLCell(ibLoc)%c
    END IF  
    CALL Set(Floor(ib))
    KinEn=>KinEnCell(ibLoc)%c
    CALL KinEnCompute
    T=>TAbsCell(ibLoc)%Vec(1)%c
    CALL AbsTCompute
    E=>VectorCell(ibLoc)%Vec(enPos)%c
    CALL ECompute
  END DO
  CALL ExchangeCell(VectorCell)

END SUBROUTINE PrepareEn

SUBROUTINE PrepareF(VectorCell,VelocityFace,Time)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  REAL(RealKind) :: Time,Time1
  REAL(RealKind) :: RadOutTime
  REAL(RealKind) :: yP0,yP1,yP2,dyP

  INTEGER :: ibLoc,iW

  logical, save :: load = .TRUE.
  logical :: exist
  integer :: iostat
  real(realkind), allocatable, save :: rad(:, :)
  real(realkind) :: glob
  real(realkind) :: rat_dir=0.5d0, lw_rad=262.75433349609375d0
  integer :: nrad

  RadOutTime=OutputTimeStep
  VelocityFaceAct=>VelocityFace
  IF (Radiation.AND..NOT.RadiationProfile) THEN
    IF (Time==StartTime.OR.MOD(INT(Time-StartTime),INT(RadOutTime))==0) THEN
      DO ibLoc=1,nbLoc
        ib=LocGlob(ibLoc)
        CALL Set(Floor(ib))
        DO i=1, NumBoundCell
          IF (Sphere) THEN
            Time1=Time+86400.0d0/(2.0d0*Pi)*xP(BoundCell(i)%ix)
            CALL SunAngleCompute(Time1,yP(BoundCell(i)%iy))
          ELSE
            CALL SunAngleCompute(Time)
          END IF

          INQUIRE(FILE='rad.prof', EXIST=exist) 
          if (exist) then
            if (load) then
              open(UNIT=900,FILE='rad.prof',STATUS='OLD',IOSTAT=iostat)
              read(900,*) nrad
              Allocate(rad(nrad,2))
              do j=1,nrad
                read(900,*) rad(j,:)
              end do
              close(900)
              load = .FALSE.
            else
              glob = ProfileEqual(rad, Time)
              BoundCell(i)%raddirekt = glob * rat_dir
              BoundCell(i)%raddiffus = glob - BoundCell(i)%raddirekt
              BoundCell(i)%radinfred = lw_rad
            end if
          else
            CALL RadiationFuLiouCompute(i)
          end if
          ! write(*,*) 'Radiation: ', BoundCell(i)%raddirekt, BoundCell(i)%raddiffus, BoundCell(i)%radinfred

          ! if (Canopy) then
            ! RaddirCell(ibLoc)%cB(i,1:Domain%nrsoillayers)=BoundCell(i)%raddirekt*BoundCell(i)%CanopyCell%RadPtrRate
            ! RaddifCell(ibLoc)%cB(i,1:Domain%nrsoillayers)=BoundCell(i)%raddiffus*BoundCell(i)%CanopyCell%GapFunc
            ! RadinfCell(ibLoc)%cB(i,1:Domain%nrsoillayers)=BoundCell(i)%radinfred*BoundCell(i)%CanopyCell%GapFunc + &
            !   BoundCell(i)%CanopyCell%emissivity*SBsigma*BoundCell(i)%CanopyCell%AvgTem**4*(1.0d0-BoundCell(i)%CanopyCell%GapFunc)
            ! BoundCell(i)%raddirekt = BoundCell(i)%raddirekt*BoundCell(i)%CanopyCell%RadPtrRate
            ! BoundCell(i)%raddiffus = BoundCell(i)%raddiffus*BoundCell(i)%CanopyCell%GapFunc
            ! BoundCell(i)%radinfred = BoundCell(i)%radinfred*BoundCell(i)%CanopyCell%GapFunc + &
            !   BoundCell(i)%CanopyCell%emissivity*SBsigma*BoundCell(i)%CanopyCell%AvgTem**4*(1.0d0-BoundCell(i)%CanopyCell%GapFunc)
          ! else
          !   RaddirCell(ibLoc)%cB(i,1:Domain%nrsoillayers)=BoundCell(i)%raddirekt
          !   RaddifCell(ibLoc)%cB(i,1:Domain%nrsoillayers)=BoundCell(i)%raddiffus
          !   RadinfCell(ibLoc)%cB(i,1:Domain%nrsoillayers)=BoundCell(i)%radinfred
          ! end if

        END DO
      END DO
    END IF
    CALL ShadowCompute
    DO ibLoc=1,nbLoc
      ib=LocGlob(ibLoc)
      CALL Set(Floor(ib))
      DO i=1,NumBoundCell
        ShadowCell(ibLoc)%cB(i,1:Domain%nrsoillayers)=BoundCell(i)%shad
      END DO
    END DO
  ELSE   
    IF (Sphere) THEN
      CALL SunAngleCompute(Time,PhiCor)
    ELSE
      CALL SunAngleCompute(Time)
    END IF  
  END IF
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL SetVelocityFace(ibLoc)
    CALL DomainSet(ib)
    Rho=>RhoCell(ibLoc)%c
    IF (RhoPos>0) THEN
      RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
      CALL RhoTotalCompute
    END IF  
    RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
    RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
    RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
    IF (qcPos==0) THEN 
      RhoL=>RhoLCell(ibLoc)%c
      IF (iWater>0) THEN
        WaterLiq=>VectorCell(ibLoc)%Vec(iWater)%c
        CALL RhoLCompute
      ELSE
        RhoLCell(ibLoc)%c=0d0
      END IF
    END IF
    IF (ASSOCIATED(KinEnCell)) THEN
      KinEn=>KinEnCell(ibLoc)%c
      CALL KinEnCompute
    END IF  
    IF (ThPos>0) THEN
      Th=>VectorCell(ibLoc)%Vec(ThPos)%c
      T=>TAbsCell(ibLoc)%Vec(1)%c
      CALL AbsTCompute
    END IF  
    IF (ASSOCIATED(ECell)) THEN
      E=>ECell(ibLoc)%c
      CALL ECompute
    END IF  
    IF (PGradient.AND..NOT.(Anelastic.OR.PseudoIn).OR.Parcel) THEN
      p=>PreCell(ibLoc)%c
      CALL PreCompute
      IF (Time==StartTime) THEN
        EnergyStart=>EStartCell(ibLoc)%c
        EnergyStart=E
        PressureStart=>PStartCell(ibLoc)%c
        PressureStart=p
      END IF
      IF (ThetaKind=='PreEn'.OR.ThetaKind=='Exner'.OR.Parcel) THEN
        Sound=>SoundCell(ibLoc)%c
        CALL SoundCompute
      END IF  
    END IF
    IF (DragSurf.OR.DynamicSoil.OR.Canopy) THEN
      CALL DragCoeff(VelocityFace,VectorCell,ibLoc=ibLoc)
    END IF
    IF (uPosL>0) THEN
      uC=>uCell(ibLoc)%c
      vC=>vCell(ibLoc)%c
      wC=>wCell(ibLoc)%c
      CALL VelFaceToCellCompute
      CALL BoundaryVelocityCellCompute(Time)
    END IF
    IF (DivDamp>Zero) THEN
      uF=>VelocityFace(ibLoc)%uF
      vF=>VelocityFace(ibLoc)%vF
      wF=>VelocityFace(ibLoc)%wF
      DivC=>DivCell(ibLoc)%c
      CALL DivFCompute
    END IF
    IF (Chemie.AND.DataFile/='') THEN 
      IF (Position('H2O')>0) THEN
        VectorCell(ibLoc)%Vec(Position('H2O'))%c=RhoV/Molmass(Position('H2O')) ! water vapor concentration
      END IF
      IF (Position('O2')>0) THEN
        VectorCell(ibLoc)%Vec(Position('O2'))%c=(RhoD-RhoV-RhoL)/Molmass(Position('O2'))*0.20942
      END IF
      IF (Position('N2')>0) THEN
        VectorCell(ibLoc)%Vec(Position('N2'))%c=(RhoD-RhoV-RhoL)/Molmass(Position('N2'))*0.78084
      END IF
    END IF
  END DO
  IF (uPosL>0) THEN
    CALL ExchangeCell(uCell) 
    CALL ExchangeCell(vCell) 
    CALL ExchangeCell(wCell) 
  END IF
  CALL ExchangeCell(RhoCell) 
  IF (ASSOCIATED(KinEnCell)) THEN
    CALL ExchangeCell(KinEnCell) 
  END IF
  IF (ASSOCIATED(PreCell)) THEN
    CALL ExchangeCell(PreCell) 
  END IF
  IF (ASSOCIATED(DivCell)) THEN
    CALL ExchangeCell(DivCell) 
  END IF
  IF (ASSOCIATED(TAbsCell)) THEN
    CALL ExchangeCell(TAbsCell) 
  END IF
  IF (ASSOCIATED(SoundCell)) THEN
    CALL ExchangeCell(SoundCell) 
  END IF
  IF (Parcel.AND.TrajIn) THEN
    DO ibLoc=1,nbLoc
      ib=LocGlob(ibLoc)
      CALL DomainSet(ib)
      CALL MetAmbientComput(VectorCell(ibLoc)%Vec,Time,ibLoc)
    END DO
  END IF

END SUBROUTINE PrepareF

SUBROUTINE PrepareFEx(VectorCell,VelocityFace,UVec,Time)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  TYPE(Vector4Cell_T), POINTER :: UVec(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc,iW

  VelocityFaceAct=>VelocityFace
  IF (Radiation.AND..NOT.RadiationProfile) THEN
   CALL SunAngleCompute(Time)
   CALL RadiationFuLiouCompute()
   CALL ShadowCompute
  END IF
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    IF (RhoPos>0) THEN
      Rho=>RhoCell(ibLoc)%c
      RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
      CALL RhoTotalCompute
    END IF  
    RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
    RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
    RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
    KinEn=>KinEnCell(ibLoc)%c
    CALL KinEnCompute
    IF (ThPos>0) THEN
      p=>PreCell(ibLoc)%c
      Th=>VectorCell(ibLoc)%Vec(ThPos)%c
      T=>TAbsCell(ibLoc)%Vec(1)%c
      CALL AbsTCompute
    END IF  
    E=>ECell(ibLoc)%c
    CALL ECompute
    IF (DragSurf) THEN
      CALL DragCoeff(VelocityFace,VectorCell,UVec,ibLoc=ibLoc)
    END IF
    IF (uPosL>0) THEN
      uC=>uCell(ibLoc)%c
      vC=>vCell(ibLoc)%c
      wC=>wCell(ibLoc)%c
      CALL VelFaceToCellCompute
      CALL BoundaryVelocityCellCompute(Time)
    END IF
  END DO   
  IF (uPosL>0) THEN
    CALL ExchangeCell(uCell) 
    CALL ExchangeCell(vCell) 
    CALL ExchangeCell(wCell) 
  END IF
  CALL ExchangeCell(RhoCell)

END SUBROUTINE PrepareFEx


SUBROUTINE PressureEnergyCompute(VectorCell,VelocityFace)

  TYPE (Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE (VelocityFace_T), TARGET :: VelocityFace(:)
   
  REAL(RealKind) :: RhoLoc,RhoVLoc,RhoLLoc,RhoDLoc
  REAL(RealKind) :: Kinetic,Energy,zLoc,pLoc

  INTEGER :: ibLoc
  INTEGER :: ix,iy,iz

  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    p=>PreCell(ibLoc)%c
    KinEn=>KinEnCell(ibLoc)%c
    Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
    E=>VectorCell(ibLoc)%Vec(enPos)%c
    RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
    RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
    IF (qcPos>0) THEN 
       RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
    ELSE
       RhoL=>RhoLCell(ibLoc)%c
    END IF  
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          RhoLoc=Rho(ix,iy,iz,1)
          RhoVLoc=RhoV(ix,iy,iz,1)
          RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
          RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc
          Energy=E(ix,iy,iz,1)
          Kinetic=KinEn(ix,iy,iz,1)
          zLoc=Half*(zp(iz-1)+zp(iz))
          pLoc=(RhoDLoc*Rd+RhoVLoc*Rv) &
                        *(Energy &
                         -RhoLoc*Kinetic &
                         -RhoLoc*zLoc*Grav &
                         -RhoVLoc*L00) &
                        /(RhoDLoc*Cvd+RhoVLoc*Cvv+RhoLLoc*Cpl+Eps)
          p(ix,iy,iz,1)=pLoc
        END DO 
      END DO 
    END DO 
  END DO 
  CALL ExchangeCell(PreCell)
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    VectorCell(ibLoc)%Vec(thPos)%c=PreCell(ibLoc)%c
  END DO  


END SUBROUTINE PressureEnergyCompute


SUBROUTINE MeanProfileCompute(VecT) 

! Profil wird aus allen Zellen berechnet
! Voraussetzung: alle Blocks weisen die originale z-Einteilung auf

  TYPE(Vector4Cell_T), POINTER :: VecT(:)
  INTEGER :: ibLoc,ic,ix,iy,iz
  REAL(RealKind), ALLOCATABLE :: VolS(:)

  ALLOCATE(VolS(Domain%iz0+1:Domain%iz1))
  VolS=0.d0
  MeanProfile=0.d0
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    IF (iz0<Domain%iz0.OR.iz1>Domain%iz1) THEN
      STOP 'SR MeanProfileCompute qualified only for blocks with original z-grid'
    END IF
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          VolS(iz)=VolS(iz)+VolC(ix,iy,iz)
          MeanProfile(0,iz)=MeanProfile(0,iz)+RhoCell(ibLoc)%c(ix,iy,iz,1)*VolC(ix,iy,iz)
          DO ic=1,SIZE(VecT(ibLoc)%Vec)
            MeanProfile(ic,iz)=MeanProfile(ic,iz)+VecT(ibLoc)%Vec(ic)%c(ix,iy,iz,1)*VolC(ix,iy,iz)
          END DO
        END DO
      END DO
    END DO
  END DO
  DO iz=Domain%iz0+1,Domain%iz1
    MeanProfile(0,iz)=MeanProfile(0,iz)/(ABS(VolS(iz))+Eps)
    DO ic=1,SIZE(VecT(1)%Vec)
      MeanProfile(ic,iz)=MeanProfile(ic,iz)/(ABS(VolS(iz))+Eps)
    END DO
  END DO

  DEALLOCATE(VolS)

END SUBROUTINE MeanProfileCompute

SUBROUTINE FcnMetSlow(VecUCell,VectorCell,VelocityFace,Rhs,ThetaF,PreFacF,SoundFac,Time,dt)

  TYPE(Vector4Cell_T), POINTER :: VecUCell(:)
  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), POINTER :: VelocityFace(:)
  TYPE(Vector4Cell_T), POINTER :: Rhs(:)
  TYPE(VectorSFace_T), POINTER :: ThetaF(:)
  TYPE(VelocityFace_T), POINTER :: PreFacF(:)
  TYPE(ScalarCell_T), POINTER :: SoundFac(:)
  REAL(RealKind) :: Time,dt
  CHARACTER*10 :: MethAdvOri

  INTEGER :: ibLoc
  REAL(RealKind) :: tt
  VelocityFaceAct=>VelocityFace
  IF (ThetaKind=='Energy') THEN
    DO ibLoc=1,nbLoc
      ib=LocGlob(ibLoc)
      CALL DomainSet(ib)
      Rho=>RhoCell(ibLoc)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      p=>PreKin(ibLoc)%c
      KinEn=>KinEnCell(ibLoc)%c
      CALL PreCompute
    END DO  
    CALL ExchangeCell(PreKin) 
  END IF  
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    DO ic=uPosL,wPosR
      IF (ic>0) THEN
        c=>VecUCell(ibLoc)%Vec(ic)%c
        f=>Rhs(ibLoc)%Vec(ic)%c
        IF (Advection) THEN
          CALL AdvectionCompute(PhiLim)
        END IF 
      END IF  
    END DO
    IF (Diffusion) THEN
      uCL=>VecUCell(ibLoc)%Vec(uPosL)%c
      vCL=>VecUCell(ibLoc)%Vec(vPosL)%c
      wCL=>VecUCell(ibLoc)%Vec(wPosL)%c
      uCR=>VecUCell(ibLoc)%Vec(uPosR)%c
      vCR=>VecUCell(ibLoc)%Vec(vPosR)%c
      wCR=>VecUCell(ibLoc)%Vec(wPosR)%c
      IF (TkeDis.OR.TkeOme) THEN 
        DH=>DiffKoeff(ibLoc)%c
        DV=>DiffKoeff(ibLoc)%c
      ELSE IF (TkeHVLen) THEN
        DH=>DiffHKoeff(ibLoc)%c
        DV=>DiffVKoeff(ibLoc)%c
      ELSE IF (TkeSGS.OR.NoTke) THEN
        DH=>DiffMomKoeff(ibLoc)%c
        DV=>DiffMomKoeff(ibLoc)%c
      ELSE IF (TkeSmag) THEN
        DH=>DiffMomHKoeff(ibLoc)%c
        DV=>DiffMomVKoeff(ibLoc)%c
      ELSE IF (DynSmag) THEN
        DH=>DiffMomHKoeff(ibLoc)%c
        DV=>DiffMomVKoeff(ibLoc)%c
      ELSE
        DH=>DiffKoeff(ibLoc)%c
        DV=>DiffKoeff(ibLoc)%c
      END IF
      DO ic=uPosL,wPosR
        c=>VecUCell(ibLoc)%Vec(ic)%c
        f=>Rhs(ibLoc)%Vec(ic)%c
        IF (ic==uPosL.AND.CrossDiff) THEN
          uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
          uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
          CALL DiffusionComputeU
        ELSE IF (ic==uPosR.AND.CrossDiff) THEN
        ELSE IF (ic==vPosL.AND.CrossDiff) THEN
          vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
          vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
          CALL DiffusionComputeV
        ELSE IF (ic==vPosR.AND.CrossDiff) THEN
        ELSE IF (ic==wPosL.AND.CrossDiff) THEN
          wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
          wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
          CALL DiffusionComputeW
        ELSE IF (ic==wPosR.AND.CrossDiff) THEN
        ELSE 
          CALL DiffusionCompute
        END IF
      END DO
!     Diffusion for scalars      
      IF (TkeDis.OR.TkeOme) THEN 
        DH=>DiffKoeff(ibLoc)%c
        DV=>DiffKoeff(ibLoc)%c
      ELSE IF (TkeHVLen) THEN
        DH=>DiffHKoeff(ibLoc)%c
        DV=>DiffVKoeff(ibLoc)%c
      ELSE IF (TkeSGS.OR.NoTke) THEN
        DH=>DiffPotKoeff(ibLoc)%c
        DV=>DiffPotKoeff(ibLoc)%c
      ELSE IF (TkeSmag) THEN
        DH=>DiffPotHKoeff(ibLoc)%c
        DV=>DiffPotVKoeff(ibLoc)%c
      ELSE IF (DynSmag) THEN
        DH=>DiffPotHKoeff(ibLoc)%c
        DV=>DiffPotVKoeff(ibLoc)%c
      ELSE
        DH=>DiffKoeff(ibLoc)%c
        DV=>DiffKoeff(ibLoc)%c
      END IF
      DO ic=1,UBOUND(VectorCell(ibLoc)%Vec,1)
        IF (ic<uPosL.OR.ic>wPosR) THEN
          c=>VectorCell(ibLoc)%Vec(ic)%c
          f=>Rhs(ibLoc)%Vec(ic)%c
          IF (TkeDis) THEN 
            DV=DV/PrandtlNumber(ic)
          ELSE IF (TkeHVLen) THEN
            DV=DV/PrandtlNumber(ic)
            DH=DH/PrandtlNumber(ic)
          ELSE
            DV=DV/PrandtlNumber(ic)
          END IF
          CALL DiffusionCompute
          IF (TkeDis) THEN 
            DV=DV*PrandtlNumber(ic)
          ELSE IF (TkeHVLen) THEN
            DV=DV*PrandtlNumber(ic)
            DH=DH*PrandtlNumber(ic)
          ELSE
            DV=DV*PrandtlNumber(ic)
          END IF
        END IF
      END DO
    END IF
    IF (ThetaKind=='PreEn'.OR.ThetaKind=='Exner') THEN 
      Sound=>SoundFac(ibLoc)%c
      Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      Th=>VectorCell(ibLoc)%Vec(thPos)%c
      CALL SoundCompute
    END IF
    IF (RainSurf) THEN
      CALL RainSurfCompute(VectorCell(ibLoc),Velocityface(ibLoc),Rhs(ibLoc),ibLoc,Time)
    END IF
    IF (DragSurf) THEN
      CALL Drag(VectorCell(ibLoc),Velocityface(ibLoc),Rhs(ibLoc),VecUCell(ibLoc),ibLoc=ibLoc,Time=Time)
    END IF
    IF (Baum) THEN 
      CALL BaumDrag(VectorCell(ibLoc),Velocityface(ibLoc),Rhs(ibLoc),ibLoc) 
    END IF
  END DO
  IF (ASSOCIATED(SoundFac)) THEN
    CALL ExchangeCell(SoundFac) 
  END IF  
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    IF (ThetaKind=='PreEn'.OR.ThetaKind=='Exner') THEN 
      Sound=>SoundFac(ibLoc)%c
      Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
      f=>Rhs(ibLoc)%Vec(thPos)%c
      c=>VectorCell(ibLoc)%Vec(thPos)%c
      IF (PreAdv=='Inner') THEN
        c=c-Sound
        CALL AdvectionPreCompute(PhiLim)  
        c=c+Sound
      ELSE
        CALL AdvectionPreCompute(PhiLim)  
      END IF
    END IF  
    IF (PGradient.AND.ThetaKind=='Energy') THEN
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
      DUU=>DUUG(ibLoc)%uF
      DUV=>DUUG(ibLoc)%vF
      DUW=>DUUG(ibLoc)%wF
      p=>PreKin(ibLoc)%c
      Rho=>RhoCell(ibLoc)%c
      CALL PGradComputeC
    END IF

  END DO

  CALL ExchangeFlux(Rhs)

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    DO ic=1,UBOUND(Rhs(ibLoc)%Vec,1)
      f=>Rhs(ibLoc)%Vec(ic)%c
      CALL AdvectionScale
    END DO
    IF (Coriolis) THEN
      IF (CoriolisFree) THEN
        RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
        Th=>VectorCell(ibLoc)%Vec(thPos)%c
        ThProf=>ThProfG(ibLoc)%c
        Rho=>RhoCell(ibLoc)%c
        uCL=>VecUCell(ibLoc)%Vec(uPosL)%c
        vCL=>VecUCell(ibLoc)%Vec(vPosL)%c
        wCL=>VecUCell(ibLoc)%Vec(wPosL)%c
        uCR=>VecUCell(ibLoc)%Vec(uPosR)%c
        vCR=>VecUCell(ibLoc)%Vec(vPosR)%c
        wCR=>VecUCell(ibLoc)%Vec(wPosR)%c
        uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
        vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
        wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
        uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
        vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
        wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
        IF (Sphere) THEN
          CALL CoriolisFreeComputeLR
        ELSE IF (Cylinder) THEN
          CALL CoriolisCylFreeComputeLR
        ELSE
          CALL CoriolisFreeComputeLR
        END IF
      ELSE
        RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
        Th=>VectorCell(ibLoc)%Vec(thPos)%c
        ThProf=>ThProfG(ibLoc)%c
        Rho=>RhoCell(ibLoc)%c
        uCL=>VecUCell(ibLoc)%Vec(uPosL)%c
        vCL=>VecUCell(ibLoc)%Vec(vPosL)%c
        wCL=>VecUCell(ibLoc)%Vec(wPosL)%c
        uCR=>VecUCell(ibLoc)%Vec(uPosR)%c
        vCR=>VecUCell(ibLoc)%Vec(vPosR)%c
        wCR=>VecUCell(ibLoc)%Vec(wPosR)%c
        uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
        vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
        wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
        uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
        vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
        wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
        uE=>VecEnv1(ibLoc)%Vec(uPosEnv)%c
        vE=>VecEnv1(ibLoc)%Vec(vPosEnv)%c
        Call CoriolisCompute
      END IF
    END IF
    IF (Forcing) THEN
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      p=>PreCell(ibLoc)%c
      Th=>VectorCell(ibLoc)%Vec(ThPos)%c
      T=>TAbsCell(ibLoc)%Vec(1)%c
      CALL ForceVelCompute(Time)
      CALL ForceScalarCompute(Rhs(ibLoc)%Vec,Time)
      CALL AbsTCompute
    END IF
    IF (Damping) THEN
      DampKoeff=>DampKoeffCell(ibLoc)%c
      Rho=>RhoCell(ibLoc)%c
      DO ic=1,SIZE(VecEnv1(ibLoc)%Vec)
        ce1=>VecEnv1(ibLoc)%Vec(ic)%c
        ce2=>VecEnv2(ibLoc)%Vec(ic)%c
        IF (PosE2Pos(ic)==uPosL) THEN
          f=>Rhs(ibLoc)%Vec(uPosL)%c
          c=>VecUCell(ibLoc)%Vec(uPosL)%c
          CALL DampingCompute(Time)
          f=>Rhs(ibLoc)%Vec(uPosR)%c
          c=>VecUCell(ibLoc)%Vec(uPosR)%c
          CALL DampingCompute(Time)
        ELSE IF (PosE2Pos(ic)==vPosL) THEN
          f=>Rhs(ibLoc)%Vec(vPosL)%c
          c=>VecUCell(ibLoc)%Vec(vPosL)%c
          CALL DampingCompute(Time)
          f=>Rhs(ibLoc)%Vec(vPosR)%c
          c=>VecUCell(ibLoc)%Vec(vPosR)%c
          CALL DampingCompute(Time)
        ELSE IF (PosE2Pos(ic)==wPosL) THEN
          f=>Rhs(ibLoc)%Vec(wPosL)%c
          c=>VecUCell(ibLoc)%Vec(wPosL)%c
          CALL DampingCompute(Time)
          f=>Rhs(ibLoc)%Vec(wPosR)%c
          c=>VecUCell(ibLoc)%Vec(wPosR)%c
          CALL DampingCompute(Time)
        ELSE
          f=>Rhs(ibLoc)%Vec(PosE2Pos(ic))%c
          c=>VectorCell(ibLoc)%Vec(PosE2Pos(ic))%c
          CALL DampingCompute(Time)
        END IF
      END DO
    END IF
    IF (Canopy) THEN
      CALL CanopyDrag(VectorCell(ibLoc),Rhs(ibLoc),ibLoc,VecUCell(ibLoc))
    END IF
    IF (Wind) THEN
      CALL WindDrag(VectorCell(ibLoc),Rhs(ibLoc),ibLoc,VecUCell(ibLoc))
    END IF
    CALL Turbulence(VectorCell(ibLoc),Rhs(ibLoc),ibLoc,VecUCell(ibLoc))
    IF (Chemie) THEN
      TAbs=>TAbsCell(ibLoc)%Vec(1)
      RhoC=>RhoCell(ibLoc)
      cVec=>VectorCell(ibLoc)%Vec
      fVec=>Rhs(ibLoc)%Vec
      IF (Emiss) THEN
        CALL EmissionCompute(Time)
        CALL EmissionPointCompute(Time,ibLoc)
      END IF
      IF (EmissStreet) THEN 
        CALL EmissionStreetCompute(Time,ibLoc) 
      END IF
    END IF
    IF (Cloud.AND..NOT.CloudFast) THEN
      Rho=>RhoCell(ibLoc)%c
      IF (MicroScheme=='Bulk') THEN
        CALL BulkMicro(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc)
      ELSE IF (MicroScheme=='Bulk2') THEN
        CALL BulkMicro2(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc,VelocityFace(:))
      ELSE IF (MicroScheme=='LSC') THEN
        CALL LSCMicro(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc)
      END IF    
    END IF    

    Rho=>RhoCell(ibLoc)%c
    DO ic=1,UBOUND(ThetaF(ibLoc)%VecF,1)
      c=>VectorCell(ibLoc)%Vec(ic)%c
      cFU=>ThetaF(ibLoc)%VecF(ic)%uF
      cFV=>ThetaF(ibLoc)%VecF(ic)%vF
      cFW=>ThetaF(ibLoc)%VecF(ic)%wF
      cFU=Zero
      cFV=Zero
      cFW=Zero
      IF (ic==enPos.AND.ThetaKind=='PreEn') THEN
!       Separation of E (slow) and p (fast)
        c=>VectorCell(ibLoc)%Vec(EnPos)%c
        p=>VectorCell(ibLoc)%Vec(thPos)%c
!       c=c+p
        CALL AdvectionFaceCompute(PhiLim)
!       c=c-p
      ELSE IF (ic==thPos.AND.(ThetaKind=='PreEn'.OR.ThetaKind=='Exner')) THEN 
        c=>SoundFac(ibLoc)%c
        CALL AdvectionFaceCompute(PhiLim)
      ELSE IF (ic==thPos.AND.ThetaKind=='Energy') THEN 
        c=>VectorCell(ibLoc)%Vec(thPos)%c
        p=>PreCell(ibLoc)%c
        c=c+p
        CALL AdvectionFaceCompute(PhiLim)
        c=c-p
      ELSE IF (ic==qrPos.OR.ic==nrPos) THEN
        CALL AdvectionFaceCompute(PhiLim,FallF)
      ELSE
        CALL AdvectionFaceCompute(PhiLim)
      END IF  
    END DO
    IF (LinearPressure) THEN
      dpdtheta=>PreCell(ibLoc)%c
      Th=>VectorCell(ibLoc)%Vec(ThPos)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      CALL DpDThetaCompute
    END IF
!   IF (Precip) THEN
!     CALL DomainSet(ib)
!     CALL SetVelocityFace(ibLoc)
!     Rho=>RhoCell(ibLoc)%c
!     RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
!     RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
!     RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
!     p=>PreCell(ibLoc)%c
!     IF (ASSOCIATED(TAbsCell)) THEN
!       T=>TAbsCell(ibLoc)%Vec(1)%c
!     END IF  
!     RhoRhs=>Rhs(ibLoc)%Vec(RhoPos)%c  
!     ThRhs=>Rhs(ibLoc)%Vec(ThPos)%c
!     DO ic=1,UBOUND(VectorCell(ibLoc)%Vec,1)
!       c=>VectorCell(ibLoc)%Vec(ic)%c
!       IF (ic==RhoPos.OR.ic==ThPos) THEN
!         CALL AdvectionQFallCompute(PhiLim1,FallF)
!       END IF
!     END DO    
!   END IF !Precip
  END DO
  CALL ExchangeCell(PreCell) 
  CALL ExchangeScalarFace(ThetaF) 
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    IF (LinearPressure) THEN
      uF=>PreFacF(ibLoc)%uF
      vF=>PreFacF(ibLoc)%vF
      wF=>PreFacF(ibLoc)%wF
      uC=>PreCell(ibLoc)%c
      vC=>PreCell(ibLoc)%c
      wC=>PreCell(ibLoc)%c
      CALL VelCellToFaceCompute
    END IF
  END DO
END SUBROUTINE FcnMetSlow

SUBROUTINE FcnMetFastU(VectorCell,VelF,PreFacF,RhsF,Time)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), POINTER :: VelF(:)
  TYPE(VelocityFace_T), POINTER :: PreFacF(:)
  TYPE(VelocityFace_T), POINTER :: RhsF(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc
  INTEGER :: iz

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    p=>PreCell(ibLoc)%c
    th=>VectorCell(ibLoc)%Vec(thPos)%c
    T=>TAbsCell(ibLoc)%Vec(1)%c
    Rho=>VectorCell(ibLoc)%Vec(rhoPos)%c
    IF (PGradient.AND..NOT.LinearPressure) THEN
      Rho=>RhoCell(ibLoc)%c
      RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
!     CALL RhoTotalCompute
      IF (qcPos==0) THEN 
        RhoL=>RhoLCell(ibLoc)%c
      END IF  
      Rho=>VectorCell(ibLoc)%Vec(rhoPos)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      CALL AbsTCompute
      CALL PreCompute
    END IF
    IF (DivDamp>Zero) THEN
      uF=>VelF(ibLoc)%uF
      vF=>VelF(ibLoc)%vF
      wF=>VelF(ibLoc)%wF
      DivC=>DivCell(ibLoc)%c
      CALL DivFCompute
    END IF
  END DO
  IF (DivDamp>Zero) THEN
    CALL ExchangeCell(DivCell)
  END IF
  IF (PGradient) THEN
    IF (LinearPressure) THEN
      CALL Assign(DummyCell,VectorCell,ThPos)
      CALL ExchangeCell(DummyCell)
    ELSE
      CALL ExchangeCell(PreCell)
    END IF  
  END IF  
  CALL Assign(DummyCell,VectorCell,RhoPos)
  CALL ExchangeCell(DummyCell)
  
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)

    uFRhs=>RhsF(ibLoc)%uF
    vFRhs=>RhsF(ibLoc)%vF
    wFRhs=>RhsF(ibLoc)%wF
    IF (PGradient) THEN
      IF (LinearPressure) THEN
        pFU=>PreFacF(ibLoc)%uF
        pFV=>PreFacF(ibLoc)%vF
        pFW=>PreFacF(ibLoc)%wF
        th=>VectorCell(ibLoc)%Vec(thPos)%c
        CALL PGradComputeFLin
      ELSE
        p=>PreCell(ibLoc)%c
        CALL PGradComputeF
      END IF
    END IF
    IF (PGradient.AND.DivDamp>Zero) THEN
      p=>DivCell(ibLoc)%c
      CALL DivergenceDampCompute
    END IF
    IF (Buoyancy) THEN
      RhoD=>VectorCell(ibLoc)%Vec(RhoPos)%c
      Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      Th=>VectorCell(ibLoc)%Vec(thPos)%c
      ThProf=>ThProfG(ibLoc)%c
      p=>PreCell(ibLoc)%c
      Call AuftriebComputeF
    END IF
  END DO
  
END SUBROUTINE FcnMetFastU

SUBROUTINE FcnMetFastU1(VectorCell,VelF,PreFacF,RhsF,Time)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), POINTER :: VelF(:)
  TYPE(VelocityFace_T), POINTER :: PreFacF(:)
  TYPE(VelocityFace_T), POINTER :: RhsF(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc
  INTEGER :: iz

  ! Only with nonlinear pressure
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    p=>PreCell(ibLoc)%c
    th=>VectorCell(ibLoc)%Vec(thPos)%c
    T=>TAbsCell(ibLoc)%Vec(1)%c
    Rho=>VectorCell(ibLoc)%Vec(rhoPos)%c
    RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
    RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
    RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
    CALL AbsTPreCompute
  END DO
  IF (PGradient) THEN
    CALL ExchangeCell(PreCell)
  END IF  
  CALL Assign(DummyCell,VectorCell,RhoPos)
  CALL ExchangeCell(DummyCell)
  
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)

    uFRhs=>RhsF(ibLoc)%uF
    vFRhs=>RhsF(ibLoc)%vF
    wFRhs=>RhsF(ibLoc)%wF
    IF (PGradient) THEN
      CALL PGradComputeF
    END IF
    IF (Buoyancy) THEN
      Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
      Call AuftriebComputeF
    END IF
  END DO
  
END SUBROUTINE FcnMetFastU1

SUBROUTINE FcnMetFastScalar(VectorCell,Velocityface,ThetaF,SoundFac,Rhs,Time)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), POINTER :: VelocityFace(:)
  TYPE(VectorSFace_T), POINTER :: ThetaF(:)
  TYPE(ScalarCell_T), POINTER :: SoundFac(:)
  TYPE(Vector4Cell_T), POINTER :: Rhs(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc

  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
    DO ic=1,UBOUND(ThetaF(ibLoc)%VecF,1)
      f=>Rhs(ibLoc)%Vec(ic)%c
      cFU=>ThetaF(ibLoc)%VecF(ic)%uF
      cFV=>ThetaF(ibLoc)%VecF(ic)%vF
      cFW=>ThetaF(ibLoc)%VecF(ic)%wF
      IF (Advection) THEN
        IF (ic==qrPos.OR.ic==nrPos) THEN ! precipitation
          vFall=FallVelocity(ic)
          RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
          CALL DivScalarCompute(FallF)
        ELSE
          CALL DivScalarCompute
        END IF
      END IF
    END DO
    IF (ThetaKind=='PreEn'.AND.EnPos>0) THEN
      p=>VectorCell(ibLoc)%Vec(ThPos)%c
      Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
      f=>Rhs(ibLoc)%Vec(EnPos)%c
      CALL DivEnCompute
    END IF  
  END DO

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    DO ic=1,UBOUND(Rhs(ibLoc)%Vec,1)
      f=>Rhs(ibLoc)%Vec(ic)%c
      CALL AdvectionScale
    END DO
    IF (ThetaKind=='PreEn'.OR.ThetaKind=='Exner') THEN
      Sound=>SoundFac(ibLoc)%c
      thRhs=>Rhs(ibLoc)%Vec(thPos)%c
      Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
    END IF  
    IF (Cloud.AND.CloudFast) THEN
      Rho=>RhoCell(ibLoc)%c
      IF (MicroScheme=='Bulk') THEN
        CALL BulkMicro(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc)
      ELSE IF (MicroScheme=='Bulk2') THEN
        CALL BulkMicro2(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc,Velocityface(:))
      ELSE IF (MicroScheme=='LSC') THEN
        CALL LSCMicro(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc)
      END IF 
    END IF
  END DO

END SUBROUTINE FcnMetFastScalar

SUBROUTINE FcnMetG(VectorCell,Velocityface,Rhs,Time,dt)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), POINTER :: VelocityFace(:)
  TYPE(Vector4Cell_T), POINTER :: VectorCellG(:)
  TYPE(Vector4Cell_T), POINTER :: Rhs(:)
  REAL(RealKind) :: Time,dt

  INTEGER :: ibLoc

  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    IF (Anelastic) THEN
      c=>RhoCell(ibLoc)%c
    ELSE IF (PseudoIn) THEN  
      c=>ThProfG(ibLoc)%c
    END IF  
    f=>Rhs(ibLoc)%Vec(1)%c
    CALL AdvectionCompute(PhiLim)
  END DO
  CALL ExchangeFlux(Rhs)

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    DO ic=1,SIZE(Rhs(ibLoc)%Vec)
      f=>Rhs(ibLoc)%Vec(ic)%c
      CALL AdvectionScale
    END DO
  END DO
END SUBROUTINE FcnMetG

SUBROUTINE FcnMet(VectorCell,Velocityface,Rhs,Time,dt,VectorCellG)

  TYPE(Vector4Cell_T), POINTER :: VectorCell(:)
  TYPE(VelocityFace_T), POINTER :: VelocityFace(:)
  TYPE(Vector4Cell_T), POINTER :: Rhs(:)
  REAL(RealKind) :: Time,dt
  TYPE(Vector4Cell_T), OPTIONAL, POINTER :: VectorCellG(:)

  INTEGER :: ibLoc
  INTEGER :: ix,iy,iz
  REAL(RealKind) :: tt
  REAL(RealKind) :: wLoc
  
  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    IF (Diffusion.AND.CrossDiff.AND.TkePos>0) THEN
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
      tke=>VectorCell(ibLoc)%Vec(tkePos)%c
      CALL TurbTke  
    END IF
  END DO  

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    IF (ASSOCIATED(TAbsCell)) THEN
      T=>TAbsCell(ibLoc)%Vec(1)%c
    END IF  
    IF (Advection) THEN
      DO ic=1,UBOUND(VectorCell(ibLoc)%Vec,1)
        c=>VectorCell(ibLoc)%Vec(ic)%c
        RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
        f=>Rhs(ibLoc)%Vec(ic)%c
        vFall=FallVelocity(ic)
        IF (ic==RhoPos) THEN
          c=>RhoCell(ibLoc)%c
          CALL AdvectionCompute(PhiLim)
        ELSE IF (ic==ThPos.AND.ThetaKind=='Energy') THEN
          p=>PreCell(ibLoc)%c
          c=c+p
          CALL AdvectionCompute(PhiLim)
          c=c-p
        ELSE IF (ic==enPos.AND.ThetaKind=='PreEn') THEN
          p=>VectorCell(ibLoc)%Vec(thPos)%c
          c=c+p
          CALL AdvectionCompute(PhiLim)
          c=c-p
        ELSE IF (ic==thPos.AND.ThetaKind=='PreEn') THEN 
          p=>SoundCell(ibLoc)%c
          IF (PreAdv=='Inner') THEN
            c=c-p
            CALL AdvectionPreCompute(PhiLim) 
            c=c+p
          ELSE
            CALL AdvectionPreCompute(PhiLim)
          END IF
        ELSE IF (ic==qrPos.OR.ic==nrPos) THEN
          CALL AdvectionCompute(PhiLim,FallF)
        ELSE
          CALL AdvectionCompute(PhiLim)
        END IF
      END DO     
    END IF
!   IF (ThetaKind=='PreEn'.AND.EnPos>0) THEN
!     p=>VectorCell(ibLoc)%Vec(thPos)%c
!     Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
!     f=>Rhs(ibLoc)%Vec(EnPos)%c
!     CALL DivEnCompute
!   END IF
    IF (ThetaKind=='PreEn'.AND.PreAdv=='Inner'.AND.ThPos>0) THEN
      Weight=>SoundCell(ibLoc)%c
      Rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
      Rho=>RhoCell(ibLoc)%c
      f=>Rhs(ibLoc)%Vec(thPos)%c
      CALL DivWeightCompute 
    END IF  
    IF (Diffusion) THEN
!     Diffusion for momentum      
      IF (uPosL>0) THEN
        IF (TkeDis.OR.TkeOme) THEN 
          DH=>DiffKoeff(ibLoc)%c
          DV=>DiffKoeff(ibLoc)%c
        ELSE IF (TkeHVLen) THEN
          DH=>DiffHKoeff(ibLoc)%c
          DV=>DiffVKoeff(ibLoc)%c
        ELSE IF (TkeSGS.OR.NoTke) THEN
          DH=>DiffMomKoeff(ibLoc)%c
          DV=>DiffMomKoeff(ibLoc)%c
        ELSE IF (TkeSmag) THEN
          DH=>DiffMomHKoeff(ibLoc)%c
          DV=>DiffMomVKoeff(ibLoc)%c
        ELSE IF (DynSmag) THEN
          DH=>DiffMomHKoeff(ibLoc)%c
          DV=>DiffMomVKoeff(ibLoc)%c
        ELSE
          DH=>DiffKoeff(ibLoc)%c
          DV=>DiffKoeff(ibLoc)%c
        END IF
        DO ic=uPosL,wPosR
          c=>VectorCell(ibLoc)%Vec(ic)%c
          f=>Rhs(ibLoc)%Vec(ic)%c
          IF (ic==uPosL.AND.CrossDiff) THEN
            uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
            uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
            vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
            vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
            wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
            wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
            uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
            uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
            CALL DiffusionComputeU
          ELSE IF (ic==uPosR.AND.CrossDiff) THEN
          ELSE IF (ic==vPosL.AND.CrossDiff) THEN
            vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
            vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
            uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
            uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
            vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
            vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
            wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
            wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
            CALL DiffusionComputeV
          ELSE IF (ic==vPosR.AND.CrossDiff) THEN
          ELSE IF (ic==wPosL.AND.CrossDiff) THEN
            wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
            wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
            uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
            uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
            vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
            vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
            wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
            wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
            CALL DiffusionComputeW
          ELSE IF (ic==wPosR.AND.CrossDiff) THEN
          ELSE 
            CALL DiffusionCompute
          END IF
        END DO
      END IF
!     Diffusion for scalars      
      IF (TkeDis.OR.TkeOme) THEN 
        DH=>DiffKoeff(ibLoc)%c
        DV=>DiffKoeff(ibLoc)%c
      ELSE IF (TkeHVLen) THEN
        DH=>DiffHKoeff(ibLoc)%c
        DV=>DiffVKoeff(ibLoc)%c
      ELSE IF (TkeSGS.OR.NoTke) THEN
        DH=>DiffPotKoeff(ibLoc)%c
        DV=>DiffPotKoeff(ibLoc)%c
      ELSE IF (TkeSmag) THEN
        DH=>DiffPotHKoeff(ibLoc)%c
        DV=>DiffPotVKoeff(ibLoc)%c
      ELSE IF (DynSmag) THEN
        DH=>DiffPotHKoeff(ibLoc)%c
        DV=>DiffPotVKoeff(ibLoc)%c
      ELSE
        DH=>DiffKoeff(ibLoc)%c
        DV=>DiffKoeff(ibLoc)%c
      END IF
      DO ic=1,UBOUND(VectorCell(ibLoc)%Vec,1)
        IF (ic<uPosL.OR.ic>wPosR) THEN
          c=>VectorCell(ibLoc)%Vec(ic)%c
          f=>Rhs(ibLoc)%Vec(ic)%c
          IF (TkeDis) THEN 
            DV=DV/PrandtlNumber(ic)
          ELSE IF (TkeHVLen) THEN
            DV=DV/PrandtlNumber(ic)
            DH=DH/PrandtlNumber(ic)
          ELSE
            DV=DV/PrandtlNumber(ic)
          END IF
          CALL DiffusionCompute
          IF (TkeDis) THEN 
            DV=DV*PrandtlNumber(ic)
          ELSE IF (TkeHVLen) THEN
            DV=DV*PrandtlNumber(ic)
            DH=DH*PrandtlNumber(ic)
          ELSE
            DV=DV*PrandtlNumber(ic)
          END IF
        END IF
      END DO
    END IF
    IF (RainSurf) THEN
      CALL RainSurfCompute(VectorCell(ibLoc),Velocityface(ibLoc),Rhs(ibLoc),ibLoc,Time)
    END IF
    IF (RadiationProfile) THEN
      CALL RadiationCompute(VectorCell(ibLoc),Velocityface(ibLoc),Rhs(ibLoc),ibLoc)
    END IF
    ! Surface drag and fluxes of momentum, heat and mass
    IF (DynamicSoil) THEN
      CALL Soil(VectorCell,Rhs,ibLoc,Time)
    ELSE IF (Canopy) THEN
      CALL CanopyCompute(VectorCell,Rhs,ibLoc,Time)
    ELSE IF (DragSurf) THEN
      CALL Drag(VectorCell(ibLoc),Velocityface(ibLoc),Rhs(ibLoc),ibLoc=ibLoc,Time=Time)
    END IF
    IF (Baum) THEN 
      CALL BaumDrag(VectorCell(ibLoc),Velocityface(ibLoc),Rhs(ibLoc),ibLoc) 
    END IF

    IF (PGradient) THEN
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
      DUU=>DUUG(ibLoc)%uF
      DUV=>DUUG(ibLoc)%vF
      DUW=>DUUG(ibLoc)%wF
      IF (Anelastic.OR.PseudoIn) THEN
        p=>VectorCellG(ibLoc)%Vec(1)%c
      ELSE
        p=>PreCell(ibLoc)%c
      END IF
      Rho=>RhoCell(ibLoc)%c
      th=>VectorCell(ibLoc)%Vec(thPos)%c
      rho=>VectorCell(ibLoc)%Vec(RhoPos)%c
      CALL PGradComputeC
    END IF
  END DO
  
! IF (Precip) THEN
!   DO ibLoc=1,nbLoc
!     ib=LocGlob(ibLoc)
!     CALL DomainSet(ib)
!     CALL SetVelocityFace(ibLoc)
!     Rho=>RhoCell(ibLoc)%c
!     RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
!     RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
!     RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
!     p=>PreCell(ibLoc)%c
!     IF (ASSOCIATED(TAbsCell)) THEN
!       T=>TAbsCell(ibLoc)%Vec(1)%c
!     END IF  
!     RhoRhs=>Rhs(ibLoc)%Vec(RhoPos)%c  
!     ThRhs=>Rhs(ibLoc)%Vec(ThPos)%c
!     DO ic=1,UBOUND(VectorCell(ibLoc)%Vec,1)
!       c=>VectorCell(ibLoc)%Vec(ic)%c
!       IF (ic==RhoPos.OR.ic==ThPos) THEN
!         CALL AdvectionQFallCompute(PhiLim1,FallF)
!       END IF
!     END DO    
!   END DO
! END IF !Precip

  CALL ExchangeFlux(Rhs)
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    DO ic=1,UBOUND(VectorCell(ibLoc)%Vec,1)
      f=>Rhs(ibLoc)%Vec(ic)%c
      CALL AdvectionScale
    END DO
    IF (ThetaKind=='PreEn'.AND.PreAdv=='Outer') THEN
      thRhs=>Rhs(ibLoc)%Vec(thPos)%c
      T=>TAbsCell(ibLoc)%Vec(1)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      Sound=>SoundCell(ibLoc)%c
      CALL DivPreCompute
    END IF
    CALL Turbulence(VectorCell(ibLoc),Rhs(ibLoc),ibLoc)
    IF (Forcing) THEN
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
      p=>PreCell(ibLoc)%c
      Th=>VectorCell(ibLoc)%Vec(ThPos)%c
      T=>TAbsCell(ibLoc)%Vec(1)%c
      CALL ForceVelCompute(Time)
      CALL ForceScalarCompute(Rhs(ibLoc)%Vec,Time)
      CALL AbsTCompute
    END IF
    IF (Damping) THEN
      DampKoeff=>DampKoeffCell(ibLoc)%c
      Rho=>RhoCell(ibLoc)%c
      DO ic=1,SIZE(VecEnv1(ibLoc)%Vec)
        f=>Rhs(ibLoc)%Vec(PosE2Pos(ic))%c
        c=>VectorCell(ibLoc)%Vec(PosE2Pos(ic))%c
        ce1=>VecEnv1(ibLoc)%Vec(ic)%c
        ce2=>VecEnv2(ibLoc)%Vec(ic)%c
        CALL DampingCompute(Time)
        IF (PosE2Pos(ic)==uPosL) THEN
          f=>Rhs(ibLoc)%Vec(uPosR)%c
          c=>VectorCell(ibLoc)%Vec(uPosR)%c
          CALL DampingCompute(Time)
        ELSE IF (PosE2Pos(ic)==vPosL) THEN
          f=>Rhs(ibLoc)%Vec(vPosR)%c
          c=>VectorCell(ibLoc)%Vec(vPosR)%c
          CALL DampingCompute(Time)
        ELSE IF (PosE2Pos(ic)==wPosL) THEN
          f=>Rhs(ibLoc)%Vec(wPosR)%c
          c=>VectorCell(ibLoc)%Vec(wPosR)%c
          CALL DampingCompute(Time)
        END IF
      END DO
    END IF
    IF (Cloud) THEN
      Rho=>RhoCell(ibLoc)%c
      IF (MicroScheme=='Bulk') THEN
        CALL BulkMicro(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc)
      ELSE IF (MicroScheme=='Bulk2') THEN
        CALL BulkMicro2(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc,Velocityface(:))
      ELSE IF (MicroScheme=='LSC') THEN
        CALL LSCMicro(VectorCell(ibLoc)%Vec(1:),Rhs(ibLoc)%Vec(1:),ibLoc)
      END IF 
    END IF
    IF (Buoyancy) THEN
      fL=>Rhs(ibLoc)%Vec(wPosL)%c
      fR=>Rhs(ibLoc)%Vec(wPosR)%c
      IF (Anelastic) THEN
        Th=>VectorCell(ibLoc)%Vec(ThPos)%c
        ThProf=>ThProfG(ibLoc)%c
        Rho=>RhoCell(ibLoc)%c
      ELSE
        RhoD=>VectorCell(ibLoc)%Vec(rhoPos)%c
      END IF
      Call AuftriebDryComputeLR
    END IF
    IF (Parcel) THEN
      cVec=>VectorCell(ibLoc)%Vec
      fVec=>Rhs(ibLoc)%Vec
      IF (TrajIn) THEN 
        CALL RelaxationParcel(cVec,fVec,Time,ibLoc)
      ELSE  
        CALL Adiabatic(cVec,fVec,Time,ibLoc)
      END IF  
      IF (DilutParcel) THEN
        CALL DilutionParcel(cVec,fVec,Time,ibLoc)
      END IF
    END IF
    IF (Shallow.AND.Height) THEN
      Rho=>RhoCell(ibLoc)%c
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      HeightC=>HeightG(ibLoc)%c
      CALL HeightComputeLR 
    END IF
    IF (Coriolis) THEN 
      IF (CoriolisFree) THEN
        Rho=>RhoCell(ibLoc)%c
        uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
        vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
        wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
        uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
        vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
        wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
        uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
        vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
        wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
        uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
        vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
        wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
        IF (Sphere) THEN
          CALL CoriolisFreeComputeLR 
        ELSE IF (Cylinder) THEN
          IF (Anelastic) THEN
            Th=>VectorCell(ibLoc)%Vec(ThPos)%c
            ThProf=>ThProfG(ibLoc)%c
          END IF   
          CALL CoriolisCylFreeComputeLR 
        ELSE
          CALL CoriolisFreeComputeLR 
        END IF
      ELSE
        Rho=>RhoCell(ibLoc)%c
        uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
        vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
        wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
        uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
        vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
        wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
        uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
        vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
        wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
        uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
        vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
        wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
        uE=>VecEnv1(ibLoc)%Vec(uPosEnv)%c
        vE=>VecEnv1(ibLoc)%Vec(vPosEnv)%c
        Call CoriolisCompute
      END IF
    END IF
    ! Add canopy drag terms to the momentum equations
    IF (Canopy) THEN
      CALL CanopyDrag(VectorCell(ibLoc),Rhs(ibLoc),ibLoc)
    END IF
    IF (Wind) THEN
      CALL WindDrag(VectorCell(ibLoc),Rhs(ibLoc),ibLoc)
    END IF
    IF (Curvature) THEN 
      Rho=>RhoCell(ibLoc)%c
      uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
      vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
      wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
      uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
      vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
      wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
      IF (Sphere) THEN
        Call CurvatureComputeLR
      ELSE IF (Cylinder) THEN
        Call CurvatureCylComputeLR
      END IF
    END IF
    IF (Centrifugal) THEN 
      Rho=>RhoCell(ibLoc)%c
      uRhsL=>Rhs(ibLoc)%Vec(uPosL)%c
      vRhsL=>Rhs(ibLoc)%Vec(vPosL)%c
      wRhsL=>Rhs(ibLoc)%Vec(wPosL)%c
      uRhsR=>Rhs(ibLoc)%Vec(uPosR)%c
      vRhsR=>Rhs(ibLoc)%Vec(vPosR)%c
      wRhsR=>Rhs(ibLoc)%Vec(wPosR)%c
      Th=>VectorCell(ibLoc)%Vec(ThPos)%c
      IF (Anelastic) THEN
        ThProf=>ThProfG(ibLoc)%c
      END IF  
      IF (Cylinder) THEN
        Call CentrifugalCylComputeLR
      ELSE
        Call CentrifugalComputeLR
      END IF
    END IF
    IF (Chemie) THEN
      IF (ChemieGas) Then
        TAbs=>TAbsCell(ibLoc)%Vec(1)
        RhoC=>RhoCell(ibLoc)
        IF (qcPos==0) THEN
          RhoLC=>RhoLCell(ibLoc)
        END IF
        cVec=>VectorCell(ibLoc)%Vec
        fVec=>Rhs(ibLoc)%Vec
        CALL GasChemie(cVec,fVec,TAbs)
      END IF
      IF (Aerosol) THEN
        TAbs=>TAbsCell(ibLoc)%Vec(1)
        RhoC=>RhoCell(ibLoc)
        IF (qcPos==0) THEN
          RhoLC=>RhoLCell(ibLoc)
        END IF
        cVec=>VectorCell(ibLoc)%Vec
        fVec=>Rhs(ibLoc)%Vec
        AVec=>Act(ibLoc)%Vec
        CALL ComputeActivity(cVec,AVec,TAbsCell(ibLoc)%Vec(1))  
        IF (ChemieAqua) THEN
          CALL AquaChemie(cVec,fVec,TAbs,AVec)
          CALL DissChemie(cVec,fVec,TAbs,AVec)
          CALL SolidChemie(cVec,fVec,TAbs,AVec)
        END IF
        CALL Condensation(cVec,fVec,HenryTrans,AVec)
        IF (Koagul) THEN
          CALL Koagulation(cVec,fVec)
        END IF
      END IF
      IF (Emiss) THEN
        TAbs=>TAbsCell(ibLoc)%Vec(1)
        RhoC=>RhoCell(ibLoc)
        IF (qcPos==0) THEN
          RhoLC=>RhoLCell(ibLoc)
        END IF
        cVec=>VectorCell(ibLoc)%Vec
        fVec=>Rhs(ibLoc)%Vec
        CALL EmissionCompute(Time)
        CALL EmissionPointCompute(Time,ibLoc)
      END IF
      IF (EmissStreet) THEN 
        CALL EmissionStreetCompute(Time,ibLoc) 
      END IF
      IF (Depos) THEN
        TAbs=>TAbsCell(ibLoc)%Vec(1)
        RhoC=>RhoCell(ibLoc)
        IF (qcPos==0) THEN
          RhoLC=>RhoLCell(ibLoc)
        END IF
        cVec=>VectorCell(ibLoc)%Vec
        fVec=>Rhs(ibLoc)%Vec
        CALL Deposition(VelocityFace,ibLoc)
      END IF
    END IF
  END DO  

END SUBROUTINE FcnMet

SUBROUTINE JacMeteo(VectorCell,VelocityFace,JacMatrix,Time)

  TYPE(Vector4Cell_T) :: VectorCell(:)
  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  TYPE(JacSpMatrix4_T) :: JacMatrix(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    Rho=>RhoCell(ibLoc)%c
    AT=>JacMatrix(ibLoc)%JacTMom
    AFall=>JacMatrix(ibLoc)%JacFall
    AFallRhoL=>JacMatrix(ibLoc)%JacFallRhoL
    CALL SetVelocityFace(ibLoc)
    IF (JacAdvection.AND.Advection) THEN
      IF (JacPartial) THEN
        FU=>DUJac(ibLoc)%uF
        FV=>DUJac(ibLoc)%vF
        FW=>DUJac(ibLoc)%wF
      END IF  
      IF (Advection) THEN
        RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
        RhoR=>VectorCell(ibLoc)%Vec(qrPos)%c
        IF (qcPos==0.AND.iWater.NE.0) THEN
          RhoL=>RhoLCell(ibLoc)%c
        END IF
        IF (qrPos>0) THEN
          CALL JacAdvectionCompute(FallF) 
        ELSE
          CALL JacAdvectionCompute
        END IF
      END IF
      IF (JacPartial) THEN
        FU=>Floor(ib)%WeiFU
        FV=>Floor(ib)%WeiFV
        FW=>Floor(ib)%WeiFW
      END IF  
    END IF 
    IF (JacDiffusion.AND.Diffusion) THEN
      IF (JacPartial) THEN
        FU=>DUJac(ibLoc)%uF
        FV=>DUJac(ibLoc)%vF
        FW=>DUJac(ibLoc)%wF
      END IF  
      IF (TkeHVLen) THEN
        DH=>DiffHKoeff(ibLoc)%c
        DV=>DiffVKoeff(ibLoc)%c
        CALL JacDiffusionCompute
      ELSE IF (TkeSGS.OR.NoTke) THEN
        JacMatrix(ibLoc)%JacTPot=JacMatrix(ibLoc)%JacTMom
        DH=>DiffMomKoeff(ibLoc)%c
        DV=>DiffMomKoeff(ibLoc)%c
        CALL JacDiffusionCompute
        DH=>DiffPotKoeff(ibLoc)%c
        DV=>DiffPotKoeff(ibLoc)%c
        AT=>JacMatrix(ibLoc)%JacTPot
        CALL JacDiffusionCompute
      ELSE IF (TkeSmag) THEN
        JacMatrix(ibLoc)%JacTPot=JacMatrix(ibLoc)%JacTMom
        DH=>DiffMomHKoeff(ibLoc)%c
        DV=>DiffMomVKoeff(ibLoc)%c
        CALL JacDiffusionCompute
        DH=>DiffPotHKoeff(ibLoc)%c
        DV=>DiffPotVKoeff(ibLoc)%c
        AT=>JacMatrix(ibLoc)%JacTPot
        CALL JacDiffusionCompute
      ELSE IF (DynSmag) THEN
        JacMatrix(ibLoc)%JacTPot=JacMatrix(ibLoc)%JacTMom
        DH=>DiffMomHKoeff(ibLoc)%c
        DV=>DiffMomVKoeff(ibLoc)%c
        CALL JacDiffusionCompute
        DH=>DiffPotHKoeff(ibLoc)%c
        DV=>DiffPotVKoeff(ibLoc)%c
        AT=>JacMatrix(ibLoc)%JacTPot
        CALL JacDiffusionCompute
      ELSE
        DH=>DiffKoeff(ibLoc)%c
        DV=>DiffKoeff(ibLoc)%c
        CALL JacDiffusionCompute
      END IF
      IF (JacPartial) THEN
        FU=>Floor(ib)%WeiFU
        FV=>Floor(ib)%WeiFV
        FW=>Floor(ib)%WeiFW
      END IF  
    END IF
    ATMom=>JacMatrix(ibLoc)%JacTMom
    ATPot=>JacMatrix(ibLoc)%JacTPot
    CALL JacScaleCompute

    AS=>JacMatrix(ibLoc)%JacSLU%Mat
    DiagP=>JacMatrix(ibLoc)%JacSLU%Struct%DiagPtr(:)
    Permu=>JacMatrix(ibLoc)%JacSLU%Struct%Permu(:)
    IF (DynamicSoil) THEN
      CALL JacSoil(VectorCell(ibLoc),AS,ibLoc)
    ELSE IF (Canopy) THEN
      CALL JacCanopyCompute(JacMatrix(ibLoc)%JacSLU, VectorCell(ibLoc),AS,ibLoc)
    ELSE IF (DragSurf) THEN
      CALL JacDrag(VectorCell(ibLoc),Velocityface(ibLoc),AS,ibLoc)
    END IF
    IF (RainSurf) THEN
      CALL JacRainSurf(VectorCell(ibLoc),AS,ibLoc)
    END IF
    IF (Baum) THEN 
      CALL JacBaumDrag(VectorCell(ibLoc),AS,ibLoc) 
    END IF
    CALL JacTurbulence(VectorCell(ibLoc),AS,ibLoc)
    IF (Damping) THEN
      DampKoeff=>DampKoeffCell(ibLoc)%c
      DO icE=1,SIZE(VecEnv1(ibLoc)%Vec)
        ic=PosE2Pos(icE)
        Diag=DiagP(Permu(ic))
        CALL JacDampingCompute 
        IF (ic==uPosL) THEN
          ic=uPosR
          Diag=DiagP(Permu(ic))
          CALL JacDampingCompute 
        ELSE IF (ic==vPosL) THEN
          ic=vPosR
          Diag=DiagP(Permu(ic))
          CALL JacDampingCompute 
        ELSE IF (ic==wPosL) THEN
          ic=wPosR
          Diag=DiagP(Permu(ic))
          CALL JacDampingCompute 
        END IF
      END DO
    END IF
    IF (Parcel) THEN
      cVec=>VectorCell(ibLoc)%Vec
      dfVec=>JacMatrix(ibLoc)%JacSLU%Mat
      IF (TrajIn) THEN 
!       CALL RelaxationParcelJac(cVec,fVec,Time,ib)
      ELSE  
        CALL AdiabaticJac(cVec,dfVec,Time,ibLoc)
      END IF  
      IF (DilutParcel) THEN
        CALL DilutionParcelJac(cVec,dfVec,JacMatrix(ibLoc)%JacSLU,Time,ibLoc)
      END IF
    END IF
    IF (Cloud) THEN
      Rho=>RhoCell(ibLoc)%c
      th=>VectorCell(ibLoc)%Vec(thPos)%c
      RhoV=>VectorCell(ibLoc)%Vec(qvPos)%c
      qv=>VectorCell(ibLoc)%Vec(qvPos)%c
      qc=>VectorCell(ibLoc)%Vec(qcPos)%c
      qr=>VectorCell(ibLoc)%Vec(qrPos)%c
      IF (qcPos>0) THEN
        RhoL=>VectorCell(ibLoc)%Vec(qcPos)%c
      ELSE
        RhoL=>RhoLCell(ibLoc)%c
        qc=>RhoLCell(ibLoc)%c
      END IF  
      IF (MicroScheme=='Bulk') THEN
        CALL BulkMicroJac(VectorCell(ibLoc)%Vec(1:),JacMatrix(ibLoc)%JacSLU%Mat,ibLoc)
      ELSE IF (MicroScheme=='Bulk2') THEN
        CALL BulkMicroJac2(VectorCell(ibLoc)%Vec(1:),JacMatrix(ibLoc)%JacSLU%Mat,ibLoc,Velocityface(:))
      ELSE IF (MicroScheme=='LSC') THEN
        CALL LSCMicroJac(VectorCell(ibLoc)%Vec(1:),JacMatrix(ibLoc)%JacSLU%Mat,ibLoc)
      END IF
      IF (Buoyancy) THEN
        wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
        wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
        CALL JacAuftriebDryComputeLR
      END IF
    ELSE
      IF (Buoyancy) THEN
        wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
        wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
        IF (Anelastic) THEN
          ThProf=>ThProfG(ibLoc)%c
          Rho=>RhoCell(ibLoc)%c
        END IF
!       CALL JacAuftriebDryComputeLR 
      END IF
    END IF
    IF (Coriolis) THEN
      Rho=>RhoCell(ibLoc)%c
      Th=>VectorCell(ibLoc)%Vec(ThPos)%c
      ThProf=>ThProfG(ibLoc)%c
      IF (Sphere) THEN
        CALL JacCoriolisCompute
      ELSE IF (Cylinder) THEN
        CALL JacCoriolisCylCompute
      ELSE
        CALL JacCoriolisCompute
      END IF
    END IF
    ! Add canopy drag terms to the momentum equations
    IF (Canopy .AND. (.NOT. DynamicSoil) .AND. (.NOT. DragSurf)) THEN
      CALL JacCanopyDrag(VectorCell(ibLoc),AS,ibLoc)
    END IF
    IF (Curvature) THEN
      Rho=>RhoCell(ibLoc)%c
      uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
      uCR=>VectorCell(ibLoc)%Vec(uPosL)%c
      vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
      vCR=>VectorCell(ibLoc)%Vec(vPosL)%c
      IF (Sphere) THEN
        CALL JacCurvatureCompute 
      ELSE IF (Cylinder) THEN
        CALL JacCurvatureCylCompute
      END IF
    END IF
    IF (Centrifugal) THEN 
      uPosJac=uPosLJac
      vPosJac=vPosLJac
      wPosJac=wPosLJac
      Rho=>RhoCell(ibLoc)%c
      IF (Anelastic) THEN
        Th=>VectorCell(ibLoc)%Vec(ThPos)%c
        ThProf=>ThProfG(ibLoc)%c
      END IF
      IF (Cylinder) THEN
        Call JacCentrifugalCylComputeLR
      ELSE
        Call JacCentrifugalComputeLR
      END IF
      uPosJac=uPosRJac
      vPosJac=vPosRJac
      wPosJac=wPosRJac
      IF (Cylinder) THEN
        Call JacCentrifugalCylComputeLR
      ELSE
        Call JacCentrifugalComputeLR
      END IF
    END IF
    IF (Chemie) THEN
      IF (ChemieGas) THEN
        cVec=>VectorCell(ibLoc)%Vec
        dfVec=>JacMatrix(ibLoc)%JacSLU%Mat
        TAbs=>TAbsCell(ibLoc)%Vec(1)
        RhoC=>RhoCell(ibLoc)
        IF (qcPos==0) THEN
          RhoLC=>RhoLCell(ibLoc)
        END IF
        CALL GasChemieJac(cVec,dfVec,TAbs)
      END IF
      IF (Aerosol) THEN
        cVec=>VectorCell(ibLoc)%Vec
        dfVec=>JacMatrix(ibLoc)%JacSLU%Mat
        TAbs=>TAbsCell(ibLoc)%Vec(1)
        RhoC=>RhoCell(ibLoc)
        IF (qcPos==0) THEN
          RhoLC=>RhoLCell(ibLoc)
        END IF
        AVec=>Act(ibLoc)%Vec
        CALL ComputeActivity(cVec,AVec,TAbsCell(ibLoc)%Vec(1))  
        IF (ChemieAqua) THEN
          CALL AquaChemieJac(cVec,dfVec,TAbs,AVec)
          CALL DissChemieJac(cVec,dfVec,TAbs,AVec)
          CALL SolidChemieJac(cVec,dfVec,TAbs,AVec)
        END IF
        CALL CondensationJac(cVec,dfVec,HenryTrans,AVec)
      END IF
    END IF
    IF (Depos) THEN
      CALL DepositionJac(JacMatrix(ibLoc)%JacSLU,VelocityFace,ibLoc,cVec,dfVec)
    END IF
    CALL Gefa(JacMatrix(ibLoc)%JacSLU)
  END DO
END SUBROUTINE JacMeteo

SUBROUTINE Limiter(VectorT,VectorT1)

  TYPE (Vector4Cell_T) :: VectorT(:)
  TYPE (Vector4Cell_T) :: VectorT1(:)
  INTEGER :: ibLoc

  DO ibLoc=1,nbLoc
    ib = LocGlob(ibLoc)
    CALL Set(Floor(ib))
    CALL LimiterCompute(VectorT(ibLoc)%Vec(1:nAqua),VectorT1(ibLoc)%Vec(1:nAqua))
  END DO
  CALL ExchangeCell(VectorT)

END SUBROUTINE Limiter

SUBROUTINE JacScaleCompute

  INTEGER :: ix,iy,iz,iDiag
  INTEGER :: nxP2,nyP2,nzP2

  nxP2=ix1-ix0+2
  nyP2=iy1-iy0+2
  nzP2=iz1-iz0+2

  IF (TypeW(1:1)/='o') THEN
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        i=Index(ix,iy,iz)
        ATMom%Val(i,4)=ATMom%Val(i,4)-ATMom%Val(i,3)
      END DO
    END DO
  END IF
  IF (TypeE(1:1)/='o') THEN
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        i=Index(ix+1,iy,iz)
        ATMom%Val(i,4)=ATMom%Val(i,4)-ATMom%Val(i,5)
      END DO
    END DO
  END IF
  IF (TypeS(1:1)/='o') THEN
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        i=Index(ix,iy,iz)
        ATMom%Val(i,4)=ATMom%Val(i,4)-ATMom%Val(i,2)
      END DO
    END DO
  END IF
  IF (TypeN(1:1)/='o') THEN
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        i=Index(ix,iy+1,iz)
        ATMom%Val(i,4)=ATMom%Val(i,4)-ATMom%Val(i,6)
      END DO
    END DO
  END IF

  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        i=Index(ix,iy,iz)
        ATMom%Val(i,4)=ATMom%Val(i,4)-ATMom%Val(i,1)
      END DO
    END DO
  END IF
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        i=Index(ix,iy,iz+1)
        ATMom%Val(i,4)=ATMom%Val(i,4)-ATMom%Val(i,7)
        AFall%Val(i,1)=AFall%Val(i,1)-AFall%Val(i,2)
      END DO
    END DO
    IF (ASSOCIATED(AFallRhoL%Val)) THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          i=Index(ix,iy,iz+1)
          AFallRhoL%Val(i,1)=AFallRhoL%Val(i,1)-AFallRhol%Val(i,2)
        END DO
      END DO
    END IF
  END IF

  ATMom%Val(1:ATMom%n,ATMom%Diag)=One-(beta0*dt)*ATMom%Val(1:ATMom%n,ATMom%Diag)
  DO iDiag=1,ATMom%NumDiag
    IF (ATMom%DiagPtr(iDiag)/=0) THEN
      ATMom%Val(1:ATMom%n,iDiag)=-(beta0*dt)*ATMom%Val(1:ATMom%n,iDiag) 
    END IF
  END DO
  DO iDiag=1,AFall%NumDiag
    AFall%Val(1:AFall%n,iDiag)=-(beta0*dt)*AFall%Val(1:AFall%n,iDiag) 
  END DO
  IF (ASSOCIATED(AFallRhoL%Val)) THEN
    DO iDiag=1,AFallRhoL%NumDiag
      AFallRhoL%Val(1:AFall%n,iDiag)=-(beta0*dt)*AFallRhoL%Val(1:AFall%n,iDiag) 
    END DO
  END IF
  IF (TkeSGS.OR.NoTke.OR.TkeSmag.OR.DynSmag) THEN
    IF (TypeW(1:1)/='o') THEN
      ix=ix0
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          i=Index(ix,iy,iz)
          ATPot%Val(i,4)=ATPot%Val(i,4)-ATPot%Val(i,3)
        END DO
      END DO
    END IF
    IF (TypeE(1:1)/='o') THEN
      ix=ix1
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          i=Index(ix+1,iy,iz)
          ATPot%Val(i,4)=ATPot%Val(i,4)-ATPot%Val(i,5)
        END DO
      END DO
    END IF
    IF (TypeS(1:1)/='o') THEN
      iy=iy0
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          i=Index(ix,iy,iz)
          ATPot%Val(i,4)=ATPot%Val(i,4)-ATPot%Val(i,2)
        END DO
      END DO
    END IF
    IF (TypeN(1:1)/='o') THEN
      iy=iy1
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          i=Index(ix,iy+1,iz)
          ATPot%Val(i,4)=ATPot%Val(i,4)-ATPot%Val(i,6)
        END DO
      END DO
    END IF
    IF (TypeB(1:1)/='o') THEN
      iz=iz0
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          i=Index(ix,iy,iz)
          ATPot%Val(i,4)=ATPot%Val(i,4)-ATPot%Val(i,1)
        END DO
      END DO
    END IF
    IF (TypeT(1:1)/='o') THEN
      iz=iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          i=Index(ix,iy,iz+1)
          ATPot%Val(i,4)=ATPot%Val(i,4)-ATPot%Val(i,7)
        END DO
      END DO
    END IF
    ATPot%Val(1:ATPot%n,ATPot%Diag)=One-(beta0*dt)*ATPot%Val(1:ATPot%n,ATPot%Diag)
    DO iDiag=1,ATPot%NumDiag
      IF (ATPot%DiagPtr(iDiag)/=0) THEN
        ATPot%Val(1:ATPot%n,iDiag)=-(beta0*dt)*ATPot%Val(1:ATPot%n,iDiag) 
      END IF
    END DO
  END IF
    
CONTAINS
FUNCTION Index(ix,iy,iz)
  INTEGER :: Index,ix,iy,iz
  Index=ix-ix0+1+nxP2*(iy-iy0)+nxP2*nyP2*(iz-iz0)  
END FUNCTION Index
END SUBROUTINE JacScaleCompute


SUBROUTINE VelocityCellToFace(VectorCell,VelocityFace)

  TYPE(Vector4Cell_T), TARGET :: VectorCell(:)
  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)

  INTEGER :: ibLoc

  VectorCellAct=>VectorCell
  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVectorCell(ibLoc)
    CALL SetVelocityFace(ibLoc)
    CALL VelCellToFaceCompute
  END DO
END SUBROUTINE VelocityCellToFace

SUBROUTINE VelocityCellToFaceLR(VectorCell,VelocityFace,VelFOld,Time)

  TYPE(Vector4Cell_T), TARGET :: VectorCell(:)
  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  TYPE(VelocityFace_T), TARGET :: VelFOld(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc
  INTEGER :: iz

  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    uFOld=>VelFOld(ibLoc)%uF
    vFOld=>VelFOld(ibLoc)%vF
    wFOld=>VelFOld(ibLoc)%wF
    uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
    vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
    wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
    uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
    vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
    wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
    CALL VelCellToFaceComputeLR(Time)
  END DO
END SUBROUTINE VelocityCellToFaceLR


SUBROUTINE VelocityFaceToCell(VelocityFace,VectorCell)

  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  TYPE(Vector4Cell_T), TARGET :: VectorCell(:)

  INTEGER :: ibLoc,ic

  VectorCellAct=>VectorCell
  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVectorCell(ibLoc)
    CALL SetVelocityFace(ibLoc)
    CALL VelFaceToCellCompute
  END DO
END SUBROUTINE VelocityFaceToCell

SUBROUTINE VelocityFaceToCellLR(VelocityFace,VectorCell)

  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  TYPE(Vector4Cell_T), TARGET :: VectorCell(:)

  INTEGER :: ibLoc,ic

  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    uCL=>VectorCell(ibLoc)%Vec(uPosL)%c
    vCL=>VectorCell(ibLoc)%Vec(vPosL)%c
    wCL=>VectorCell(ibLoc)%Vec(wPosL)%c
    uCR=>VectorCell(ibLoc)%Vec(uPosR)%c
    vCR=>VectorCell(ibLoc)%Vec(vPosR)%c
    wCR=>VectorCell(ibLoc)%Vec(wPosR)%c
    Rho=>RhoCell(ibLoc)%c
    CALL VelFaceToCellComputeLR
!   CALL VelFaceToCellComputeLRC 
  END DO
  CALL ExchangeCell(VectorCell)
END SUBROUTINE VelocityFaceToCellLR

SUBROUTINE BoundaryConditionT(VectorCell,Time)
 
  TYPE(Vector4Cell_T), TARGET :: VectorCell(:)
  REAL(RealKind) :: Time
 
  INTEGER :: ibLoc,ic
 
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    DO ic=1,UBOUND(VectorCell(ibLoc)%Vec,1)
      c=>VectorCell(ibLoc)%Vec(ic)%c
      CALL BoundaryComputeZeroGrad
    END DO
  END DO
END SUBROUTINE BoundaryConditionT
 
SUBROUTINE BoundaryCondition(VectorCell,Time)
 
  TYPE(Vector4Cell_T), TARGET :: VectorCell(:)
  REAL(RealKind) :: Time
 
  INTEGER :: ibLoc,ic
 
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    DO ic=LBOUND(VectorCell(ibLoc)%Vec,1)+1,UBOUND(VectorCell(ibLoc)%Vec,1)
      c=>VectorCell(ibLoc)%Vec(ic)%c
      Rho=>RhoCell(ibLoc)%c
      BC=>BCVec(ic)
      IF      (ic==  uPosL) THEN
      ELSE IF (ic==  vPosL) THEN
      ELSE IF (ic==  wPosL) THEN
      ELSE IF (ic==  uPosR) THEN
      ELSE IF (ic==  vPosR) THEN
      ELSE IF (ic==  wPosR) THEN
      ELSE IF (ic== thPos) THEN
        CALL BoundaryCompute(   ThStart,Time,ic)
      ELSE IF (ic== EnPos) THEN
        CALL BoundaryCompute(   EnStart,Time,ic)
      ELSE IF (ic== RhoPos) THEN
        CALL BoundaryCompute(   RhoStart,Time,ic)
      ELSE IF (ic==tkePos) THEN
        CALL BoundaryCompute(  TkeStart,Time,ic)
      ELSE IF (ic==disPos) THEN
        CALL BoundaryCompute(  DisStart,Time,ic)
      ELSE IF (ic==omePos) THEN
        CALL BoundaryCompute(  OmeStart,Time,ic)
      ELSE IF (ic==tkeHPos) THEN
        CALL BoundaryCompute(  TkeHStart,Time,ic)
      ELSE IF (ic==tkeVPos) THEN
        CALL BoundaryCompute(  TkeVStart,Time,ic)
      ELSE IF (ic==LenPos) THEN
        CALL BoundaryCompute(  LenStart,Time,ic)
      ELSE IF (ic== qvPos) THEN
        CALL BoundaryCompute(   QvStart,Time,ic)
      ELSE IF (ic== qcPos) THEN
        CALL BoundaryCompute(   QcStart,Time,ic)
      ELSE IF (ic== qrPos) THEN
        CALL BoundaryCompute(   QrStart,Time,ic)
      ELSE IF (ic== qiPos) THEN
        CALL BoundaryCompute(   QiStart,Time,ic)
      ELSE IF (ic== qsPos) THEN
        CALL BoundaryCompute(   QsStart,Time,ic)
      ELSE IF (ic== nvPos) THEN
        CALL BoundaryCompute(   NvStart,Time,ic)
      ELSE IF (ic== ncPos) THEN
        CALL BoundaryCompute(   NcStart,Time,ic)
      ELSE IF (ic== nrPos) THEN
        CALL BoundaryCompute(   NrStart,Time,ic)
      ELSE IF (ic== niPos) THEN
        CALL BoundaryCompute(   NiStart,Time,ic)
      ELSE IF (ic== nsPos) THEN
        CALL BoundaryCompute(   NsStart,Time,ic)
      ELSE IF (ic== tracer1Pos) THEN
        CALL BoundaryCompute(Tracer1Start,Time,ic)
      ELSE IF (ic== tracer2Pos) THEN
        CALL BoundaryCompute(Tracer2Start,Time,ic)
      ELSE
        CALL BoundaryCompute(DummyStart,Time,ic)
      END IF
    END DO
  END DO

END SUBROUTINE BoundaryCondition

SUBROUTINE BoundaryVelocityFace(VelocityFace,Time)
 
  TYPE(VelocityFace_T), TARGET :: VelocityFace(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc

  VelocityFaceAct=>VelocityFace
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    Rho=>RhoCell(ibLoc)%c
    CALL DomainSet(ib)
    CALL SetVelocityFace(ibLoc)
    CALL BoundaryVelocityFaceCompute(Time)
  END DO

END SUBROUTINE BoundaryVelocityFace

SUBROUTINE BoundaryVelocityCell(VelocityCell,Time)
 
  TYPE(Vector4Cell_T), TARGET :: VelocityCell(:)
  REAL(RealKind) :: Time

  INTEGER :: ibLoc

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    Rho=>RhoCell(ibLoc)%c
    uC=>VelocityCell(ibLoc)%Vec(uPosL)%c
    vC=>VelocityCell(ibLoc)%Vec(vPosL)%c
    wC=>VelocityCell(ibLoc)%Vec(wPosL)%c
    CALL BoundaryVelocityCellCompute(Time)
    uC=>VelocityCell(ibLoc)%Vec(uPosR)%c
    vC=>VelocityCell(ibLoc)%Vec(vPosR)%c
    wC=>VelocityCell(ibLoc)%Vec(wPosR)%c
    CALL BoundaryVelocityCellCompute(Time)
  END DO

END SUBROUTINE BoundaryVelocityCell

SUBROUTINE UpdateScalarCell(alpha,x,y)
  
  REAL(RealKind) :: alpha
  TYPE(ScalarCell_T) :: x(:)
  TYPE(ScalarCell_T) :: y(:)

  INTEGER :: ibLoc

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    c=>y(ibLoc)%c
    f=>x(ibLoc)%c
    CALL AdvectionUpdate(alpha)
  END DO

END SUBROUTINE UpdateScalarCell

SUBROUTINE ScaleScalarCell(x)

  TYPE(ScalarCell_T) :: x(:)

  INTEGER :: ibLoc

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    f=>x(ibLoc)%c
    CALL AdvectionScale
  END DO

END SUBROUTINE ScaleScalarCell

SUBROUTINE UpdateVectorCell(alpha,x,y)

  REAL(RealKind) :: alpha
  TYPE(Vector4Cell_T) :: x(:)
  TYPE(Vector4Cell_T) :: y(:)

  INTEGER :: ibLoc,ic

  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    DO ic=1,SIZE(x(ibLoc)%Vec)
      c=>y(ibLoc)%Vec(ic)%c
      f=>x(ibLoc)%Vec(ic)%c
      CALL AdvectionUpdate(alpha)
    END DO
  END DO

END SUBROUTINE UpdateVectorCell

SUBROUTINE ScaleVectorCell(x)

  TYPE(Vector4Cell_T) :: x(:)

  INTEGER :: ibLoc,ic

  CALL ExchangeFlux(x)
  DO ibLoc=1,nbLoc
    ib=LocGlob(ibLoc)
    CALL DomainSet(ib)
    DO ic=1,SIZE(x(ibLoc)%Vec)
      f=>x(ibLoc)%Vec(ic)%c
      CALL AdvectionScale
    END DO
  END DO
END SUBROUTINE ScaleVectorCell

SUBROUTINE DomainSet(ib)

  INTEGER, INTENT(IN) :: ib

  CALL Set(Floor(ib))

END SUBROUTINE DomainSet


SUBROUTINE SetVelocityFace(ibLoc)

  INTEGER, INTENT(IN) :: ibLoc

  uF=>VelocityFaceAct(ibLoc)%uF
  vF=>VelocityFaceAct(ibLoc)%vF
  wF=>VelocityFaceAct(ibLoc)%wF

END SUBROUTINE SetVelocityFace

SUBROUTINE SetVectorCell(ibLoc)

  INTEGER, INTENT(IN) :: ibLoc

  uC=>VectorCellAct(ibLoc)%Vec(uPosL)%c
  vC=>VectorCellAct(ibLoc)%Vec(vPosL)%c
  wC=>VectorCellAct(ibLoc)%Vec(wPosL)%c

END SUBROUTINE SetVectorCell

SUBROUTINE VelCellToFaceCompute

  INTEGER :: ix,iy,iz
  INTEGER :: jx,jy,jz
  INTEGER :: in
  REAL(RealKind) :: VolCoarse,VolFine
  REAL(RealKind) :: uCoarse,uFine,uFace
  REAL(RealKind) :: vCoarse,vFine,vFace
  REAL(RealKind) :: wCoarse,wFine,wFace

  uF=Zero
  vF=Zero
  wF=Zero
  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1)) 
            uFine= &
               SUM(uC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps 
             uCoarse=uC(ix0,jy,jz,1)
             uFace=(uCoarse*VolCoarse+uFine*VolFine)/ &
                   (VolFine+VolCoarse+Eps) 
             uF(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)= &
                uFace*FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)/ &
                      (FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jz=jz0+1,jz1
            uF(ix0,jy,jz)= &
                          (uC(ix0,jy,jz,1)*VolC(ix0,jy,jz)+ &
                           uC(ix0+1,jy,jz,1)*VolC(ix0+1,jy,jz))/ &
                          (VolC(ix0+1,jy,jz)+VolC(ix0,jy,jz)+Eps)* &
                           FU(ix0,jy,jz)/(FU(ix0,jy,jz)+Eps)
          END DO
        END DO
      END IF
    END IF

    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)) 
            uFine= &
               SUM(uC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps 
             uCoarse=uC(ix1+1,jy,jz,1)
             uFace=(uCoarse*VolCoarse+uFine*VolFine)/ &
                   (VolFine+VolCoarse+Eps) 
             uF(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)= &
                uFace*FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)/ &
                      (FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jz=jz0+1,jz1
            uF(ix1,jy,jz)= &
                          (uC(ix1,jy,jz,1)*VolC(ix1,jy,jz)+ &
                           uC(ix1+1,jy,jz,1)*VolC(ix1+1,jy,jz))/ &
                          (VolC(ix1+1,jy,jz)+VolC(ix1,jy,jz)+Eps)* &
                           FU(ix1,jy,jz)/(FU(ix1,jy,jz)+Eps)
          END DO
        END DO
      END IF
    END IF

    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1)) 
            vFine= &
               SUM(vC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps 
             vCoarse=vC(jx,iy0,jz,1)
             vFace=(vCoarse*VolCoarse+vFine*VolFine)/ &
                   (VolFine+VolCoarse+Eps) 
             vF(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)= &
                vFace*FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)/ &
                      (FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            vF(jx,iy0,jz)= &
                          (vC(jx,iy0,jz,1)*VolC(jx,iy0,jz)+ &
                           vC(jx,iy0+1,jz,1)*VolC(jx,iy0+1,jz))/ &
                          (VolC(jx,iy0+1,jz)+VolC(jx,iy0,jz)+Eps)* &
                           FV(jx,iy0,jz)/(FV(jx,iy0,jz)+Eps)
          END DO
        END DO
      END IF
    END IF

    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)) 
            vFine= &
               SUM(vC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps 
             vCoarse=vC(jx,iy1+1,jz,1)
             vFace=(vCoarse*VolCoarse+vFine*VolFine)/ &
                   (VolFine+VolCoarse+Eps) 
             vF(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)= &
                vFace*FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)/ &
                      (FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            vF(jx,iy1,jz)= &
                          (vC(jx,iy1,jz,1)*VolC(jx,iy1,jz)+ &
                           vC(jx,iy1+1,jz,1)*VolC(jx,iy1+1,jz))/ &
                          (VolC(jx,iy1+1,jz)+VolC(jx,iy1,jz)+Eps)* &
                           FV(jx,iy1,jz)/(FV(jx,iy1,jz)+Eps)
          END DO
        END DO
      END IF
    END IF

    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jy=jy0+1,jy1,IncrY
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1)) 
            wFine= &
               SUM(wC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps 
             wCoarse=wC(jx,jy,iz0,1)
             wFace=(wCoarse*VolCoarse+wFine*VolFine)/ &
                   (VolFine+VolCoarse+Eps) 
             wF(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)= &
                wFace*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)/ &
                      (FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            wF(jx,jy,iz0)= &
                          (wC(jx,jy,iz0,1)*VolC(jx,jy,iz0)+ &
                           wC(jx,jy,iz0+1,1)*VolC(jx,jy,iz0+1))/ &
                          (VolC(jx,jy,iz0+1)+VolC(jx,jy,iz0)+Eps)* &
                           FW(jx,jy,iz0)/(FW(jx,jy,iz0)+Eps)
          END DO
        END DO
      END IF
    END IF

    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jy=jy0+1,jy1,IncrY
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)) 
            wFine= &
               SUM(wC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps 
             wCoarse=wC(jx,jy,iz1+1,1)
             wFace=(wCoarse*VolCoarse+wFine*VolFine)/ &
                   (VolFine+VolCoarse+Eps) 
             wF(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)= &
                wFace*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)/ &
                      (FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            wF(jx,jy,iz1)= &
                          (wC(jx,jy,iz1,1)*VolC(jx,jy,iz1)+ &
                           wC(jx,jy,iz1+1,1)*VolC(jx,jy,iz1+1))/ &
                          (VolC(jx,jy,iz1+1)+VolC(jx,jy,iz1)+Eps)* &
                           FW(jx,jy,iz1)/(FW(jx,jy,iz1)+Eps)
          END DO
        END DO
      END IF
    END IF
  END DO


  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        uF(ix,iy,iz)= &
                     (uC(ix,iy,iz,1)*VolC(ix,iy,iz)+ &
                      uC(ix+1,iy,iz,1)*VolC(ix+1,iy,iz))/ &
                     (VolC(ix+1,iy,iz)+VolC(ix,iy,iz)+Eps)* &
                      FU(ix,iy,iz)/(FU(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        vF(ix,iy,iz)= &
                     (vC(ix,iy,iz,1)*VolC(ix,iy,iz)+ &
                      vC(ix,iy+1,iz,1)*VolC(ix,iy+1,iz))/ &
                     (VolC(ix,iy+1,iz)+VolC(ix,iy,iz)+Eps)* &
                      FV(ix,iy,iz)/(FV(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        wF(ix,iy,iz)= &
                     (wC(ix,iy,iz,1)*VolC(ix,iy,iz)+ &
                      wC(ix,iy,iz+1,1)*VolC(ix,iy,iz))/ &
                     (VolC(ix,iy,iz+1)+VolC(ix,iy,iz)+Eps)* &
                      FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO

  IF (TypeW=='ow') THEN
    IF (BCVec(uPosL)%West=='ZeroGrad'.OR.BCVec(uPosL)%West=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix0,iy,iz)=uC(ix0+1,iy,iz,1) &
                                *FU(ix0,iy,iz)/(FU(ix0,iy,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeE=='oe') THEN
    IF (BCVec(uPosL)%East=='ZeroGrad'.OR.BCVec(uPosL)%East=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix1,iy,iz)=uC(ix1,iy,iz,1) &
                                *FU(ix1,iy,iz)/(FU(ix1,iy,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeS=='os') THEN
    IF (BCVec(vPosL)%South=='ZeroGrad'.OR.BCVec(vPosL)%South=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy0,iz)=vC(ix,iy0+1,iz,1) &
                                *FV(ix,iy0,iz)/(FV(ix,iy0,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeN=='on') THEN
    IF (BCVec(vPosL)%North=='ZeroGrad'.OR.BCVec(vPosL)%North=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy1,iz)=vC(ix,iy1,iz,1) &
                                *FV(ix,iy1,iz)/(FV(ix,iy1,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeB=='ob') THEN
    IF (BCVec(wPosL)%Bottom=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz0)=wC(ix,iy,iz0+1,1) &
                                *FW(ix,iy,iz0)/(FW(ix,iy,iz0)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeT=='ot') THEN
    IF (BCVec(wPosL)%Top=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz1)=wC(ix,iy,iz1,1) &
                                *FW(ix,iy,iz1)/(FW(ix,iy,iz1)+eps)
        END DO
      END DO
    END IF
  END IF
  
END SUBROUTINE VelCellToFaceCompute

SUBROUTINE VelFaceToCellCompute

  REAL(RealKind) :: Time 

  INTEGER :: ix,iy,iz

  DO ix=ix0+1,ix1
    DO iy=iy0+1,iy1
      DO iz=iz0+1,iz1
        uC(ix,iy,iz,1)=          &
                (FU(ix-1,iy,iz)*uF(ix-1,iy,iz)+  &
                 FU(ix,iy,iz)*uF(ix,iy,iz)) / &
                (FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        vC(ix,iy,iz,1)=          &
                (FV(ix,iy-1,iz)*vF(ix,iy-1,iz)+  &
                 FV(ix,iy,iz)*vF(ix,iy,iz)) / &
                (FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        wC(ix,iy,iz,1)=          &
                (FW(ix,iy,iz-1)*wF(ix,iy,iz-1)+  &
                 FW(ix,iy,iz)*wF(ix,iy,iz)) /  &
                (FW(ix,iy,iz-1)+FW(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
END SUBROUTINE VelFaceToCellCompute

SUBROUTINE VelFaceToCellComputeLRC

  REAL(RealKind) :: Time 

  INTEGER :: ix,iy,iz

  DO ix=ix0+1,ix1
    DO iy=iy0+1,iy1
      DO iz=iz0+1,iz1
        uCL(ix,iy,iz,1)=          &
                (FU(ix-1,iy,iz)*uF(ix-1,iy,iz)+  &
                 FU(ix,iy,iz)*uF(ix,iy,iz)) / &
                (FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        uCR(ix,iy,iz,1)=uCL(ix,iy,iz,1)
        vCL(ix,iy,iz,1)=          &
                (FV(ix,iy-1,iz)*vF(ix,iy-1,iz)+  &
                 FV(ix,iy,iz)*vF(ix,iy,iz)) / &
                (FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        vCR(ix,iy,iz,1)=vCL(ix,iy,iz,1)
        wCL(ix,iy,iz,1)=          &
                (FW(ix,iy,iz-1)*wF(ix,iy,iz-1)+  &
                 FW(ix,iy,iz)*wF(ix,iy,iz)) /  &
                (FW(ix,iy,iz-1)+FW(ix,iy,iz)+Eps)
        wCR(ix,iy,iz,1)=wCL(ix,iy,iz,1)
      END DO
    END DO
  END DO
END SUBROUTINE VelFaceToCellComputeLRC

SUBROUTINE VelFaceToCellComputeLR


  INTEGER :: ix,iy,iz
  INTEGER :: jx,jy,jz
  INTEGER :: in
  REAL(RealKind) :: uFine,vFine,wFine,RhoFine
  REAL(RealKind) :: FUL,FUR
  REAL(RealKind) :: FVL,FVR
  REAL(RealKind) :: FWL,FWR
  REAL(RealKind) :: uLoc,vLoc,wLoc
  REAL(RealKind) :: n1,n2,n3
  REAL(RealKind) :: nu,nn

  DO ix=ix0+1,ix1
    DO iy=iy0+1,iy1
      DO iz=iz0+1,iz1
        uCL(ix,iy,iz,1)=Rho(ix,iy,iz,1) &
                       *(VolC(ix-1,iy,iz)+VolC(ix,iy,iz)) &
                       /(Rho(ix-1,iy,iz,1)*VolC(ix-1,iy,iz) &
                        +Rho(ix,iy,iz,1)*VolC(ix,iy,iz)+Eps) &
                        *uF(ix-1,iy,iz)          
        uCR(ix,iy,iz,1)=Rho(ix,iy,iz,1) &
                       *(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)) &
                       /(Rho(ix+1,iy,iz,1)*VolC(ix+1,iy,iz) &
                        +Rho(ix,iy,iz,1)*VolC(ix,iy,iz)+Eps) &
                        *uF(ix,iy,iz)          
        vCL(ix,iy,iz,1)=Rho(ix,iy,iz,1) &
                       *(VolC(ix,iy-1,iz)+VolC(ix,iy,iz)) &
                       /(Rho(ix,iy-1,iz,1)*VolC(ix,iy-1,iz) &
                        +Rho(ix,iy,iz,1)*VolC(ix,iy,iz)+Eps) &
                        *vF(ix,iy-1,iz)          
        vCR(ix,iy,iz,1)=Rho(ix,iy,iz,1) &
                       *(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)) &
                       /(Rho(ix,iy+1,iz,1)*VolC(ix,iy+1,iz) &
                        +Rho(ix,iy,iz,1)*VolC(ix,iy,iz)+Eps) &
                        *vF(ix,iy,iz)          
        wCL(ix,iy,iz,1)=Rho(ix,iy,iz,1) &
                       *(VolC(ix,iy,iz-1)+VolC(ix,iy,iz)) &
                       /(Rho(ix,iy,iz-1,1)*VolC(ix,iy,iz-1) &
                        +Rho(ix,iy,iz,1)*VolC(ix,iy,iz)+Eps) &
                        *wF(ix,iy,iz-1)          
        wCR(ix,iy,iz,1)=Rho(ix,iy,iz,1) &
                       *(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)) &
                       /(Rho(ix,iy,iz+1,1)*VolC(ix,iy,iz+1) &
                        +Rho(ix,iy,iz,1)*VolC(ix,iy,iz)+Eps) &
                        *wF(ix,iy,iz)          
        uCL(ix,iy,iz,1)=uF(ix-1,iy,iz)          
        uCR(ix,iy,iz,1)=uF(ix,iy,iz)          
        vCL(ix,iy,iz,1)=vF(ix,iy-1,iz)          
        vCR(ix,iy,iz,1)=vF(ix,iy,iz)          
        wCL(ix,iy,iz,1)=wF(ix,iy,iz-1)          
        wCR(ix,iy,iz,1)=wF(ix,iy,iz)          
      END DO
    END DO
  END DO
  IF (Sphere.AND.igy0==domain%igy0) THEN
    iy=iy0+1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        vCL(ix,iy,iz,1)=vF(ix,iy,iz)          
      END DO
    END DO
  END IF  
  IF (Sphere.AND.igy1==domain%igy1) THEN
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        vCR(ix,iy,iz,1)=vF(ix,iy-1,iz)          
      END DO
    END DO
  END IF  

  IF (FreeSlip) THEN
    DO i=1,NumBoundCell
      ix    =BoundCell(i)%ix
      iy    =BoundCell(i)%iy
      iz    =BoundCell(i)%iz
      CALL ShiftVel1(VolC(ix,iy,iz), &  
                    FU(ix-1,iy,iz),FU(ix,iy,iz), &
                    xP(ix-1),xP(ix), &
                    FV(ix,iy-1,iz),FV(ix,iy,iz), &
                    yP(iy-1),yP(iy), &
                    FW(ix,iy,iz-1),FW(ix,iy,iz), &
                    zP(iz-1),zP(iz), &
                    uF(ix-1,iy,iz),uF(ix,iy,iz), &
                    vF(ix,iy-1,iz),vF(ix,iy,iz), &
                    wF(ix,iy,iz-1),wF(ix,iy,iz), &
                    uCL(ix,iy,iz,1),uCR(ix,iy,iz,1), &
                    vCL(ix,iy,iz,1),vCR(ix,iy,iz,1), &
                    wCL(ix,iy,iz,1),wCR(ix,iy,iz,1))
    END DO
  ELSE
    DO i=1,NumBoundCell
      ix    =BoundCell(i)%ix
      iy    =BoundCell(i)%iy
      iz    =BoundCell(i)%iz
      CALL ShiftNoSlip(VolC(ix,iy,iz), &
                    FU(ix-1,iy,iz),FU(ix,iy,iz), &
                    xP(ix-1),xP(ix), &
                    FV(ix,iy-1,iz),FV(ix,iy,iz), &
                    yP(iy-1),yP(iy), &
                    FW(ix,iy,iz-1),FW(ix,iy,iz), &
                    zP(iz-1),zP(iz), &
                    uF(ix-1,iy,iz),uF(ix,iy,iz), &
                    vF(ix,iy-1,iz),vF(ix,iy,iz), &
                    wF(ix,iy,iz-1),wF(ix,iy,iz), &
                    uCL(ix,iy,iz,1),uCR(ix,iy,iz,1), &
                    vCL(ix,iy,iz,1),vCR(ix,iy,iz,1), &
                    wCL(ix,iy,iz,1),wCR(ix,iy,iz,1))
    END DO
  END IF

END SUBROUTINE VelFaceToCellComputeLR

SUBROUTINE ShiftVel(Vol, &
                    FUL,FUR, &
                    xL,xR, &
                    FVL,FVR, &
                    yL,yR, &
                    FWL,FWR, &
                    zL,zR, &
                    uL,uR,vL,vR,wL,wR, &
                    uCL,uCR,vCL,vCR,wCL,wCR)
                    

  REAL(RealKind) :: Vol
  REAL(RealKind) :: FUL,FUR
  REAL(RealKind) :: xL,xR
  REAL(RealKind) :: FVL,FVR
  REAL(RealKind) :: yL,yR
  REAL(RealKind) :: FWL,FWR
  REAL(RealKind) :: zL,zR
  REAL(RealKind) :: uL,uR,vL,vR,wL,wR
  REAL(RealKind) :: uCL,uCR,vCL,vCR,wCL,wCR

  REAL(RealKind) :: FL,xFL,yFL,zFL
  REAL(RealKind) :: n1,n2,n3
  REAL(RealKind) :: b(7)
  REAL(RealKind) :: A(7,4)
  INTEGER :: m,n
  INTEGER :: info

  INTEGER :: lwork=200
  REAL(RealKind) :: Work(200)
  
  m=7
  n=4

  IF (ABS(FUL-FUR)>1.d-7*MAX(FUL,FUR)) THEN
    xFL=MAX(MIN((Vol-FUR*xR+FUL*xL)/(FUL-FUR),xR),xL)
  ELSE
    xFL=Half*(xL+xR)
  END IF 
  IF (ABS(FVL-FVR)>1.d-7*MAX(FVL,FVR)) THEN
    yFL=MAX(MIN((Vol-FVR*yR+FVL*zL)/(FVL-FVR),yR),yL)
  ELSE
    yFL=Half*(yL+yR)
  END IF 
  IF (ABS(FWL-FWR)>1.d-7*MAX(FWL,FWR)) THEN
    zFL=MAX(MIN((Vol-FWR*zR+FWL*zL)/(FWL-FWR),zR),zL)
  ELSE
    zFL=Half*(zL+zR)
  END IF 

  n1=FUR-FUL 
  n2=FVR-FVL 
  n3=FWR-FWL 
  FL=SQRT(n1*n1+n2*n2+n3*n3) 

! FUL
  b(1)=FUL*uL
  A(1,1)=FUL
  A(1,2)=0.0d0
  A(1,3)=0.0d0
  A(1,4)=FUL*(xL-xFL)
! FUR
  b(2)=FUR*uR
  A(2,1)=FUR
  A(2,2)=0.0d0
  A(2,3)=0.0d0
  A(2,4)=FUR*(xR-xFL)
! FVL
  b(3)=FVL*vL
  A(3,1)=0.0d0
  A(3,2)=FVL
  A(3,3)=0.0d0
  A(3,4)=FVL*(yL-yFL)
! FVR
  b(4)=FVR*vR
  A(4,1)=0.0d0
  A(4,2)=FVR
  A(4,3)=0.0d0
  A(4,4)=FVR*(yR-yFL)
! FWL
  b(5)=FWL*wL
  A(5,1)=0.0d0
  A(5,2)=0.0d0
  A(5,3)=FWL
  A(5,4)=FWL*(zL-zFL)
! FWR
  b(6)=FWR*wR
  A(6,1)=0.0d0
  A(6,2)=0.0d0
  A(6,3)=FWR
  A(6,4)=FWR*(zR-zFL)
! FL 
  b(7)=0.0d0
  A(7,1)=n1
  A(7,2)=n2
  A(7,3)=n3
  A(7,4)=0.0d0
  A(7,:)=1.0d7*A(7,:)

  CALL DGELS('N',m,n,1,A,m,b,m,work,lwork,info) 
  IF (info>0) THEN
    WRITE(*,*) 'info aus DGELS',info
    STOP
  END IF

  IF (FUL>FUR) THEN
    uCL=uL 
    uCR=(FUR*uR+(FUL-FUR)*b(1))/FUL
  ELSE
    uCL=(FUL*uL+(FUR-FUL)*b(1))/FUR
    uCR=uR 
  END IF
  IF (FVL>FVR) THEN
    vCL=vL 
    vCR=(FVR*vR+(FVL-FVR)*b(2))/FVL
  ELSE
    vCL=(FVL*vL+(FVR-FVL)*b(2))/FVR
    vCR=vR 
  END IF
  IF (FWL>FWR) THEN
    wCL=wL 
    wCR=(FWR*wR+(FWL-FWR)*b(3))/FWL
  ELSE
    wCL=(FWL*wL+(FWR-FWL)*b(3))/FWR
    wCR=wR 
  END IF
    
END SUBROUTINE ShiftVel

SUBROUTINE ShiftVel1(Vol, &
                    FUL,FUR, &
                    xL,xR, &
                    FVL,FVR, &
                    yL,yR, &
                    FWL,FWR, &
                    zL,zR, &
                    uL,uR,vL,vR,wL,wR, &
                    uCL,uCR,vCL,vCR,wCL,wCR)
                    

  REAL(RealKind) :: Vol
  REAL(RealKind) :: FUL,FUR
  REAL(RealKind) :: xL,xR
  REAL(RealKind) :: FVL,FVR
  REAL(RealKind) :: yL,yR
  REAL(RealKind) :: FWL,FWR
  REAL(RealKind) :: zL,zR
  REAL(RealKind) :: uL,uR,vL,vR,wL,wR
  REAL(RealKind) :: uCL,uCR,vCL,vCR,wCL,wCR

  REAL(RealKind) :: FL,xFL,yFL,zFL
  REAL(RealKind) :: n1,n2,n3

  IF (FUL>FUR) THEN
    uCL=uL 
    uCR=(FUR*uR+(FUL-FUR)*uL)/(FUL+Eps)
  ELSE
    uCL=(FUL*uL+(FUR-FUL)*uR)/(FUR+Eps)
    uCR=uR 
  END IF
  IF (FVL>FVR) THEN
    vCL=vL 
    vCR=(FVR*vR+(FVL-FVR)*vL)/(FVL+Eps)
  ELSE
    vCL=(FVL*vL+(FVR-FVL)*vR)/(FVR+Eps)
    vCR=vR 
  END IF
  IF (FWL>FWR) THEN
    wCL=wL 
    wCR=(FWR*wR+(FWL-FWR)*wL)/(FWL+Eps)
  ELSE
    wCL=(FWL*wL+(FWR-FWL)*wR)/(FWR+Eps)
    wCR=wR 
  END IF
END SUBROUTINE ShiftVel1

SUBROUTINE ShiftVel2(Vol, &
                    FUL,FUR, &
                    xL,xR, &
                    FVL,FVR, &
                    yL,yR, &
                    FWL,FWR, &
                    zL,zR, &
                    uL,uR,vL,vR,wL,wR, &
                    uCL,uCR,vCL,vCR,wCL,wCR)


  REAL(RealKind) :: Vol
  REAL(RealKind) :: FUL,FUR
  REAL(RealKind) :: xL,xR
  REAL(RealKind) :: FVL,FVR
  REAL(RealKind) :: yL,yR
  REAL(RealKind) :: FWL,FWR
  REAL(RealKind) :: zL,zR
  REAL(RealKind) :: uL,uR,vL,vR,wL,wR
  REAL(RealKind) :: uCL,uCR,vCL,vCR,wCL,wCR

  REAL(RealKind) :: FL,xFL,yFL,zFL
  REAL(RealKind) :: n1,n2,n3
  REAL(RealKind) :: uLoc,vLoc,wLoc
  REAL(RealKind) :: nu,nn



  uLoc=(FUL*uL+FUR*uR)/(FUL+FUR+Eps)
  vLoc=(FVL*vL+FVR*vR)/(FVL+FVR+Eps)
  wLoc=(FWL*wL+FWR*wR)/(FWL+FWR+Eps)
! uLoc=(MAX(FUR-FUL,Zero)*uR+MAX(FUL-FUR,Zero)*uL)/(ABS(FUR-FUL)+Eps)
! vLoc=(MAX(FVR-FVL,Zero)*vR+MAX(FVL-FVR,Zero)*vL)/(ABS(FVR-FVL)+Eps)
! wLoc=(MAX(FWR-FWL,Zero)*wR+MAX(FWL-FWR,Zero)*wL)/(ABS(FWR-FWL)+Eps)
  n1=FUR-FUL
  n2=FVR-FVL
  n3=FWR-FWL
  nu=n1*uLoc+n2*vLoc+n3*wLoc
  nn=n1*n1+n2*n2+n3*n3
  uCL=(FUL*uL+MAX(FUR-FUL,Zero)*(uLoc-nu/nn*n1))/(MAX(FUL,FUR)+Eps)
  uCR=(FUR*uR+MAX(FUL-FUR,Zero)*(uLoc-nu/nn*n1))/(MAX(FUL,FUR)+Eps)
  vCL=(FVL*vL+MAX(FVR-FVL,Zero)*(vLoc-nu/nn*n2))/(MAX(FVL,FVR)+Eps)
  vCR=(FVR*vR+MAX(FVL-FVR,Zero)*(vLoc-nu/nn*n2))/(MAX(FVL,FVR)+Eps)
  wCL=(FWL*wL+MAX(FWR-FWL,Zero)*(wLoc-nu/nn*n3))/(MAX(FWL,FWR)+Eps)
  wCR=(FWR*wR+MAX(FWL-FWR,Zero)*(wLoc-nu/nn*n3))/(MAX(FWL,FWR)+Eps)

END SUBROUTINE ShiftVel2

SUBROUTINE ShiftNoSlip(Vol, &
                    FUL,FUR, &
                    xL,xR, &
                    FVL,FVR, &
                    yL,yR, &
                    FWL,FWR, &
                    zL,zR, &
                    uL,uR,vL,vR,wL,wR, &
                    uCL,uCR,vCL,vCR,wCL,wCR)


  REAL(RealKind) :: Vol
  REAL(RealKind) :: FUL,FUR
  REAL(RealKind) :: xL,xR
  REAL(RealKind) :: FVL,FVR
  REAL(RealKind) :: yL,yR
  REAL(RealKind) :: FWL,FWR
  REAL(RealKind) :: zL,zR
  REAL(RealKind) :: uL,uR,vL,vR,wL,wR
  REAL(RealKind) :: uCL,uCR,vCL,vCR,wCL,wCR


  uCL=FUL*uL/MAX(FUR,FUL)
  uCR=FUR*uR/MAX(FUR,FUL)
  vCL=FVL*vL/MAX(FVR,FVL)
  vCR=FVR*vR/MAX(FVR,FVL)
  wCL=FWL*wL/MAX(FWR,FWL)
  wCR=FWR*wR/MAX(FWR,FWL)
    
END SUBROUTINE ShiftNoSlip

SUBROUTINE VelCellToFaceComputeLR2(Time)

  REAL(RealKind) :: Time

  INTEGER :: ix,iy,iz
  INTEGER :: jx,jy,jz
  INTEGER :: in
  REAL(RealKind) :: VolCoarse,VolFine
  REAL(RealKind) :: FL,FC,FR
  REAL(RealKind) :: uCoarse,uFine,uFace
  REAL(RealKind) :: vCoarse,vFine,vFace
  REAL(RealKind) :: wCoarse,wFine,wFace
  REAL(RealKind) :: VL,VR

  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            FR= &
               SUM(FU(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            uFine= &
               SUM(uCL(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FL= &
               SUM(FU(ix0-1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            uCoarse=uCR(ix0,jy,jz,1)
            VL=VolCoarse
            VR=VolFine
            uFace=(uCoarse*VL+uFine*VR)/ &
                  (VL+VR+Eps)
            uF(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)= &
               uFace*FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)/ &
                     (FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jz=jz0+1,jz1
            VR=VolC(ix0+1,jy,jz)
            VL=VolC(ix0,jy,jz)
            uF(ix0,jy,jz)=(VR*uCL(ix0+1,jy,jz,1) &
                         +VL*uCR(ix0,jy,jz,1)) &
                         /(VL+VR+Eps)*FU(ix0,jy,jz)/(FU(ix0,jy,jz)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            FL= &
               SUM(FU(ix1-1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            uFine= &
               SUM(uCR(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FR= &
               SUM(FU(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            VL=VolFine
            VR=VolCoarse
            uCoarse=uCL(ix1+1,jy,jz,1)
            uFace=(uCoarse*VR+uFine*VL)/ &
                  (VL+VR+Eps)
            uF(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)= &
               uFace*FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)/ &
                     (FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jz=jz0+1,jz1
            VR=VolC(ix1+1,jy,jz)
            VL=VolC(ix1,jy,jz)
            uF(ix1,jy,jz)=(VR*uCL(ix1+1,jy,jz,1) &
                         +VL*uCR(ix1,jy,jz,1)) &
                         /(VL+VR+Eps)*FU(ix1,jy,jz)/(FU(ix1,jy,jz)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            FR= &
               SUM(FV(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            vFine= &
               SUM(vCL(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            FL= &
               SUM(FV(jx:jx+IncrX-1,iy0-1,jz:jz+IncrZ-1))+Eps
            vCoarse=vCR(jx,iy0,jz,1)
            VL=VolCoarse
            VR=VolFine
            vFace=(vCoarse*VL+vFine*VR)/ &
                  (VL+VR+Eps)
            vF(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)= &
                vFace*FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)/ &
                      (FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jx=jx0+1,jx1
          DO jz=jz0+1,jz1
            VR=VolC(jx,iy0+1,jz)
            VL=VolC(jx,iy0,jz)
            vF(jx,iy0,jz)=(VR*vCL(jx,iy0+1,jz,1) &
                          +VL*vCR(jx,iy0,jz,1)) &
                         /(VL+VR+Eps)*FV(jx,iy0,jz)/(FV(jx,iy0,jz)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            FL= &
               SUM(FV(jx:jx+IncrX-1,iy1-1,jz:jz+IncrZ-1))
            vFine= &
               SUM(vCR(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))+Eps
            FR= &
               SUM(FV(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            VL=VolFine
            VR=VolCoarse
            vCoarse=vCL(jx,iy1+1,jz,1)
            vFace=(vCoarse*VR+vFine*VL)/ &
                  (VL+VR+Eps)
            vF(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)= &
               vFace*FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)/ &
                     (FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jx=jx0+1,jx1
          DO jz=jz0+1,jz1
            VR=VolC(jx,iy1+1,jz)
            VL=VolC(jx,iy1,jz)
            vF(jx,iy1,jz)=(VR*vCL(jx,iy1+1,jz,1) &
                          +VL*vCR(jx,iy1,jz,1)) &
                         /(VL+VR+Eps)*FV(jx,iy1,jz)/(FV(jx,iy1,jz)+Eps)
          END DO
        END DO
      END IF
    END IF


    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            FR= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            wFine= &
               SUM(wCL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            FC= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            FL= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0-1))
            wCoarse=wCR(jx,jy,iz0,1)
            VL=VolCoarse
            VR=VolFine
            wFace=(wCoarse*VL+wFine*VR)/ &
                  (VL+VR+Eps)
            wF(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)= &
                wFace*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)/ &
                      (FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            VR=VolC(jx,jy,iz0+1)
            VL=VolC(jx,jy,iz0)
            wF(jx,jy,iz0)=(VR*wCL(jx,jy,iz0+1,1) &
                          +VL*wCR(jx,jy,iz0,1)) &
                         /(VL+VR+Eps)*FW(jx,jy,iz0)/(FW(jx,jy,iz0)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            FL= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1-1))
            wFine= &
               SUM(wCR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            FC= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))+Eps
            FR= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            VL=VolFine
            VR=VolCoarse
            wCoarse=wCL(jx,jy,iz1+1,1)
            wFace=(wCoarse*VR+wFine*VL)/ &
                  (VL+VR+Eps)
            wF(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)= &
                wFace*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)/ &
                      (FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            VR=VolC(jx,jy,iz1+1)
            VL=VolC(jx,jy,iz1)
            wF(jx,jy,iz1)=(VR*wCL(jx,jy,iz1+1,1) &
                          +VL*wCR(jx,jy,iz1,1)) &
                         /(VL+VR+Eps)*FW(jx,jy,iz1)/(FW(jx,jy,iz1)+Eps)
          END DO
        END DO
      END IF
    END IF
  END DO

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        VR=VolC(ix+1,iy,iz)
        VL=VolC(ix,iy,iz)
        uF(ix,iy,iz)=(VR*uCL(ix+1,iy,iz,1) &
                     +VL*uCR(ix,iy,iz,1)) &
                     /(VL+VR+Eps)*FU(ix,iy,iz)/(FU(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        VR=VolC(ix,iy+1,iz)
        VL=VolC(ix,iy,iz)
        vF(ix,iy,iz)=(VR*vCL(ix,iy+1,iz,1) &
                     +VL*vCR(ix,iy,iz,1)) &
                     /(VL+VR+Eps)*FV(ix,iy,iz)/(FV(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VR=VolC(ix,iy,iz+1)
        VL=VolC(ix,iy,iz)
        wF(ix,iy,iz)=(VR*wCL(ix,iy,iz+1,1) &
                     +VL*wCR(ix,iy,iz,1)) &
                     /(VL+VR+Eps)*FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  IF (TypeW(1:1)=='o') THEN
    !IF (BCVel%West/='OutFlow') THEN
    IF (BCVec(uPosL)%West=='ZeroGrad'.OR.BCVec(uPosL)%West=='MeanValue') THEN ! Hinneburg
      ix=ix0
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=Zero
        END DO
      END DO
    ELSE
      ix=ix0
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=uF(ix+1,iy,iz)
        END DO
      END DO
    END IF
  END IF
  IF (TypeE(1:1)=='o') THEN
    IF (BCVec(uPosL)%East=='ZeroGrad'.OR.BCVec(uPosL)%East=='MeanValue') THEN 
      ix=ix1
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=Zero
        END DO
      END DO
    ELSE
      ix=ix1
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=uF(ix-1,iy,iz)
        END DO
      END DO
    END IF
  END IF
  IF (TypeS(1:1)=='o') THEN
    iy=iy0
    IF (BCVec(vPosL)%South=='ZeroGrad'.OR.BCVec(vPosL)%South=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=Zero
        END DO
      END DO
    ELSE
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=vF(ix,iy+1,iz)
        END DO
      END DO
    END IF
  END IF
  IF (TypeN(1:1)=='o') THEN
    iy=iy1
    IF (BCVec(vPosL)%North=='ZeroGrad'.OR.BCVec(vPosL)%North=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=Zero
        END DO
      END DO
    ELSE
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=vF(ix,iy-1,iz)
        END DO
      END DO
    END IF
  END IF
  IF (TypeB(1:1)=='o') THEN
    iz=iz0
    IF (BCVec(wPosL)%Bottom=='ZeroGrad'.OR.BCVec(wPosL)%Bottom=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=Zero
        END DO
      END DO
    ELSE
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=wF(ix,iy,iz+1)
        END DO
      END DO
    END IF
  END IF
  IF (TypeT(1:1)=='o') THEN
    IF (BCVec(wPosL)%Top=='ZeroGrad'.OR.BCVec(wPosL)%Top=='MeanValue') THEN 
      iz=iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=Zero
        END DO
      END DO
    ELSE 
      iz=iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=wF(ix,iy,iz-1)
        END DO
      END DO
    END IF
  END IF

END SUBROUTINE VelCellToFaceComputeLR2

SUBROUTINE VelCellToFaceComputeLR(Time)

  REAL(RealKind) :: Time

  INTEGER :: ix,iy,iz
  INTEGER :: jx,jy,jz
  INTEGER :: in
  REAL(RealKind) :: VolCoarse,VolFine
  REAL(RealKind) :: FL,FC,FR
  REAL(RealKind) :: uCoarse,uFine,uFace
  REAL(RealKind) :: vCoarse,vFine,vFace
  REAL(RealKind) :: wCoarse,wFine,wFace
  REAL(RealKind) :: VL,VR
  REAL(RealKind) :: xPL,yPL,zPL

  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            FR= &
               SUM(FU(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            uFine= &
               SUM(uCL(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FL= &
               SUM(FU(ix0-1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            uCoarse=uCR(ix0,jy,jz,1)
            VL=VolCoarse*FC/(FC+FL+Eps)
            VR=VolFine*FC/(FC+FR+Eps)
            uFace=(uCoarse*VL+uFine*VR)/ &
                  (VL+VR+Eps)
            uF(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)= &
               uFace*FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)/ &
                     (FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jz=jz0+1,jz1
            VR=VolC(ix0+1,jy,jz)*FU(ix0,jy,jz)/(FU(ix0,jy,jz)+FU(ix0+1,jy,jz)+Eps)
            VL=VolC(ix0,jy,jz)*FU(ix0,jy,jz)/(FU(ix0,jy,jz)+FU(ix0-1,jy,jz)+Eps)
            uF(ix0,jy,jz)=(VR*uCL(ix0+1,jy,jz,1) &
                         +VL*uCR(ix0,jy,jz,1)) &
                         /(VL+VR+Eps)*FU(ix0,jy,jz)/(FU(ix0,jy,jz)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            FL= &
               SUM(FU(ix1-1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            uFine= &
               SUM(uCR(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            FR= &
               SUM(FU(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            VL=VolFine*FC/(FC+FL+Eps)
            VR=VolCoarse*FC/(FC+FR+Eps)
            uCoarse=uCL(ix1+1,jy,jz,1)
            uFace=(uCoarse*VR+uFine*VL)/ &
                  (VL+VR+Eps)
            uF(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)= &
               uFace*FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)/ &
                     (FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jz=jz0+1,jz1
            VR=VolC(ix1+1,jy,jz)*FU(ix1,jy,jz)/(FU(ix1,jy,jz)+FU(ix1+1,jy,jz)+Eps)
            VL=VolC(ix1,jy,jz)*FU(ix1,jy,jz)/(FU(ix1,jy,jz)+FU(ix1-1,jy,jz)+Eps)
            uF(ix1,jy,jz)=(VR*uCL(ix1+1,jy,jz,1) &
                         +VL*uCR(ix1,jy,jz,1)) &
                         /(VL+VR+Eps)*FU(ix1,jy,jz)/(FU(ix1,jy,jz)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            FR= &
               SUM(FV(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            vFine= &
               SUM(vCL(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            FL= &
               SUM(FV(jx:jx+IncrX-1,iy0-1,jz:jz+IncrZ-1))+Eps
            vCoarse=vCR(jx,iy0,jz,1)
            VL=VolCoarse*FC/(FC+FL+Eps)
            VR=VolFine*FC/(FC+FR+Eps)
            vFace=(vCoarse*VL+vFine*VR)/ &
                  (VL+VR+Eps)
            vF(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)= &
                vFace*FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)/ &
                      (FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jx=jx0+1,jx1
          DO jz=jz0+1,jz1
            VR=VolC(jx,iy0+1,jz)*FV(jx,iy0,jz)/(FV(jx,iy0,jz)+FV(jx,iy0+1,jz)+Eps)
            VL=VolC(jx,iy0,jz)*FV(jx,iy0,jz)/(FV(jx,iy0,jz)+FV(jx,iy0-1,jz)+Eps)
            vF(jx,iy0,jz)=(VR*vCL(jx,iy0+1,jz,1) &
                          +VL*vCR(jx,iy0,jz,1)) &
                         /(VL+VR+Eps)*FV(jx,iy0,jz)/(FV(jx,iy0,jz)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jx=jx0+1,jx1,IncrX
          DO jz=jz0+1,jz1,IncrZ
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            FL= &
               SUM(FV(jx:jx+IncrX-1,iy1-1,jz:jz+IncrZ-1))
            vFine= &
               SUM(vCR(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            FC= &
               SUM(FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))+Eps
            FR= &
               SUM(FV(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            VL=VolFine*FC/(FC+FL+Eps)
            VR=VolCoarse*FC/(FC+FR+Eps)
            vCoarse=vCL(jx,iy1+1,jz,1)
            vFace=(vCoarse*VR+vFine*VL)/ &
                  (VL+VR+Eps)
            vF(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)= &
               vFace*FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)/ &
                     (FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)+Eps)
          END DO
        END DO
      ELSE
        DO jx=jx0+1,jx1
          DO jz=jz0+1,jz1
            VR=VolC(jx,iy1+1,jz)*FV(jx,iy1,jz)/(FV(jx,iy1,jz)+FV(jx,iy1+1,jz)+Eps)
            VL=VolC(jx,iy1,jz)*FV(jx,iy1,jz)/(FV(jx,iy1,jz)+FV(jx,iy1-1,jz)+Eps)
            vF(jx,iy1,jz)=(VR*vCL(jx,iy1+1,jz,1) &
                          +VL*vCR(jx,iy1,jz,1)) &
                         /(VL+VR+Eps)*FV(jx,iy1,jz)/(FV(jx,iy1,jz)+Eps)
          END DO
        END DO
      END IF
    END IF


    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
!     -------------------
!              |
!        N     |    D
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |     |  |  |
!       |     |------
!       |     |  |  |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            FR= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            wFine= &
               SUM(wCL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            FC= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            FL= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0-1))
            wCoarse=wCR(jx,jy,iz0,1)
            VL=VolCoarse*FC/(FC+FL+Eps)
            VR=VolFine*FC/(FC+FR+Eps)
            wFace=(wCoarse*VL+wFine*VR)/ &
                  (VL+VR+Eps)
            wF(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)= &
                wFace*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)/ &
                      (FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            VR=VolC(jx,jy,iz0+1)*FW(jx,jy,iz0)/(FW(jx,jy,iz0)+FW(jx,jy,iz0+1)+Eps)
            VL=VolC(jx,jy,iz0)*FW(jx,jy,iz0)/(FW(jx,jy,iz0)+FW(jx,jy,iz0-1)+Eps)
            wF(jx,jy,iz0)=(VR*wCL(jx,jy,iz0+1,1) &
                          +VL*wCR(jx,jy,iz0,1)) &
                         /(VL+VR+Eps)*FW(jx,jy,iz0)/(FW(jx,jy,iz0)+Eps)
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
!     -------------------
!              |
!        D     |    N
!              |
!     -------------------
      IF (Refine>RefineNachbar) THEN
!       -------------
!       |  |  |     |
!       |------     |
!       |  |  |     |
!       -------------
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            FL= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1-1))
            wFine= &
               SUM(wCR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            FC= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))+Eps
            FR= &
               SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            VL=VolFine*FC/(FC+FL+Eps)
            VR=VolCoarse*FC/(FC+FR+Eps)
            wCoarse=wCL(jx,jy,iz1+1,1)
            wFace=(wCoarse*VR+wFine*VL)/ &
                  (VL+VR+Eps)
            wF(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)= &
                wFace*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)/ &
                      (FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)+Eps)
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            VR=VolC(jx,jy,iz1+1)*FW(jx,jy,iz1)/(FW(jx,jy,iz1)+FW(jx,jy,iz1+1)+Eps)
            VL=VolC(jx,jy,iz1)*FW(jx,jy,iz1)/(FW(jx,jy,iz1)+FW(jx,jy,iz1-1)+Eps)
            wF(jx,jy,iz1)=(VR*wCL(jx,jy,iz1+1,1) &
                          +VL*wCR(jx,jy,iz1,1)) &
                         /(VL+VR+Eps)*FW(jx,jy,iz1)/(FW(jx,jy,iz1)+Eps)
          END DO
        END DO
      END IF
    END IF
  END DO

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        VR=VolC(ix+1,iy,iz)*FU(ix,iy,iz)/(FU(ix,iy,iz)+FU(ix+1,iy,iz)+Eps)
        VL=VolC(ix,iy,iz)*FU(ix,iy,iz)/(FU(ix,iy,iz)+FU(ix-1,iy,iz)+Eps)
        uF(ix,iy,iz)=(VR*uCL(ix+1,iy,iz,1) &
                     +VL*uCR(ix,iy,iz,1)) &
                     /(VL+VR+Eps)*FU(ix,iy,iz)/(FU(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        VR=VolC(ix,iy+1,iz)*FV(ix,iy,iz)/(FV(ix,iy,iz)+FV(ix,iy+1,iz)+Eps)
        VL=VolC(ix,iy,iz)*FV(ix,iy,iz)/(FV(ix,iy,iz)+FV(ix,iy-1,iz)+Eps)
        vF(ix,iy,iz)=(VR*vCL(ix,iy+1,iz,1) &
                     +VL*vCR(ix,iy,iz,1)) &
                     /(VL+VR+Eps)*FV(ix,iy,iz)/(FV(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VR=VolC(ix,iy,iz+1)*FW(ix,iy,iz)/(FW(ix,iy,iz)+FW(ix,iy,iz+1)+Eps)
        VL=VolC(ix,iy,iz)*FW(ix,iy,iz)/(FW(ix,iy,iz)+FW(ix,iy,iz-1)+Eps)
        wF(ix,iy,iz)=(VR*wCL(ix,iy,iz+1,1) &
                     +VL*wCR(ix,iy,iz,1)) &
                     /(VL+VR+Eps)*FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  IF (TypeW(1:1)=='o') THEN
    ix=ix0
    IF (BCVec(uPosL)%West=='Function') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix0)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uF(ix,iy,iz)=RhoFun(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix+1,iy)),Time) &
                      *UStart(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix+1,iy)),Time) &
                      *FU(ix,iy,iz)/(FU(ix,iy,iz)+eps)-uFOld(ix,iy,iz)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%West=='ZeroGrad' &
         .OR.BCVec(uPosL)%West=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=uCL(ix+1,iy,iz,1) 
        END DO
      END DO
    ELSE
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=Zero
        END DO
      END DO
    END IF
  END IF
  IF (TypeE(1:1)=='o') THEN
    ix=ix1
    IF (BCVec(uPosR)%East=='Function') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uF(ix,iy,iz)=RhoFun(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix+1,iy)),Time) &
                      *UStart(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix+1,iy)),Time) &
                      *FU(ix,iy,iz)/(FU(ix,iy,iz)+eps)-uFOld(ix,iy,iz)
        END DO
      END DO
    ELSE IF (BCVec(uPosR)%East=='ZeroGrad' &
         .OR.BCVec(uPosR)%East=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=uCR(ix,iy,iz,1) 
        END DO
      END DO
    ELSE  
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix,iy,iz)=Zero
        END DO
      END DO
    END IF
  END IF
  IF (TypeS(1:1)=='o') THEN
    iy=iy0
    IF (BCVec(vPosL)%South=='Function') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy0)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vF(ix,iy,iz)=RhoFun(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix,iy+1)),Time) &
                      *VStart(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix,iy+1)),Time) &
                      *FV(ix,iy,iz)/(FV(ix,iy,iz)+eps)-vFOld(ix,iy,iz)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%South=='ZeroGrad' &
         .OR.BCVec(vPosL)%South=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=vCL(ix,iy+1,iz,1) 
        END DO
      END DO
    ELSE  
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=Zero
        END DO
      END DO
    END IF
  END IF
  IF (TypeN(1:1)=='o') THEN
    iy=iy1
    IF (BCVec(vPosR)%North=='Function') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy0)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vF(ix,iy,iz)=RhoFun(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix,iy+1)),Time) &
                      *VStart(xPL,yPL,zPl,Half*(zH(ix,iy)+zh(ix,iy+1)),Time) &
                      *FV(ix,iy,iz)/(FV(ix,iy,iz)+eps)-vFOld(ix,iy,iz)
        END DO
      END DO
    ELSE IF (BCVec(vPosR)%North=='ZeroGrad' &
         .OR.BCVec(vPosR)%North=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=vCR(ix,iy,iz,1) 
        END DO
      END DO
    ELSE  
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy,iz)=Zero
        END DO
      END DO
    END IF
  END IF
  IF (TypeB(1:1)=='o') THEN
    iz=iz0
    IF (BCVec(wPosL)%Bottom=='Function') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz0)
          wF(ix,iy,iz)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time) &
                      *WStart(xPL,yPL,zPl,zH(ix,iy),Time) &
                      *FW(ix,iy,iz)/(FW(ix,iy,iz)+eps)-wFOld(ix,iy,iz)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Bottom=='ZeroGrad' &
         .OR.BCVec(wPosL)%Bottom=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=wCL(ix,iy,iz+1,1) 
        END DO
      END DO
    ELSE  
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=Zero
        END DO
      END DO
    END IF
  END IF
  IF (TypeT(1:1)=='o') THEN
    iz=iz1
    IF (BCVec(wPosR)%Top=='Function') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz0)
          wF(ix,iy,iz)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time) &
                      *WStart(xPL,yPL,zPl,zH(ix,iy),Time) &
                      *FW(ix,iy,iz)/(FW(ix,iy,iz)+eps)-wFOld(ix,iy,iz)
        END DO
      END DO
    ELSE IF (BCVec(wPosR)%Top=='ZeroGrad' &
         .OR.BCVec(wPosR)%Top=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=wCR(ix,iy,iz,1) 
        END DO
      END DO
    ELSE  
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz)=Zero
        END DO
      END DO
    END IF
  END IF

END SUBROUTINE VelCellToFaceComputeLR

SUBROUTINE BoundaryVelocityCellCompute(Time) 

  REAL(RealKind) :: Time 

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: xPL,yPL,zPl

  IF (TypeW=='ow') THEN
    IF (BCVec(uPosL)%West=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uC(ix0,iy,iz,1)=-uC(ix0+1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%West=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uC(ix0,iy,iz,1)=uC(ix0+1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%West=='MeanValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uC(ix0,iy,iz,1)=0.5d0*(MeanProfile(uPosL,iz)+MeanProfile(uPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%West=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix0)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uC(ix0,iy,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix0,iy),Time)*UStart(xPL,yPL,zPl,zH(ix0,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(vPosL)%West=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          vC(ix0,iy,iz,1)=-vC(ix0+1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%West=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          vC(ix0,iy,iz,1)=vC(ix0+1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%West=='MeanValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          vC(ix0,iy,iz,1)=0.5d0*(MeanProfile(vPosL,iz)+MeanProfile(vPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%West=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix0)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vC(ix0,iy,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix0,iy),Time)*VStart(xPL,yPL,zPl,zH(ix0,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(wPosL)%West=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          wC(ix0,iy,iz,1)=-wC(ix0+1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%West=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          wC(ix0,iy,iz,1)=wC(ix0+1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%West=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          wC(ix0,iy,iz,1)=0.5d0*(MeanProfile(wPosL,iz)+MeanProfile(wPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%West=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix0)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          wC(ix0,iy,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix0,iy),Time)*WStart(xPL,yPL,zPl,zH(ix0,iy),Time)
        END DO
      END DO
    END IF
  END IF

  IF (TypeE=='oe') THEN
    IF (BCVec(uPosL)%East=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uC(ix1+1,iy,iz,1)=-uC(ix1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%East=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uC(ix1+1,iy,iz,1)=uC(ix1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%East=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uC(ix1+1,iy,iz,1)=0.5d0*(MeanProfile(uPosL,iz)+MeanProfile(uPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%East=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix1)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uC(ix1+1,iy,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix1+1,iy),Time)*UStart(xPL,yPL,zPl,zH(ix1+1,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(vPosL)%East=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          vC(ix1+1,iy,iz,1)=-vC(ix1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%East=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          vC(ix1+1,iy,iz,1)=vC(ix1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%East=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          vC(ix1+1,iy,iz,1)=0.5d0*(MeanProfile(vPosL,iz)+MeanProfile(vPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%East=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix1)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vC(ix1+1,iy,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix1+1,iy),Time)*VStart(xPL,yPL,zPl,zH(ix1+1,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(wPosL)%East=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          wC(ix1+1,iy,iz,1)=-wC(ix1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%East=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          wC(ix1+1,iy,iz,1)=wC(ix1,iy,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%East=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          wC(ix1+1,iy,iz,1)=0.5d0*(MeanProfile(wPosL,iz)+MeanProfile(wPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%East=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix1)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          wC(ix1+1,iy,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix1+1,iy),Time)*WStart(xPL,yPL,zPl,zH(ix1+1,iy),Time)
        END DO
      END DO
    END IF

  END IF

  IF (TypeS=='os') THEN
    IF (BCVec(uPosL)%South=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          uC(ix,iy0,iz,1)=-uC(ix,iy0+1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%South=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          uC(ix,iy0,iz,1)=uC(ix,iy0+1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%South=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          uC(ix,iy0,iz,1)=0.5d0*(MeanProfile(uPosL,iz)+MeanProfile(uPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%South=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy0)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uC(ix,iy0,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy0),Time)*UStart(xPL,yPL,zPl,zH(ix,iy0),Time)
        END DO
      END DO
    END IF

    IF (BCVec(vPosL)%South=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vC(ix,iy0,iz,1)=-vC(ix,iy0+1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%South=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vC(ix,iy0,iz,1)=vC(ix,iy0+1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%South=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vC(ix,iy0,iz,1)=0.5d0*(MeanProfile(vPosL,iz)+MeanProfile(vPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%South=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy0)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vC(ix,iy0,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy0),Time)*VStart(xPL,yPL,zPl,zH(ix,iy0),Time)
        END DO
      END DO
    END IF

    IF      (BCVec(wPosL)%South=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          wC(ix,iy0,iz,1)=-wC(ix,iy0+1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%South=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          wC(ix,iy0,iz,1)=wC(ix,iy0+1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%South=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          wC(ix,iy0,iz,1)=0.5d0*(MeanProfile(wPosL,iz)+MeanProfile(wPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%South=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy0)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          wC(ix,iy0,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy0),Time)*WStart(xPL,yPL,zPl,zH(ix,iy0),Time)
        END DO
      END DO
    END IF

  END IF

  IF (TypeN=='on') THEN
    IF (BCVec(uPosL)%North=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          uC(ix,iy1+1,iz,1)=-uC(ix,iy1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%North=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          uC(ix,iy1+1,iz,1)=uC(ix,iy1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%North=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          uC(ix,iy1+1,iz,1)=0.5d0*(MeanProfile(uPosL,iz)+MeanProfile(uPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%North=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy1)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uC(ix,iy1+1,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy1+1),Time)*UStart(xPL,yPL,zPl,zH(ix,iy1+1),Time)
        END DO
      END DO
    END IF

    IF (BCVec(vPosL)%North=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vC(ix,iy1+1,iz,1)=-vC(ix,iy1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%North=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vC(ix,iy1+1,iz,1)=vC(ix,iy1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%North=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vC(ix,iy1+1,iz,1)=0.5d0*(MeanProfile(vPosL,iz)+MeanProfile(vPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%North=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy1)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vC(ix,iy1+1,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy1+1),Time)*VStart(xPL,yPL,zPl,zH(ix,iy1+1),Time)
        END DO
      END DO
    END IF

    IF (BCVec(wPosL)%North=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          wC(ix,iy1+1,iz,1)=-wC(ix,iy1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%North=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          wC(ix,iy1+1,iz,1)=wC(ix,iy1,iz,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%North=='MeanValue') THEN 
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          wC(ix,iy1+1,iz,1)=0.5d0*(MeanProfile(wPosL,iz)+MeanProfile(wPosR,iz))
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%North=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy1)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          wC(ix,iy1+1,iz,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy1+1),Time)*WStart(xPL,yPL,zPl,zH(ix,iy1+1),Time)
        END DO
      END DO
    END IF
  END IF

  IF (TypeB=='ob') THEN

    IF (BCVec(uPosL)%Bottom=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          uC(ix,iy,iz0,1)=-uC(ix,iy,iz0+1,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%Bottom=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          uC(ix,iy,iz0,1)=uC(ix,iy,iz0+1,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%Bottom=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          uC(ix,iy,iz0,1)=0.5d0*(MeanProfile(uPosL,iz0+1)+MeanProfile(uPosR,iz0+1))
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%Bottom=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz0)
          uC(ix,iy,iz0,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*UStart(xPL,yPL,zPl,zH(ix,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(vPosL)%Bottom=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          vC(ix,iy,iz0,1)=-vC(ix,iy,iz0+1,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%Bottom=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          vC(ix,iy,iz0,1)=vC(ix,iy,iz0+1,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%Bottom=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          vC(ix,iy,iz0,1)=0.5d0*(MeanProfile(vPosL,iz0+1)+MeanProfile(vPosR,iz0+1))
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%Bottom=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz0)
          vC(ix,iy,iz0,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*VStart(xPL,yPL,zPl,zH(ix,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(wPosL)%Bottom=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wC(ix,iy,iz0,1)=-wC(ix,iy,iz0+1,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Bottom=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wC(ix,iy,iz0,1)=wC(ix,iy,iz0+1,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Bottom=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wC(ix,iy,iz0,1)=0.5d0*(MeanProfile(wPosL,iz0+1)+MeanProfile(wPosR,iz0+1))
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Bottom=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz0)
          wC(ix,iy,iz0,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*WStart(xPL,yPL,zPl,zH(ix,iy),Time)
        END DO
      END DO
    END IF

  END IF

  IF (TypeT=='ot') THEN
    IF (BCVec(uPosL)%Top=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          uC(ix,iy,iz1+1,1)=-uC(ix,iy,iz1,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%Top=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          uC(ix,iy,iz1+1,1)=uC(ix,iy,iz1,1)
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%Top=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          uC(ix,iy,iz1+1,1)=0.5d0*(MeanProfile(uPosL,iz1)+MeanProfile(uPosR,iz1))
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%Top=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz1)
          uC(ix,iy,iz1+1,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*UStart(xPL,yPL,zPl,zH(ix,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(vPosL)%Top=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          vC(ix,iy,iz1+1,1)=-vC(ix,iy,iz1,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%Top=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          vC(ix,iy,iz1+1,1)=vC(ix,iy,iz1,1)
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%Top=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          vC(ix,iy,iz1+1,1)=0.5d0*(MeanProfile(vPosL,iz1)+MeanProfile(vPosR,iz1))
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%Top=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz1)
          vC(ix,iy,iz1+1,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*VStart(xPL,yPL,zPl,zH(ix,iy),Time)
        END DO
      END DO
    END IF

    IF (BCVec(wPosL)%Top=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wC(ix,iy,iz1+1,1)=-wC(ix,iy,iz1,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Top=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wC(ix,iy,iz1+1,1)=wC(ix,iy,iz1,1)
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Top=='MeanValue') THEN 
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wC(ix,iy,iz1+1,1)=0.5d0*(MeanProfile(wPosL,iz1)+MeanProfile(wPosR,iz1))
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Top=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz1)
          wC(ix,iy,iz1+1,1)=RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*WStart(xPL,yPL,zPl,zH(ix,iy),Time)
        END DO
      END DO
    END IF

  END IF

END SUBROUTINE BoundaryVelocityCellCompute

SUBROUTINE BoundaryComputeZeroGrad

  INTEGER :: ix,iy,iz

  IF (TypeW=='ow') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          c(ix0,iy,iz,:)=c(ix0+1,iy,iz,:)
        END DO
      END DO
  END IF

  IF (TypeE=='oe') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          c(ix1+1,iy,iz,:)=c(ix1,iy,iz,:)
        END DO
      END DO
  END IF

  IF (TypeS=='os') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          c(ix,iy0,iz,:)=c(ix,iy0+1,iz,:)
        END DO
      END DO
  END IF

  IF (TypeN=='on') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          c(ix,iy1+1,iz,:)=c(ix,iy1,iz,:)
        END DO
      END DO
  END IF

  IF (TypeB=='ob') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          c(ix,iy,iz0,:)=Zero
        END DO
      END DO
  END IF
  IF (TypeT=='ot') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          c(ix,iy,iz1+1,:)=c(ix,iy,iz1,:)
        END DO
      END DO
  END IF

END SUBROUTINE BoundaryComputeZeroGrad


SUBROUTINE BoundaryCompute(Val,Time,ic) 

  REAL(RealKind), EXTERNAL :: Val
  REAL(RealKind) :: Time

  INTEGER :: ix,iy,iz,ic
  REAL(RealKind) :: xPL,yPL,zPl

  IF (TypeW=='ow') THEN
    ix=ix0
    IF (BC%West=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          c(ix0,iy,iz,:)=c(ix0+1,iy,iz,:)
        END DO
      END DO
    ELSE IF (BC%West=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          c(ix0,iy,iz,:)=-c(ix0+1,iy,iz,:)
        END DO
      END DO
    ELSE IF (BC%West=='MeanValue') THEN 
       DO iz=iz0+1,iz1
         DO iy=iy0+1,iy1
           c(ix0,iy,iz,:) = 2.d0*MeanProfile(ic,iz)-c(ix0+1,iy,iz,:)
         END DO
       END DO
    ELSE IF (BC%West=='Function') THEN
       DO iz=iz0+1,iz1
         DO iy=iy0+1,iy1
           xPL=xP(ix0)-0.5d0*dx(ix0+1)
           yPL=yP(iy-1)+0.5e0*dy(iy)
           zPL=zP(iz-1)+0.5e0*dz(iz)
           c(ix0,iy,iz,:)=2.d0*Rho(ix0+1,iy,iz,:)*Val(xPL,yPL,zPL,zH(ix0,iy),Time)-c(ix0+1,iy,iz,:)
           IF (ic==nvPos.OR.ic==ncPos.OR.ic==nrPos.OR.ic==nsPos.OR.ic==niPos) THEN 
             c(ix0,iy,iz,:)=2.d0*Val(xPL,yPL,zPL,zH(ix0,iy),Time)-c(ix0+1,iy,iz,:)
           ELSE
             c(ix0,iy,iz,:)=2.d0*RhoFun(xPL,yPL,zPL,zH(ix0,iy),Time)*Val(xPL,yPL,zPL,zH(ix0,iy),Time)-c(ix0+1,iy,iz,:)
           END IF
         END DO
       END DO
    END IF
  END IF

  IF (TypeE=='oe') THEN
    ix=ix1
    IF (BC%East=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          c(ix1+1,iy,iz,:)=c(ix1,iy,iz,:)
        END DO
      END DO
    ELSE IF (BC%East=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          c(ix1+1,iy,iz,:)=-c(ix1,iy,iz,:)
        END DO
      END DO
    ELSE IF (BC%East=='MeanValue') THEN 
       DO iz=iz0+1,iz1
         DO iy=iy0+1,iy1
           c(ix1+1,iy,iz,:) = 2.d0*MeanProfile(ic,iz)-c(ix1,iy,iz,:)
         END DO
       END DO
    ELSE IF (BC%East=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix1)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          IF (ic==nvPos.OR.ic==ncPos.OR.ic==nrPos.OR.ic==nsPos.OR.ic==niPos) THEN 
            c(ix1+1,iy,iz,:) = 2.d0*Val(xPL,yPL,zPL,zH(ix1+1,iy),Time)-c(ix1,iy,iz,:)
          ELSE
            c(ix1+1,iy,iz,:) = 2.d0*Rho(ix1,iy,iz,:)*Val(xPL,yPL,zPL,zH(ix1+1,iy),Time)-c(ix1,iy,iz,:)
          END IF
        END DO
      END DO
    END IF
  END IF

  IF (TypeS=='os') THEN
    iy=iy0
    IF (BC%South=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          c(ix,iy0,iz,:)=c(ix,iy0+1,iz,:)
        END DO
      END DO
    ELSE IF (BC%South=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          c(ix,iy0,iz,:)=-c(ix,iy0+1,iz,:)
        END DO
      END DO
    ELSE IF (BC%South=='MeanValue') THEN 
       DO iz=iz0+1,iz1
         DO ix=ix0+1,ix1
           c(ix,iy0,iz,:) = 2.d0*MeanProfile(ic,iz)-c(ix,iy0+1,iz,:)
         END DO
       END DO
    ELSE IF (BC%South=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy0)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          IF (ic==nvPos.OR.ic==ncPos.OR.ic==nrPos.OR.ic==nsPos.OR.ic==niPos) THEN 
            c(ix,iy0,iz,:) = 2.d0*Val(xPL,yPL,zPL,zH(ix,iy0),Time)-c(ix,iy0+1,iz,:)
          ELSE
            c(ix,iy0,iz,:) = 2.d0*Rho(ix,iy0+1,iz,:)*Val(xPL,yPL,zPL,zH(ix,iy0),Time)-c(ix,iy0+1,iz,:)
          END IF
        END DO
      END DO
    END IF
  END IF

  IF (TypeN=='on') THEN
    iy=iy1
    IF (BC%North=='ZeroGrad') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          c(ix,iy1+1,iz,:)=c(ix,iy1,iz,:)
        END DO
      END DO
    ELSE IF (BC%North=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          c(ix,iy1+1,iz,:)=-c(ix,iy1,iz,:)
        END DO
      END DO
    ELSE IF (BC%North=='MeanValue') THEN 
       DO iz=iz0+1,iz1
         DO ix=ix0+1,ix1
           c(ix,iy1+1,iz,:) = 2.d0*MeanProfile(ic,iz)-c(ix,iy1,iz,:)
         END DO
       END DO
    ELSE IF (BC%North=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy1)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          IF (ic==nvPos.OR.ic==ncPos.OR.ic==nrPos.OR.ic==nsPos.OR.ic==niPos) THEN 
            c(ix,iy1+1,iz,:) = 2.d0*Val(xPL,yPL,zPL,zH(ix,iy1+1),Time)-c(ix,iy1,iz,:)
          ELSE
            c(ix,iy1+1,iz,:) = 2.d0*Rho(ix,iy1,iz,:)*Val(xPL,yPL,zPL,zH(ix,iy1+1),Time)-c(ix,iy1,iz,:)
          END IF
        END DO
      END DO
    END IF
  END IF

  IF (TypeB=='ob') THEN
    iz=iz0
    IF (BC%Bottom=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          c(ix,iy,iz0,:)=c(ix,iy,iz0+1,:)
        END DO
      END DO
    ELSE IF (BC%Bottom=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          c(ix,iy,iz0,:)=-c(ix,iy,iz0+1,:)
        END DO
      END DO
    ELSE IF (BC%Bottom=='MeanValue') THEN 
       DO iy=iy0+1,iy1
         DO ix=ix0+1,ix1
           c(ix,iy,iz0,:) = 2.d0*MeanProfile(ic,iz0+1)-c(ix,iy,iz0+1,:)
         END DO
       END DO
    ELSE IF (BC%Bottom=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz0)
          IF (ic==nvPos.OR.ic==ncPos.OR.ic==nrPos.OR.ic==nsPos.OR.ic==niPos) THEN 
            c(ix,iy,iz0,:) = 2.d0*Val(xPL,yPL,zPL,zH(ix,iy),Time)-c(ix,iy,iz0+1,:)
          ELSE
            c(ix,iy,iz0,:) = 2.d0*Rho(ix,iy,iz0+1,:)*Val(xPL,yPL,zPL,zH(ix,iy),Time)-c(ix,iy,iz0+1,:)
          END IF
        END DO
      END DO
    END IF
  END IF

  IF (TypeT=='ot') THEN
    iz=iz1
    IF (BC%Top=='ZeroGrad') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          c(ix,iy,iz1+1,:)=c(ix,iy,iz1,:)
        END DO
      END DO
    ELSE IF (BC%Top=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          c(ix,iy,iz1+1,:)=-c(ix,iy,iz1,:)
        END DO
      END DO
    ELSE IF (BC%Top=='MeanValue') THEN 
       DO iy=iy0+1,iy1
         DO ix=ix0+1,ix1
           c(ix,iy,iz1+1,:) = 2.d0*MeanProfile(ic,iz1)-c(ix,iy,iz1,:)
         END DO
       END DO
    ELSE IF (BC%Top=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz1)
          IF (ic==nvPos.OR.ic==ncPos.OR.ic==nrPos.OR.ic==nsPos.OR.ic==niPos) THEN 
            c(ix,iy,iz1+1,:) = 2.d0*Val(xPL,yPL,zPL,zH(ix,iy),Time)-c(ix,iy,iz1,:)
          ELSE
            c(ix,iy,iz1+1,:) = 2.d0*Rho(ix,iy,iz1,:)*Val(xPL,yPL,zPL,zH(ix,iy),Time)-c(ix,iy,iz1,:)
          END IF
        END DO
      END DO
    END IF
  END IF

END SUBROUTINE BoundaryCompute

SUBROUTINE BoundaryVelocityFaceCompute(Time)

  REAL(RealKind) :: Time

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: xPL,yPL,zPl

  IF (TypeW=='ow') THEN
    ix=ix0
    IF (BCVec(uPosL)%West=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix0,iy,iz)=0.d0
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%West=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix0)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uF(ix0,iy,iz)=RhoFun(xPL,yPL,zPl,Half*(zH(ix0,iy)+zh(ix0+1,iy)),Time) &
                        *UStart(xPL,yPL,zPl,Half*(zH(ix0,iy)+zh(ix0+1,iy)),Time) &
                        *FU(ix0,iy,iz)/(FU(ix0,iy,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeE=='oe') THEN
    ix=ix1
    IF (BCVec(uPosL)%East=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          uF(ix1,iy,iz)=0.d0
        END DO
      END DO
    ELSE IF (BCVec(uPosL)%East=='Function') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          xPL=xP(ix1)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          uF(ix1,iy,iz)=RhoFun(xPL,yPL,zPl,Half*(zH(ix1,iy)+zh(ix1+1,iy)),Time) &
                       *UStart(xPL,yPL,zPl,Half*(zH(ix1,iy)+zh(ix1+1,iy)),Time) &
                       *FU(ix1,iy,iz)/(FU(ix1,iy,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeS=='os') THEN
    iy=iy0
    IF (BCVec(vPosL)%South=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy0,iz)=0.d0
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%South=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy0)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vF(ix,iy0,iz) = RhoFun(xPL,yPL,zPl,Half*(zH(ix,iy0)+zh(ix,iy0+1)),Time)*VStart(xPL,yPL,zPl,Half*(zH(ix,iy0)+zh(ix,iy0+1)),Time) &
                                *FV(ix,iy0,iz)/(FV(ix,iy0,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeN=='on') THEN
    iy=iy1
    IF (BCVec(vPosL)%North=='ZeroValue') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          vF(ix,iy1,iz)=0.d0
        END DO
      END DO
    ELSE IF (BCVec(vPosL)%North=='Function') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy1)
          zPL=zP(iz-1)+0.5e0*dz(iz)
          vF(ix,iy1,iz) = RhoFun(xPL,yPL,zPl,Half*(zH(ix,iy1)+zh(ix,iy1+1)),Time)*VStart(xPL,yPL,zPl,Half*(zH(ix,iy1)+zh(ix,iy1+1)),Time) &
                                *FV(ix,iy1,iz)/(FV(ix,iy1,iz)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeB=='ob') THEN
    iz=iz0
    IF (BCVec(wPosL)%Bottom=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz0)=0.d0
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Bottom=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz0)
          wF(ix,iy,iz0) = RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*WStart(xPL,yPL,zPl,zH(ix,iy),Time) &
                                *FW(ix,iy,iz0)/(FW(ix,iy,iz0)+eps)
        END DO
      END DO
    END IF
  END IF

  IF (TypeT=='ot') THEN
    iz=iz1
    IF (BCVec(wPosL)%Top=='ZeroValue') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wF(ix,iy,iz1)=0.d0
        END DO
      END DO
    ELSE IF (BCVec(wPosL)%Top=='Function') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          xPL=xP(ix-1)+0.5e0*dx(ix)
          yPL=yP(iy-1)+0.5e0*dy(iy)
          zPL=zP(iz1)
          wF(ix,iy,iz1) = RhoFun(xPL,yPL,zPl,zH(ix,iy),Time)*WStart(xPL,yPL,zPl,zH(ix,iy),Time) &
                                *FW(ix,iy,iz1)/(FW(ix,iy,iz1)+eps)
        END DO
      END DO
    END IF
  END IF

END SUBROUTINE BoundaryVelocityFaceCompute

SUBROUTINE AdvectionCompute(Phi,FallF)

  INTERFACE
    FUNCTION Phi1(r,k1,k2)
      USE Kind_Mod
      REAL(RealKind) :: Phi1,r,k1,k2
    END FUNCTION Phi1
    FUNCTION Phi(r,k1,k2,cL,cC,cR,hC)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2,cL,cC,cR,hC
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  IF (Primitive) THEN
    CALL AdvectionComputeP(Phi,FallF)
  ELSE 
    CALL AdvectionComputeC(Phi,FallF)
  END IF

END SUBROUTINE AdvectionCompute

SUBROUTINE AdvectionPreCompute(Phi,FallF)
  INTERFACE
    FUNCTION Phi(r,k1,k2,cL,cC,cR,hC)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2,cL,cC,cR,hC
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  IF (AdvPr=='V1') THEN
    CALL AdvectionPreComputeC(FallF)
  ELSE IF (AdvPr=='V2') THEN
    CALL AdvectionPreComputeV2(Phi,FallF)
  ELSE IF (AdvPr=='V3') THEN
    CALL AdvectionPreComputeV3(Phi,FallF)
  END IF  
END SUBROUTINE AdvectionPreCompute

SUBROUTINE AdvectionPreComputeV2(Phi,FallF)

  INTERFACE
    FUNCTION Phi(r,k1,k2,cR,cC,cL,hC)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2,cR,cC,cL,hC
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cL,cC,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux
  REAL(RealKind) :: cDiff,cLeft,cRight
  REAL(RealKind) :: uLe,uRi,vLe,vRi,wLe,wRi
  REAL(RealKind) :: uLoc,vLoc,wLoc
  REAL(RealKind) :: RhoL,RhoC,RhoR
  REAL(RealKind) :: RhoLF

  DO it=LBOUND(c,4),UBOUND(c,4)
! x-Direction
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0,ix1+1
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        uLoc=Half*(uCL(ix,iy,iz,1)+uCR(ix,iy,iz,1))/(Rho(ix,iy,iz,1)+Eps)
!       Left Value        
!       uLoc>0 take for interpolation cLL,cL,cC
!       uLoc<0 take for interpolation cL,cC,cR
!       Right Value        
!       uLoc>0 take for interpolation cL,cC,cR
!       uLoc<0 take for interpolation cC,cR,cRR
        cLeft=Zero
        cRight=Zero
        IF (uLoc>Zero.AND.ix>ix0) THEN
!         uLoc>0 take for interpolation cLL,cL,cC
!         Left boundary
          IF (ix>ix0+1) THEN
            VL=VolC(ix-2,iy,iz)
            cL=c(ix-2,iy,iz,it)
            VC=VolC(ix-1,iy,iz)
            cC=c(ix-1,iy,iz,it)
            VR=VolC(ix,iy,iz)
            cR=c(ix,iy,iz,it)
            FL=FU(ix-2,iy,iz)
            FR=FU(ix-1,iy,iz)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VL,VC,VR)
            k2=k2F(VL,VC,VR)
            cDiff=cC-cL
            r=(cR-cC+Eps)/(cDiff+Eps)
            cLeft=(cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
          END IF  
!         Right boundary
          IF (ix<ix1+1) THEN
            VL=VolC(ix-1,iy,iz)
            cL=c(ix-1,iy,iz,it)
            VC=VolC(ix,iy,iz)
            cC=c(ix,iy,iz,it)
            VR=VolC(ix+1,iy,iz)
            cR=c(ix+1,iy,iz,it)
            FL=FU(ix-1,iy,iz)
            FR=FU(ix,iy,iz)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VL,VC,VR)
            k2=k2F(VL,VC,VR)
            cDiff=cC-cL
            r=(cR-cC+Eps)/(cDiff+Eps)
            cRight=cC+FR/(FR+Eps)*phi(r,k1,k2,cR,cC,cL,hC)
          END IF  
        END IF  
        IF (uLoc<Zero.AND.ix<ix1+1) THEN
!         uLoc<0 take for interpolation cL,cC,cR
!         Left boundary          
          IF (ix>ix0) THEN
            VL=VolC(ix-1,iy,iz)
            cL=c(ix-1,iy,iz,it)
            VC=VolC(ix,iy,iz)
            cC=c(ix,iy,iz,it)
            VR=VolC(ix+1,iy,iz)
            cR=c(ix+1,iy,iz,it)
            FL=FU(ix-1,iy,iz)
            FR=FU(ix,iy,iz)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VR,VC,VL)
            k2=k2F(VR,VC,VL)
            cDiff=cR-cC
            r=(cC-cL+Eps)/(cDiff+Eps)
            cLeft=cC+FL/(FL+Eps)*phi(r,k1,k2,cL,cC,cR,hC)       
          END IF  
!         Right boundary
          IF (ix<ix1) THEN
            VL=VolC(ix,iy,iz)
            cL=c(ix,iy,iz,it)
            VC=VolC(ix+1,iy,iz)
            cC=c(ix+1,iy,iz,it)
            VR=VolC(ix+2,iy,iz)
            cR=c(ix+2,iy,iz,it)
            FL=FU(ix,iy,iz)
            FR=FU(ix+1,iy,iz)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VR,VC,VL)
            k2=k2F(VR,VC,VL)
            cDiff=cR-cC
            r=(cC-cL+Eps)/(cDiff+Eps)
            cRight=cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC)       
          END IF  
        END IF  
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-uLoc*(cRight-cLeft)*Half*(FL+FR)
      END DO  
    END DO  
  END DO  
! z-Direction
  DO iz=iz0,iz1+1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        wLoc=Half*(wCL(ix,iy,iz,1)+wCR(ix,iy,iz,1))/(Rho(ix,iy,iz,1)+Eps)
!       Left Value        
!       wLoc>0 take for interpolation cLL,cL,cC
!       wLoc<0 take for interpolation cL,cC,cR
!       Right Value        
!       wLoc>0 take for interpolation cL,cC,cR
!       wLoc<0 take for interpolation cC,cR,cRR
        cLeft=Zero
        cRight=Zero
        IF (wLoc>Zero.AND.iz>iz0) THEN
!         wLoc>0 take for interpolation cLL,cL,cC
!         Left boundary
          IF (iz>iz0+1) THEN
            VL=VolC(ix,iy,iz-2)
            cL=c(ix,iy,iz-2,it)
            VC=VolC(ix,iy,iz-1)
            cC=c(ix,iy,iz-1,it)
            VR=VolC(ix,iy,iz)
            cR=c(ix,iy,iz,it)
            FL=FW(ix,iy,iz-2)
            FR=FW(ix,iy,iz-1)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VL,VC,VR)
            k2=k2F(VL,VC,VR)
            cDiff=cC-cL
            r=(cR-cC+Eps)/(cDiff+Eps)
            cLeft=(cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
          END IF  
!         Right boundary
          IF (iz<iz1+1) THEN
            VL=VolC(ix,iy,iz-1)
            cL=c(ix,iy,iz-1,it)
            VC=VolC(ix,iy,iz)
            cC=c(ix,iy,iz,it)
            VR=VolC(ix,iy,iz+1)
            cR=c(ix,iy,iz+1,it)
            FL=FW(ix,iy,iz-1)
            FR=FW(ix,iy,iz)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VL,VC,VR)
            k2=k2F(VL,VC,VR)
            cDiff=cC-cL
            r=(cR-cC+Eps)/(cDiff+Eps)
            cRight=cC+FR/(FR+Eps)*phi(r,k1,k2,cR,cC,cL,hC)
          END IF  
        END IF  
        IF (wLoc<Zero.AND.iz<iz1+1) THEN
!         wLoc<0 take for interpolation cL,cC,cR
!         Left boundary          
          IF (iz>iz0) THEN
            VL=VolC(ix,iy,iz-1)
            cL=c(ix,iy,iz-1,it)
            VC=VolC(ix,iy,iz)
            cC=c(ix,iy,iz,it)
            VR=VolC(ix,iy,iz+1)
            cR=c(ix,iy,iz+1,it)
            FL=FW(ix,iy,iz-1)
            FR=FW(ix,iy,iz)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VR,VC,VL)
            k2=k2F(VR,VC,VL)
            cDiff=cR-cC
            r=(cC-cL+Eps)/(cDiff+Eps)
            cLeft=cC+FL/(FL+Eps)*phi(r,k1,k2,cL,cC,cR,hC)       
          END IF  
!         Right boundary
          IF (iz<iz1) THEN
            VL=VolC(ix,iy,iz)
            cL=c(ix,iy,iz,it)
            VC=VolC(ix,iy,iz+1)
            cC=c(ix,iy,iz+1,it)
            VR=VolC(ix,iy,iz+2)
            cR=c(ix,iy,iz+2,it)
            FL=FW(ix,iy,iz)
            FR=FW(ix,iy,iz+1)
            hL=hLF(VL,FL)
            hC=hCF(VC,FL,FR)
            hR=hRF(VR,FR)
            k1=k1F(VR,VC,VL)
            k2=k2F(VR,VC,VL)
            cDiff=cR-cC
            r=(cC-cL+Eps)/(cDiff+Eps)
            cRight=cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC)       
          END IF  
        END IF  
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-wLoc*(cRight-cLeft)*Half*(FL+FR)
      END DO  
    END DO  
  END DO  
  IF (TypeW=='ow') THEN
    ix=ix0+1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        uLoc=Half*(uCL(ix,iy,iz,1)+uCR(ix,iy,iz,1))/(Rho(ix,iy,iz,1)+Eps)
        cLeft=c(ix-1,iy,iz,it)
        IF (uLoc>Zero) THEN
          f(ix,iy,iz,it)=f(ix,iy,iz,it)-uLoc*(-cLeft)*Half*(FL+FR)
        END IF  
      END DO
    END DO
  END IF
  IF (TypeW=='oe') THEN
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        uLoc=Half*(uCL(ix,iy,iz,1)+uCR(ix,iy,iz,1))/(Rho(ix,iy,iz,1)+Eps)
        cRight=c(ix+1,iy,iz,it)
        IF (uLoc<Zero) THEN
          f(ix,iy,iz,it)=f(ix,iy,iz,it)-uLoc*(cRight)*Half*(FL+FR)
        END IF  
      END DO
    END DO
  END IF
  IF (TypeB=='ob') THEN
    iz=iz0+1
    DO ix=ix0+1,ix1
      DO iy=iy0+1,iy1
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        wLoc=Half*(wCL(ix,iy,iz,1)+wCR(ix,iy,iz,1))/(Rho(ix,iy,iz,1)+Eps)
        cLeft=c(ix,iy,iz-1,it)
        IF (FL==Zero) THEN
          cLeft=c(ix,iy,iz,it)
        END IF  
        IF (wLoc>Zero) THEN
          f(ix,iy,iz,it)=f(ix,iy,iz,it)-wLoc*(-cLeft)*Half*(FL+FR)
        END IF  
      END DO
    END DO
  END IF
  IF (TypeT=='ot') THEN
    iz=iz1
    DO ix=ix0+1,ix1
      DO iy=iy0+1,iy1
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        wLoc=Half*(wCL(ix,iy,iz,1)+wCR(ix,iy,iz,1))/(Rho(ix,iy,iz,1)+Eps)
        cRight=c(ix,iy,iz+1,it)
        IF (wLoc<Zero) THEN
          f(ix,iy,iz,it)=f(ix,iy,iz,it)-wLoc*(cRight)*Half*(FL+FR)
        END IF  
      END DO
    END DO
  END IF
  END DO !it

END SUBROUTINE AdvectionPreComputeV2

SUBROUTINE AdvectionPreComputeV3(Phi,FallF)

  INTERFACE
    FUNCTION Phi(r,k1,k2,cR,cC,cL,hC)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2,cR,cC,cL,hC
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cL,cC,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux
  REAL(RealKind) :: cDiff,cLeft,cRight
  REAL(RealKind) :: uLe,uRi,vLe,vRi,wLe,wRi
  REAL(RealKind) :: uLoc,vLoc,wLoc
  REAL(RealKind) :: RhoLF,wfLoc


  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cC=c(ix,iy,iz,it)
        VC=VolC(ix,iy,iz)

!       x-Direction
        cL=c(ix-1,iy,iz,it)
        cR=c(ix+1,iy,iz,it)
        VL=VolC(ix-1,iy,iz)
        VR=VolC(ix+1,iy,iz)
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix-1,iy,iz))-uF(ix-1,iy,iz))* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))       
        f(ix-1,iy,iz,it)=f(ix-1,iy,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary 
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix,iy,iz))+uF(ix,iy,iz))* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux

!       y-Direction
        cL=c(ix,iy-1,iz,it)
        cR=c(ix,iy+1,iz,it)
        VL=VolC(ix,iy-1,iz)
        VR=VolC(ix,iy+1,iz)
        FR=FV(ix,iy,iz)
        FL=FV(ix,iy-1,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy-1,iz))-vF(ix,iy-1,iz))* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))
        f(ix,iy-1,iz,it)=f(ix,iy-1,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy,iz))+vF(ix,iy,iz))* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix,iy+1,iz,it)=f(ix,iy+1,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux

!       z-Direction
        cL=c(ix,iy,iz-1,it)
        cR=c(ix,iy,iz+1,it)
        VL=VolC(ix,iy,iz-1)
        VR=VolC(ix,iy,iz+1)
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        IF (PRESENT(FallF)) THEN
           RhoLF=CellToFaceVol(RhoR(ix,iy,iz-1,1),RhoR(ix,iy,iz,1) &
                           ,VL,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz-1) &
             +CellToFaceVol(Rho(ix,iy,iz-1,1),Rho(ix,iy,iz,1) &
                           ,VolC(ix,iy,iz-1),VolC(ix,iy,iz))*(vFall+vSub(zP(iz-1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))
        f(ix,iy,iz-1,it)=f(ix,iy,iz-1,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary
        IF (PRESENT(FallF)) THEN
           RhoLF=CellToFaceVol(RhoR(ix,iy,iz+1,1),RhoR(ix,iy,iz,1) &
                               ,VR,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz) &
             +CellToFaceVol(Rho(ix,iy,iz+1,1),Rho(ix,iy,iz,1) &
                           ,VolC(ix,iy,iz+1),VolC(ix,iy,iz))*(vFall+vSub(zP(iz)))
        Flux=Half*(ABS(wFLoc)+wFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix,iy,iz+1,it)=f(ix,iy,iz+1,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
      END DO
    END DO
  END DO
  IF (TypeW=='ow') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix0,iy,iz))+uF(ix0,iy,iz))* &
              c(ix0,iy,iz,it)*FU(ix0,iy,iz)
        f(ix0+1,iy,iz,it)=f(ix0+1,iy,iz,it)+Flux
        f(ix0,iy,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeE=='oe') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix1,iy,iz))-uF(ix1,iy,iz))* &
              c(ix1+1,iy,iz,it)*FU(ix1,iy,iz) 
        f(ix1,iy,iz,it)=f(ix1,iy,iz,it)+Flux
        f(ix1+1,iy,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeS=='os') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy0,iz))+vF(ix,iy0,iz))* &
              c(ix,iy0,iz,it)*FV(ix,iy0,iz)
        f(ix,iy0+1,iz,it)=f(ix,iy0+1,iz,it)+Flux
        f(ix,iy0,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeN=='on') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy1,iz))-vF(ix,iy1,iz))* &
              c(ix,iy1+1,iz,it)*FV(ix,iy1,iz)
        f(ix,iy1,iz,it)=f(ix,iy1,iz,it)+Flux
        f(ix,iy1+1,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeB=='ob') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz0+1,1))
        END IF
        wFLoc=wF(ix,iy,iz0) &
             +Rho(ix,iy,iz0+1,1)*(vFall+vSub(zP(iz0)))
        Flux=Half*(ABS(wFLoc)+wFLoc)* &
              c(ix,iy,iz0,it)*FW(ix,iy,iz0)
        f(ix,iy,iz0+1,it)=f(ix,iy,iz0+1,it)+Flux 
        f(ix,iy,iz0,it)=Zero 
      END DO
    END DO
  END IF
  IF (TypeT=='ot') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz1,1))
        END IF
        wFLoc=wF(ix,iy,iz1) &
             +Rho(ix,iy,iz1,1)*(vFall+vSub(zP(iz1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
              c(ix,iy,iz1+1,it)*FW(ix,iy,iz1)
        f(ix,iy,iz1,it)=f(ix,iy,iz1,it)+Flux
        f(ix,iy,iz1+1,it)=Zero
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        f(ix,iy,iz,it)=f(ix,iy,iz,it)+c(ix,iy,iz,it) &
                      *(FU(ix,iy,iz)*uF(ix,iy,iz) &
                       -FU(ix-1,iy,iz)*uF(ix-1,iy,iz) &
                       +FV(ix,iy,iz)*vF(ix,iy,iz) &
                       -FV(ix,iy-1,iz)*vF(ix,iy-1,iz) &
                       +FW(ix,iy,iz)*wF(ix,iy,iz) &
                       -FW(ix,iy,iz-1)*wF(ix,iy,iz-1)) 
      END DO
    END DO
  END DO
  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        f(ix,iy,iz,it)=f(ix,iy,iz,it)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)/(Rho(ix,iy,iz,1)+Eps)
      END DO
    END DO
  END DO
  END DO

END SUBROUTINE AdvectionPreComputeV3

FUNCTION RhoFace(RhoL,RhoR,VL,VR)

  REAL(RealKind) :: RhoFace
  REAL(RealKind) :: RhoL,RhoR,VL,VR

  RhoFace=(RhoL*VL+RhoR*VR)/(VR+VL+Eps)
END FUNCTION RhoFace

SUBROUTINE AdvectionPreComputeC(FallF)

  INTERFACE
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cC,cL,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux
  REAL(RealKind) :: cDiff
  REAL(RealKind) :: uLe,uRi,vLe,vRi,wLe,wRi
  REAL(RealKind) :: RhoLF

  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cC=c(ix,iy,iz,it)
        VC=VolC(ix,iy,iz)

!       x-Direction
        cL=c(ix-1,iy,iz,it)
        cR=c(ix+1,iy,iz,it)
        VL=VolC(ix-1,iy,iz)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix+1,iy,iz)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)
        uLe=uF(ix-1,iy,iz)
        uRi=uF(ix,iy,iz)
        Flux=FaceToCell(uLe*Gradient(cL,cC,FL,VL,VC),uRi*Gradient(cC,cR,FR,VC,VR),FL,FR) &
             *VC/(Rho(ix,iy,iz,1)+Eps)

!       y-Direction
        cL=c(ix,iy-1,iz,it)
        cR=c(ix,iy+1,iz,it)
        VL=VolC(ix,iy-1,iz)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix,iy+1,iz)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FV(ix,iy,iz)
        FL=FV(ix,iy-1,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)
        vLe=vF(ix,iy-1,iz)
        vRi=vF(ix,iy,iz)
        Flux=FaceToCell(vLe*Gradient(cL,cC,FL,VL,VC),vRi*Gradient(cC,cR,FR,VC,VR),FL,FR) &
             *VC/(Rho(ix,iy,iz,1)+Eps)
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux

!       z-Direction
        cL=c(ix,iy,iz-1,it)
        cR=c(ix,iy,iz+1,it)
        VL=VolC(ix,iy,iz-1)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix,iy,iz+1)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)
        wLe=wF(ix,iy,iz-1)
        wRi=wF(ix,iy,iz)
        Flux=FaceToCell(wLe*Gradient(cL,cC,FL,VL,VC),wRi*Gradient(cC,cR,FR,VC,VR),FL,FR) &
             *VC/(Rho(ix,iy,iz,1)+Eps)
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux

      END DO 
    END DO 
  END DO 
  END DO 

END SUBROUTINE AdvectionPreComputeC


SUBROUTINE AdvectionCompute4
  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: cLL,cL,cC,cR,cRR,cF
  REAL(RealKind) :: hLL,hL,hC,hR,hRR
  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+2,ix1-1
        cLL=c(ix-2,iy,iz,it)/(Rho(ix-2,iy,iz,it)+Eps)
        cL=c(ix-1,iy,iz,it)/(Rho(ix-1,iy,iz,it)+Eps)
        cC=c(ix,iy,iz,it)/(Rho(ix,iy,iz,it)+Eps)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,it)+Eps)
        cRR=c(ix+2,iy,iz,it)/(Rho(ix+2,iy,iz,it)+Eps)
        cF=(cLL+5.0d0*cL)
        f(ix,iy,iz,it)=f(ix,iy,iz,it)
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)
      END DO
    END DO
  END DO
  END DO
END SUBROUTINE AdvectionCompute4

SUBROUTINE AdvectionComputeP(Phi,FallF)

  INTERFACE
    FUNCTION Phi1(r,k1,k2)
      USE Kind_Mod
      REAL(RealKind) :: Phi1,r,k1,k2
    END FUNCTION Phi1
    FUNCTION Phi(r,k1,k2,cL,cC,cR,hC)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2,cL,cC,cR,hC
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cC,cL,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux
  REAL(RealKind) :: cDiff
  REAL(RealKind) :: wFLoc
  REAL(RealKind) :: RhoLF

  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cC=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VC=VolC(ix,iy,iz)

!       x-Direction
        cL=c(ix-1,iy,iz,it)/(Rho(ix-1,iy,iz,1)+Eps)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VL=VolC(ix-1,iy,iz)
        VR=VolC(ix+1,iy,iz)
        IF (VL<VC) cL=((VC-VL)*cC+VL*cL)/VC
        IF (VR<VC) cR=((VC-VR)*cC+VR*cR)/VC
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix-1,iy,iz))-uF(ix-1,iy,iz))* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))       
        f(ix-1,iy,iz,it)=f(ix-1,iy,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary 
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix,iy,iz))+uF(ix,iy,iz))* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       y-Direction
        cL=c(ix,iy-1,iz,it)/(Rho(ix,iy-1,iz,1)+Eps)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VL=VolC(ix,iy-1,iz)
        VR=VolC(ix,iy+1,iz)
        IF (VL<VC) cL=((VC-VL)*cC+VL*cL)/VC
        IF (VR<VC) cR=((VC-VR)*cC+VR*cR)/VC
        FR=FV(ix,iy,iz)
        FL=FV(ix,iy-1,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy-1,iz))-vF(ix,iy-1,iz))* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))
        f(ix,iy-1,iz,it)=f(ix,iy-1,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy,iz))+vF(ix,iy,iz))* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix,iy+1,iz,it)=f(ix,iy+1,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux

!       z-Direction
        cL=c(ix,iy,iz-1,it)/(Rho(ix,iy,iz-1,1)+Eps)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VL=VolC(ix,iy,iz-1)
        VR=VolC(ix,iy,iz+1)
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Precipitation part
!       Left boundary
        IF (PRESENT(FallF)) THEN
          RhoLF=CellToFaceVol(RhoR(ix,iy,iz-1,1),RhoR(ix,iy,iz,1) &
                           ,VL,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz-1) &
             +CellToFaceVol(Rho(ix,iy,iz-1,1),Rho(ix,iy,iz,1) &
                           ,VolC(ix,iy,iz-1),VolC(ix,iy,iz))*(vFall+vSub(zP(iz-1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))
        f(ix,iy,iz-1,it)=f(ix,iy,iz-1,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary
        IF (PRESENT(FallF)) THEN
          RhoLF=CellToFaceVol(RhoR(ix,iy,iz+1,1),RhoR(ix,iy,iz,1) &
                               ,VR,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz) &
             +CellToFaceVol(Rho(ix,iy,iz+1,1),Rho(ix,iy,iz,1) &
                           ,VolC(ix,iy,iz+1),VolC(ix,iy,iz))*(vFall+vSub(zP(iz)))
        Flux=Half*(ABS(wFLoc)+wFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix,iy,iz+1,it)=f(ix,iy,iz+1,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
      END DO
    END DO
  END DO
  IF (TypeW=='ow') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix0,iy,iz))+uF(ix0,iy,iz))* &
              c(ix0,iy,iz,it)/(Rho(ix0,iy,iz,1)+Eps)*FU(ix0,iy,iz)
        f(ix0+1,iy,iz,it)=f(ix0+1,iy,iz,it)+Flux
        f(ix0,iy,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeE=='oe') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix1,iy,iz))-uF(ix1,iy,iz))* &
              c(ix1+1,iy,iz,it)/(Rho(ix1+1,iy,iz,1)+Eps)*FU(ix1,iy,iz) 
        f(ix1,iy,iz,it)=f(ix1,iy,iz,it)+Flux
        f(ix1+1,iy,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeS=='os') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy0,iz))+vF(ix,iy0,iz))* &
              c(ix,iy0,iz,it)/(Rho(ix,iy0,iz,1)+Eps)*FV(ix,iy0,iz)
        f(ix,iy0+1,iz,it)=f(ix,iy0+1,iz,it)+Flux
        f(ix,iy0,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeN=='on') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy1,iz))-vF(ix,iy1,iz))* &
              c(ix,iy1+1,iz,it)/(Rho(ix,iy1+1,iz,1)+Eps)*FV(ix,iy1,iz)
        f(ix,iy1,iz,it)=f(ix,iy1,iz,it)+Flux
        f(ix,iy1+1,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeB=='ob') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz0+1,1))
        END IF
        wFLoc=wF(ix,iy,iz0) &
             +Rho(ix,iy,iz0+1,1)*(vFall+vSub(zP(iz0)))
        Flux=Half*(ABS(wFLoc)+wFLoc)* &
              c(ix,iy,iz0,it)/(Rho(ix,iy,iz0+1,1)+Eps)*FW(ix,iy,iz0)
        f(ix,iy,iz0+1,it)=f(ix,iy,iz0+1,it)+Flux 
        f(ix,iy,iz0,it)=Zero 
      END DO
    END DO
  END IF
  IF (TypeT=='ot') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz1,1))
        END IF
        wFLoc=wF(ix,iy,iz1) &
             +Rho(ix,iy,iz1,1)*(vFall+vSub(zP(iz1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
              c(ix,iy,iz1+1,it)/(Rho(ix,iy,iz1+1,1)+Eps)*FW(ix,iy,iz1)
        f(ix,iy,iz1,it)=f(ix,iy,iz1,it)+Flux
        f(ix,iy,iz1+1,it)=Zero
      END DO
    END DO
  END IF
  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        f(ix,iy,iz,it)=f(ix,iy,iz,it)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  END DO

END SUBROUTINE AdvectionComputeP


SUBROUTINE AdvectionComputeC(Phi,FallF)

  INTERFACE
    FUNCTION Phi1(r,k1,k2)
      USE Kind_Mod
      REAL(RealKind) :: Phi1,r,k1,k2
    END FUNCTION Phi1
    FUNCTION Phi(r,k1,k2,cL,cC,cR,hC)
      USE KIND_Mod
      REAL(RealKind) :: Phi,r,k1,k2,cL,cC,cR,hC
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cC,cL,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux
  REAL(RealKind) :: cDiff
  REAL(RealKind) :: uFLoc,vFloc,wFLoc
  REAL(RealKind) :: RhoLe,RhoC,RhoRi
  REAL(RealKind) :: RhoLF

  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoC=Rho(ix,iy,iz,1)
        cC=c(ix,iy,iz,it)
        VC=VolC(ix,iy,iz)

!       x-Direction
        RhoLe=Rho(ix-1,iy,iz,1)
        cL=c(ix-1,iy,iz,it)
        RhoRi=Rho(ix+1,iy,iz,1)
        cR=c(ix+1,iy,iz,it)
        VL=VolC(ix-1,iy,iz)
        VR=VolC(ix+1,iy,iz)
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        uFLoc=uF(ix-1,iy,iz)*(VC+VL)/(VC*RhoC+VL*RhoLe+Eps)
        Flux=Half*(ABS(uFLoc)-uFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))
        f(ix-1,iy,iz,it)=f(ix-1,iy,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary 
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        uFLoc=uF(ix,iy,iz)*(VC+VR)/(VC*RhoC+VR*RhoRi+Eps)
        Flux=Half*(ABS(uFLoc)+uFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux

!       y-Direction
        RhoLe=Rho(ix,iy-1,iz,1)
        cL=c(ix,iy-1,iz,it)
        RhoRi=Rho(ix,iy+1,iz,1)
        cR=c(ix,iy+1,iz,it)
        VL=VolC(ix,iy-1,iz)
        VR=VolC(ix,iy+1,iz)
        FR=FV(ix,iy,iz)
        FL=FV(ix,iy-1,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        vFLoc=vF(ix,iy-1,iz)*(VC+VL)/(VC*RhoC+VL*RhoLe+Eps)
        Flux=Half*(ABS(vFLoc)-vFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))
        f(ix,iy-1,iz,it)=f(ix,iy-1,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        vFLoc=vF(ix,iy,iz)*(VC+VR)/(VC*RhoC+VR*RhoRi+Eps)
        Flux=Half*(ABS(vFLoc)+vFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix,iy+1,iz,it)=f(ix,iy+1,iz,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux

!       z-Direction
        RhoLe=Rho(ix,iy,iz-1,1)
        cL=c(ix,iy,iz-1,it)
        RhoRi=Rho(ix,iy,iz+1,1)
        cR=c(ix,iy,iz+1,it)
        VL=VolC(ix,iy,iz-1)
        VR=VolC(ix,iy,iz+1)
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        IF (PRESENT(FallF)) THEN
          RhoLF=CellToFaceVol(RhoR(ix,iy,iz-1,1),RhoR(ix,iy,iz,1) & 

                           ,VL,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cR-cC
        r=(cC-cL+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz-1)*(VC+VL)/(VC*RhoC+VL*RhoLe+Eps)+(vFall+vSub(zP(iz-1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))
        f(ix,iy,iz-1,it)=f(ix,iy,iz-1,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
!       Right boundary
        IF (PRESENT(FallF)) THEN
           RhoLF=CellToFaceVol(RhoR(ix,iy,iz+1,1),RhoR(ix,iy,iz,1) &
                               ,VR,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz)*(VC+VR)/(VC*RhoC+VR*RhoRi+Eps)+(vFall+vSub(zP(iz)))
        Flux=Half*(ABS(wFLoc)+wFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        f(ix,iy,iz+1,it)=f(ix,iy,iz+1,it)+Flux
        f(ix,iy,iz,it)=f(ix,iy,iz,it)-Flux
      END DO
    END DO
  END DO
  IF (TypeW=='ow') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix0,iy,iz))+uF(ix0,iy,iz))* &
              c(ix0,iy,iz,it)/(Rho(ix0,iy,iz,1)+Eps)*FU(ix0,iy,iz)
        f(ix0+1,iy,iz,it)=f(ix0+1,iy,iz,it)+Flux
        f(ix0,iy,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeE=='oe'.AND.BCvel%East/='OutFlow') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix1,iy,iz))-uF(ix1,iy,iz))* &
              c(ix1+1,iy,iz,it)/(Rho(ix1+1,iy,iz,1)+Eps)*FU(ix1,iy,iz) 
        f(ix1,iy,iz,it)=f(ix1,iy,iz,it)+Flux
        f(ix1+1,iy,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeS=='os') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy0,iz))+vF(ix,iy0,iz))* &
              c(ix,iy0,iz,it)/(Rho(ix,iy0,iz,1)+Eps)*FV(ix,iy0,iz)
        f(ix,iy0+1,iz,it)=f(ix,iy0+1,iz,it)+Flux
        f(ix,iy0,iz,it)=Zero
      END DO
    END DO
  END IF
  IF (TypeN=='on') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy1,iz))-vF(ix,iy1,iz))* &
              c(ix,iy1+1,iz,it)/(Rho(ix,iy1+1,iz,1)+Eps)*FV(ix,iy1,iz)
        f(ix,iy1,iz,it)=f(ix,iy1,iz,it)+Flux
        f(ix,iy1+1,iz,it)=Zero
      END DO
    END DO
  END IF 

  IF (TypeB=='ob') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz0+1,1))
        END IF
        wFLoc=wF(ix,iy,iz0) &
             +Rho(ix,iy,iz0+1,1)*(vFall+vSub(zP(iz0)))
        Flux=Half*(ABS(wFLoc)+wFLoc)* &
              c(ix,iy,iz0,it)/(Rho(ix,iy,iz0+1,1)+Eps)*FW(ix,iy,iz0)
        f(ix,iy,iz0+1,it)=f(ix,iy,iz0+1,it)+Flux 
        f(ix,iy,iz0,it)=Zero 
      END DO
    END DO
  END IF
  IF (TypeT=='ot') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz1,1))
        END IF
        wFLoc=wF(ix,iy,iz1) &
             +Rho(ix,iy,iz1,1)*(vFall+vSub(zP(iz1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
              c(ix,iy,iz1+1,it)/(Rho(ix,iy,iz1+1,1)+Eps)*FW(ix,iy,iz1)
        f(ix,iy,iz1,it)=f(ix,iy,iz1,it)+Flux
        f(ix,iy,iz1+1,it)=Zero
      END DO
    END DO
  END IF
  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        f(ix,iy,iz,it)=f(ix,iy,iz,it)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  END DO

END SUBROUTINE AdvectionComputeC

SUBROUTINE AdvectionQECompute(Phi,FallF)

  INTERFACE
    FUNCTION Phi(r,k1,k2)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cC,cL,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux,Flux1,Flux2
  REAL(RealKind) :: PreFac 
  REAL(RealKind) :: cDiff
  REAL(RealKind) :: uFLoc,vFloc,wFLoc
  REAL(RealKind) :: RhoL,RhoC,RhoR
  REAL(RealKind) :: RhoLL,RhoCL,RhoRL
  REAL(RealKind) :: RhoLF

END SUBROUTINE AdvectionQECompute


SUBROUTINE AdvectionQFallCompute(Phi,FallF)

  INTERFACE
    FUNCTION Phi(r,k1,k2)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cC,cL,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux,Flux1,Flux2
  REAL(RealKind) :: cDiff
  REAL(RealKind) :: uFLoc,vFloc,wFLoc
  REAL(RealKind) :: RhoLe,RhoC,RhoRi
  REAL(RealKind) :: RhoLF
  REAL(RealKind) :: RhoLoc,RhoDLoc,RhoVLoc,RhoLLoc,TLoc,pLoc,ExnerPre
  REAL(RealKind) :: Cpml,Rm,Cp_eff,ThDens,ThEquiv,TotalEnergy 
  REAL(RealKind) :: PreFac 

  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoC=Rho(ix,iy,iz,1)
        cC=RhoR(ix,iy,iz,it)
        VC=VolC(ix,iy,iz)

!       z-Direction
        RhoLe=Rho(ix,iy,iz-1,1)
        cL=RhoR(ix,iy,iz-1,it)
        VL=VolC(ix,iy,iz-1)
        IF (VL==Zero) THEN
          cL=cC
        END IF

        RhoRi=Rho(ix,iy,iz+1,1)
        cR=RhoR(ix,iy,iz+1,it)
        VR=VolC(ix,iy,iz+1)
        IF (VR==Zero) THEN
          cR=cC
        END IF

        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
!       Compute d/dz([W_f+w]*RhoR) = Flux1
        IF (PRESENT(FallF)) THEN
          RhoLF=CellToFaceVol(RhoR(ix,iy,iz-1,1),RhoR(ix,iy,iz,1) &
                           ,VL,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz-1)*(VC+VL)/(VC*RhoC+VL*RhoLe+Eps)+(vFall+vSub(zP(iz-1)))
        Flux1=Half*(ABS(wFLoc)-wFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2)*(cC-cR))
!       Compute d/dz(w*RhoR) = Flux2
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz-1)*(VC+VL)/(VC*RhoC+VL*RhoLe+Eps)
        Flux2=Half*(ABS(wFLoc)-wFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2)*(cC-cR))
!       Compute Flux
        Flux=Flux1-Flux2
        IF (ic==RhoPos) THEN
          RhoRhs(ix,iy,iz-1,it)=RhoRhs(ix,iy,iz-1,it)+Flux
          RhoRhs(ix,iy,iz,it)=RhoRhs(ix,iy,iz,it)-Flux
        ELSE IF (ic==ThPos) THEN
          RhoLoc=Rho(ix,iy,iz,1)+Eps
          RhoVLoc=RhoV(ix,iy,iz,1)+Eps
          RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)+Eps
          RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Three*Eps
          TLoc=T(ix,iy,iz,1)+Eps
          pLoc=p(ix,iy,iz,1)+Eps
          Rm=Rd+RhoVLoc/RhoDLoc*Rv
          Cpml=Cpd+RhoVLoc/RhoDLoc*Cpv+RhoLLoc/RhoDLoc*Cpl
          ExnerPre=(pLoc/p0)**(Rm/Cpml)
          SELECT CASE(ThetaKind)
          CASE('Density')
            ThDens=TLoc/ExnerPre*(1+Rv/Rd*RhoVLoc/RhoDLoc)/(1+RhoVLoc/RhoDLoc+RhoLLoc/RhoDLoc)
            PreFac=RhoLoc*ThDens*(Cpl/(RhoDLoc*Cpml)-LOG(ExnerPre)/RhoDLoc*(Cpl/Cpml)+1.0d0/RhoLoc)
          CASE('Equiv')
            Cp_eff=Cpd+(RhoVLoc/RhoDLoc+RhoLLoc/RhoDLoc)*Cpl
            ThEquiv=TLoc*(p0/(RhoDLoc*Rd*TLoc))**(Rd/Cp_eff) &
                     *RelHumidity(TLoc,RhoVLoc)**(-RhoVLoc/RhoDLoc*Rv/Cp_eff) &
                     *EXP(RhoDLoc*LatHeat(TLoc)/(RhoDLoc*Cp_eff*TLoc)) 
            PreFac=-RhoLoc*ThEquiv*Cpl/(RhoDLoc*Cp_eff**2) &
                    *(Rd*LOG(p0/pLoc*(1+Rv/Rd*RhoVLoc/RhoDLoc)-RhoVLoc) &
                      -RhoVLoc/RhoDLoc*Rv*LOG(RelHumidity(TLoc,RhoVLoc)) &
                      +RhoVLoc/RhoDLoc*LatHeat(TLoc)/TLoc &
                     ) &
                   -ThEquiv
          END SELECT
          ThRhs(ix,iy,iz+1,it)=ThRhs(ix,iy,iz+1,it)+PreFac*Flux
          ThRhs(ix,iy,iz,it)=ThRhs(ix,iy,iz,it)-PreFac*Flux
        END IF

!       Right boundary
!       Compute d/dz([W_f+w]*RhoR) = Flux1
        IF (PRESENT(FallF)) THEN
           RhoLF=CellToFaceVol(RhoR(ix,iy,iz+1,1),RhoR(ix,iy,iz,1) &
                               ,VR,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz)*(VC+VR)/(VC*RhoC+VR*RhoRi+Eps)+(vFall+vSub(zP(iz)))
        Flux1=Half*(ABS(wFLoc)+wFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2)*(cC-cL))
!       Compute d/dz(w*RhoR) = Flux2
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz)*(VC+VR)/(VC*RhoC+VR*RhoRi+Eps)
        Flux2=Half*(ABS(wFLoc)+wFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2)*(cC-cL))
!       Compute Flux
        Flux=Flux1-Flux2
        IF (ic==RhoPos) THEN
          RhoRhs(ix,iy,iz+1,it)=RhoRhs(ix,iy,iz+1,it)+Flux
          RhoRhs(ix,iy,iz,it)=RhoRhs(ix,iy,iz,it)-Flux
        ELSE IF (ic==ThPos) THEN
          RhoLoc=Rho(ix,iy,iz,1)+Eps
          RhoVLoc=RhoV(ix,iy,iz,1)+Eps
          RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)+Eps
          RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Three*Eps
          TLoc=T(ix,iy,iz,1)+Eps
          pLoc=p(ix,iy,iz,1)+Eps
          Rm=Rd+RhoVLoc/RhoDLoc*Rv
          Cpml=Cpd+RhoVLoc/RhoDLoc*Cpv+RhoLLoc/RhoDLoc*Cpl
          ExnerPre=(pLoc/p0)**(Rm/Cpml)
          SELECT CASE(ThetaKind)
          CASE('Density')
            ThDens=TLoc/ExnerPre*(1+Rv/Rd*RhoVLoc/RhoDLoc)/(1+RhoVLoc/RhoDLoc+RhoLLoc/RhoDLoc)
            PreFac=RhoLoc*ThDens*(Cpl/(RhoDLoc*Cpml)-LOG(ExnerPre)/RhoDLoc*(Cpl/Cpml)+1.0d0/RhoLoc)
          CASE('Equiv')
            Cp_eff=Cpd+(RhoVLoc/RhoDLoc+RhoLLoc/RhoDLoc)*Cpl
            ThEquiv=TLoc*(p0/(RhoDLoc*Rd*TLoc))**(Rd/Cp_eff) &
                     *RelHumidity(TLoc,RhoVLoc)**(-RhoVLoc/RhoDLoc*Rv/Cp_eff) &
                     *EXP(RhoDLoc*LatHeat(TLoc)/(RhoDLoc*Cp_eff*TLoc)) 
            PreFac=-ThEquiv*Cpl/(RhoDLoc*Cp_eff**2) &
                    *(Rd*LOG(p0/pLoc*(1+Rv/Rd*RhoVLoc/RhoDLoc)-RhoVLoc) &
                      -RhoVLoc/RhoDLoc*Rv*LOG(RelHumidity(TLoc,RhoVLoc)) &
                      +RhoVLoc/RhoDLoc*LatHeat(TLoc)/TLoc &
                     )
          END SELECT
          ThRhs(ix,iy,iz+1,it)=ThRhs(ix,iy,iz+1,it)+PreFac*Flux
          ThRhs(ix,iy,iz,it)=ThRhs(ix,iy,iz,it)-PreFac*Flux
        END IF
      END DO
    END DO
  END DO 
  END DO !it

END SUBROUTINE AdvectionQFallCompute

SUBROUTINE AdvectionFaceCompute1(Phi,FallF)

  INTERFACE
    FUNCTION Phi(r,k1,k2)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cC,cL,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux
  REAL(RealKind) :: cDiff
  REAL(RealKind) :: wFLoc
  REAL(RealKind) :: RhoLF

  cFU=Zero
  cFV=Zero
  cFW=Zero
! Fluxes
  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cC=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VC=VolC(ix,iy,iz)

!       x-Direction
        cL=c(ix-1,iy,iz,it)/(Rho(ix-1,iy,iz,1)+Eps)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VL=VolC(ix-1,iy,iz)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix+1,iy,iz)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix-1,iy,iz)+Eps)-uF(ix-1,iy,iz)-Eps)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2)*(cC-cR))
        cFU(ix-1,iy,iz,it)=cFU(ix-1,iy,iz,it)+Flux/(FL*ABS(uF(ix-1,iy,iz)+Eps)+Eps**2)
!       Right boundary 
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix,iy,iz)+Eps)+uF(ix,iy,iz)+Eps)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2)*(cC-cL))
        cFU(ix,iy,iz,it)=cFU(ix,iy,iz,it)+Flux/(FR*ABS(uF(ix,iy,iz)+Eps)+Eps**2)

!       y-Direction
        cL=c(ix,iy-1,iz,it)/(Rho(ix,iy-1,iz,1)+Eps)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VL=VolC(ix,iy-1,iz)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix,iy+1,iz)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FV(ix,iy,iz)
        FL=FV(ix,iy-1,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy-1,iz)+Eps)-vF(ix,iy-1,iz)-Eps)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2)*(cC-cR))
        cFV(ix,iy-1,iz,it)=cFV(ix,iy-1,iz,it)+Flux/(FL*ABS(vF(ix,iy-1,iz)+Eps)+Eps**2)
!       Right boundary
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy,iz)+Eps)+vF(ix,iy,iz)+Eps)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2)*(cC-cL))
        cFV(ix,iy,iz,it)=cFV(ix,iy,iz,it)+Flux/(FR*ABS(vF(ix,iy,iz)+Eps)+Eps**2)

!       z-Direction
        cL=c(ix,iy,iz-1,it)/(Rho(ix,iy,iz-1,1)+Eps)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VL=VolC(ix,iy,iz-1)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix,iy,iz+1)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz-1) 
        Flux=Half*(ABS(wFLoc+Eps)-wFLoc-Eps)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2)*(cC-cR))
        cFW(ix,iy,iz-1,it)=cFW(ix,iy,iz-1,it)+Flux/(FL*ABS(wFLoc+Eps)+Eps**2)
!       Right boundary
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz) 
        Flux=Half*(ABS(wFLoc+Eps)+wFLoc+Eps)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2)*(cC-cL))
        cFW(ix,iy,iz,it)=cFW(ix,iy,iz,it)+Flux/FR*(ABS(wFLoc+Eps)+Eps**2)
      END DO
    END DO
  END DO
  IF (TypeW=='ow') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix0,iy,iz)+Eps)+uF(ix0,iy,iz)+Eps)* &
              c(ix0,iy,iz,it)/(Rho(ix0,iy,iz,1)+Eps)*FU(ix0,iy,iz)
        cFU(ix0,iy,iz,it)=cFU(ix0,iy,iz,it)+Flux/(FU(ix0,iy,iz)*ABS(uF(ix0,iy,iz)+Eps)+Eps**2)
      END DO
    END DO
  END IF
  IF (TypeE=='oe') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix1,iy,iz)+Eps)-uF(ix1,iy,iz)-Eps)* &
              c(ix1+1,iy,iz,it)/(Rho(ix1+1,iy,iz,1)+Eps)*FU(ix1,iy,iz) 
        cFU(ix1,iy,iz,it)=cFU(ix1,iy,iz,it)+Flux/(FU(ix1,iy,iz)*ABS(uF(ix1,iy,iz)+Eps)+Eps**2)
      END DO
    END DO
  END IF
  IF (TypeS=='os') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy0,iz)+Eps)+vF(ix,iy0,iz)+Eps)* &
              c(ix,iy0,iz,it)/(Rho(ix,iy0,iz,1)+Eps)*FV(ix,iy0,iz)
        cFV(ix,iy0,iz,it)=cFV(ix,iy0,iz,it)+Flux/(FV(ix,iy0,iz)*ABS(vF(ix,iy0,iz)+Eps)+Eps**2)
      END DO
    END DO
  END IF
  IF (TypeN=='on') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy1,iz)+Eps)-vF(ix,iy1,iz)-Eps)* &
              c(ix,iy1+1,iz,it)/(Rho(ix,iy1+1,iz,1)+Eps)*FV(ix,iy1,iz)
        cFV(ix,iy1,iz,it)=cFV(ix,iy1,iz,it)+Flux/(FV(ix,iy1,iz)*ABS(vF(ix,iy1,iz)+Eps)+Eps**2)
      END DO
    END DO
  END IF
  IF (TypeB=='ob') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz0+1,1))
        END IF
        wFLoc=wF(ix,iy,iz0) &
             +Rho(ix,iy,iz0+1,1)*(vFall+vSub(zP(iz0)))
        Flux=Half*(ABS(wFLoc+Eps)+wFLoc+Eps)* &
              c(ix,iy,iz0,it)/(Rho(ix,iy,iz0+1,1)+Eps)*FW(ix,iy,iz0)
        cFW(ix,iy,iz0,it)=cFW(ix,iy,iz0,it)+Flux/(FW(ix,iy,iz0)*ABS(wFLoc+Eps)+Eps**2)
      END DO
    END DO
  END IF
  IF (TypeT=='ot') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz1,1))
        END IF
        wFLoc=wF(ix,iy,iz1) &
             +Rho(ix,iy,iz1,1)*(vFall+vSub(zP(iz1)))
        Flux=Half*(ABS(wFLoc+Eps)-wFLoc-Eps)* &
              c(ix,iy,iz1+1,it)/(Rho(ix,iy,iz1+1,1)+Eps)*FW(ix,iy,iz1)
        cFW(ix,iy,iz1,it)=cFW(ix,iy,iz1,it)+Flux/(FW(ix,iy,iz1)*ABS(wFLoc+Eps)+Eps**2)
      END DO
    END DO
  END IF
  END DO

END SUBROUTINE AdvectionFaceCompute1

SUBROUTINE AdvectionFaceCompute(Phi,FallF)

  INTERFACE
    FUNCTION Phi(r,k1,k2,cL,cC,cR,hC)
      USE Kind_Mod
      REAL(RealKind) :: Phi,r,k1,k2,cL,cC,cR,hC
    END FUNCTION Phi
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: r
  REAL(RealKind) :: hL,hC,hR
  REAL(RealKind) :: k1,k2
  REAL(RealKind) :: cx,cy,cz
  REAL(RealKind) :: cC,cL,cR
  REAL(RealKind) :: VC,VL,VR
  REAL(RealKind) :: FL,FR
  REAL(RealKind) :: Flux
  REAL(RealKind) :: cDiff
  REAL(RealKind) :: wFLoc
  REAL(RealKind) :: RhoLF

  cFU=Zero
  cFV=Zero
  cFW=Zero
! Fluxes
  DO it=LBOUND(c,4),UBOUND(c,4)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cC=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VC=VolC(ix,iy,iz)

!       x-Direction
        cL=c(ix-1,iy,iz,it)/(Rho(ix-1,iy,iz,1)+Eps)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VL=VolC(ix-1,iy,iz)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix+1,iy,iz)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FU(ix,iy,iz)
        FL=FU(ix-1,iy,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix-1,iy,iz))-uF(ix-1,iy,iz))* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))       
        cFU(ix-1,iy,iz,it)=cFU(ix-1,iy,iz,it)+Flux/(FL*(ABS(uF(ix-1,iy,iz)))+Eps*Eps)
!       Right boundary 
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(uF(ix,iy,iz))+uF(ix,iy,iz))* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        cFU(ix,iy,iz,it)=cFU(ix,iy,iz,it)+Flux/(FR*(ABS(uF(ix,iy,iz)))+Eps*Eps)

!       y-Direction
        cL=c(ix,iy-1,iz,it)/(Rho(ix,iy-1,iz,1)+Eps)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VL=VolC(ix,iy-1,iz)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix,iy+1,iz)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FV(ix,iy,iz)
        FL=FV(ix,iy-1,iz)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy-1,iz))-vF(ix,iy-1,iz))* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))       
        cFV(ix,iy-1,iz,it)=cFV(ix,iy-1,iz,it)+Flux/(FL*(ABS(vF(ix,iy-1,iz)))+Eps*Eps)
!       Right boundary
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        Flux=Half*(ABS(vF(ix,iy,iz))+vF(ix,iy,iz))* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        cFV(ix,iy,iz,it)=cFV(ix,iy,iz,it)+Flux/(FR*(ABS(vF(ix,iy,iz)))+Eps*Eps)

!       z-Direction
        cL=c(ix,iy,iz-1,it)/(Rho(ix,iy,iz-1,1)+Eps)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VL=VolC(ix,iy,iz-1)
        IF (VL==Zero) THEN
          cL=cC
        END IF
        VR=VolC(ix,iy,iz+1)
        IF (VR==Zero) THEN
          cR=cC
        END IF
        FR=FW(ix,iy,iz)
        FL=FW(ix,iy,iz-1)
        hL=hLF(VL,FL)
        hC=hCF(VC,FL,FR)
        hR=hRF(VR,FR)

!       Left boundary
        IF (PRESENT(FallF)) THEN
          RhoLF=CellToFaceVol(RhoR(ix,iy,iz-1,1),RhoR(ix,iy,iz,1) &
                           ,VL,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VR,VC,VL)
        k2=k2F(VR,VC,VL)
        cDiff=cC-cR
        r=(cL-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz-1)+CellToFaceVol(Rho(ix,iy,iz-1,1),Rho(ix,iy,iz,1) &
                                        ,VolC(ix,iy,iz-1),VolC(ix,iy,iz)) &
                            *(vFall+vSub(zP(iz-1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
             FL* &
             (cC+FR/(FR+Eps)*phi(r,k1,k2,cL,cC,cR,hC))       
        cFW(ix,iy,iz-1,it)=cFW(ix,iy,iz-1,it)+Flux/(FL*(ABS(wFLoc))+Eps*Eps)
!       Right boundary
        IF (PRESENT(FallF)) THEN
          RhoLF=CellToFaceVol(RhoR(ix,iy,iz,1),RhoR(ix,iy,iz+1,1) &
                           ,VL,VC)
          vFall=FallF(RhoLF)
        END IF
        k1=k1F(VL,VC,VR)
        k2=k2F(VL,VC,VR)
        cDiff=cC-cL
        r=(cR-cC+Eps)/(cDiff+Eps)
        wFLoc=wF(ix,iy,iz)+CellToFaceVol(Rho(ix,iy,iz,1),Rho(ix,iy,iz+1,1) &
                                        ,VolC(ix,iy,iz),VolC(ix,iy,iz+1)) &
                          *(vFall+vSub(zP(iz)))
        Flux=Half*(ABS(wFLoc)+wFLoc)* &
             FR* &
             (cC+FL/(FL+Eps)*phi(r,k1,k2,cR,cC,cL,hC))
        cFW(ix,iy,iz,it)=cFW(ix,iy,iz,it)+Flux/(FR*(ABS(wFLoc))+Eps*Eps)
      END DO
    END DO
  END DO
  IF (TypeW=='ow') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix0,iy,iz))+uF(ix0,iy,iz))* &
              c(ix0,iy,iz,it)/(Rho(ix0,iy,iz,1)+Eps)*FU(ix0,iy,iz)
        cFU(ix0,iy,iz,it)=cFU(ix0,iy,iz,it)+Flux/(FU(ix0,iy,iz)*(ABS(uF(ix0,iy,iz))+Eps)+Eps)
      END DO
    END DO
  END IF
  IF (TypeE=='oe') THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        Flux=Half*(ABS(uF(ix1,iy,iz))-uF(ix1,iy,iz))* &
              c(ix1+1,iy,iz,it)/(Rho(ix1+1,iy,iz,1)+Eps)*FU(ix1,iy,iz) 
        cFU(ix1,iy,iz,it)=cFU(ix1,iy,iz,it)+Flux/(FU(ix1,iy,iz)*(ABS(uF(ix1,iy,iz))+Eps)+Eps)
      END DO
    END DO
  END IF
  IF (TypeS=='os') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy0,iz))+vF(ix,iy0,iz))* &
              c(ix,iy0,iz,it)/(Rho(ix,iy0,iz,1)+Eps)*FV(ix,iy0,iz)
        cFV(ix,iy0,iz,it)=cFV(ix,iy0,iz,it)+Flux/(FV(ix,iy0,iz)*(ABS(vF(ix,iy0,iz))+Eps)+Eps)
      END DO
    END DO
  END IF
  IF (TypeN=='on') THEN
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        Flux=Half*(ABS(vF(ix,iy1,iz))-vF(ix,iy1,iz))* &
              c(ix,iy1+1,iz,it)/(Rho(ix,iy1+1,iz,1)+Eps)*FV(ix,iy1,iz)
        cFV(ix,iy1,iz,it)=cFV(ix,iy1,iz,it)+Flux/(FV(ix,iy1,iz)*(ABS(vF(ix,iy1,iz))+Eps)+Eps)
      END DO
    END DO
  END IF
  IF (TypeB=='ob') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz0+1,1))
        END IF
        wFLoc=wF(ix,iy,iz0) &
             +Rho(ix,iy,iz0+1,1)*(vFall+vSub(zP(iz0)))
        Flux=Half*(ABS(wFLoc)+wFLoc+Eps)* &
              c(ix,iy,iz0,it)/(Rho(ix,iy,iz0+1,1)+Eps)*FW(ix,iy,iz0)
        cFW(ix,iy,iz0,it)=cFW(ix,iy,iz0,it)+Flux/(FW(ix,iy,iz0)*(ABS(wFLoc)+Eps)+Eps)
      END DO
    END DO
  END IF
  IF (TypeT=='ot') THEN
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        IF (PRESENT(FallF)) THEN
          vFall=FallF(RhoR(ix,iy,iz1,1))
        END IF
        wFLoc=wF(ix,iy,iz1) &
             +Rho(ix,iy,iz1,1)*(vFall+vSub(zP(iz1)))
        Flux=Half*(ABS(wFLoc)-wFLoc)* &
              c(ix,iy,iz1+1,it)/(Rho(ix,iy,iz1+1,1)+Eps)*FW(ix,iy,iz1)
        cFW(ix,iy,iz1,it)=cFW(ix,iy,iz1,it)+Flux/(FW(ix,iy,iz1)*(ABS(wFLoc)+Eps)+Eps)
      END DO
    END DO
  END IF
  END DO

END SUBROUTINE AdvectionFaceCompute

FUNCTION hLF(VL,FL)
  REAL(RealKind) :: hLF,VL,FL
  hLF=VL/(FL+Eps)
END FUNCTION hLF
FUNCTION hCF(VC,FL,FR)
  REAL(RealKind) :: hCF,VC,FL,FR
  hCF=2.0e0*VC/(FL+FR+Eps)
END FUNCTION hCF
FUNCTION hRF(VR,FR)
  REAL(RealKind) :: hRF,VR,FR
  hRF=VR/(FR+Eps)
END FUNCTION hRF
FUNCTION k1F(hL,hC,hR)
  REAL(RealKind) :: k1F,hL,hC,hR
  k1F=(hC/(hC+hR+Eps))*((hL+hC)/(hL+hC+hR+Eps))
END FUNCTION k1F
FUNCTION k2F(hL,hC,hR)
  REAL(RealKind) :: k2F,hL,hC,hR
  k2F=(hC/(hL+hC+Eps))*(hR/(hL+hC+hR+Eps))
END FUNCTION k2F

FUNCTION PhiLim(r,k1,k2,cL,cC,cR,hC)
  REAL(RealKind) :: PhiLim,r,k1,k2,cL,cC,cR,hC
  REAL(RealKind) :: rad,eps,eta
  REAL(RealKind) :: q,TOL,a,b,c,d,d1,d2
  SELECT CASE(MethAdv) 
    CASE('Koren')
      PhiLim=(MAX(Zero,MIN(r,MIN(k1*r+k2,One))))*(cC-cR)
    CASE('Third')
      PhiLim=(k1*r+k2)*(cC-cR)
    CASE('Upwind')  
      PhiLim=Zero
    CASE('Leer1')
      PhiLim=(Half*(r+r*r)/(One+r*r))*(cC-cR)
    CASE('Leer2')
      PhiLim=(Half*(r+ABS(r))/(One+ABS(r)))*(cC-cR)
    CASE('Central')
      PhiLim=(Half*r)*(cC-cR)
    CASE('Limo3')
       eps=0.1d0
       eta=(((cC-cR)**2+(cL-cC)**2)/((0.01d0*hC)**2))
       IF (eta<=(1-eps)) THEN
          PhiLim=(k1*r+k2)*(cC-cR)
       ELSE IF (eta>=(1+eps)) THEN
          PhiLim=(MAX(Zero,MIN((k1*r+k2),MAX(-0.25d0*r,MIN(r,(k1*r+k2),0.8d0)))))*(cC-cR)
       ELSE
          PhiLim=0.5d0*((1-(eta-1)/eps)*((k1*r+k2))+(1+(eta-1)/eps)*MAX(Zero,MIN(((k1*r+k2)),MAX(-0.25d0*r,MIN(r,(k1*r+k2),0.8d0)))))*(cC-cR)
       END IF
    CASE('LDLR')
       IF (hC<=0.0d0) THEN
         PhiLim=0.0d0
       ELSE  
         q=1.4d0
         TOL=0.1d0*(1.0d0/160.0d0)**q
         d1=(cC-cR)/hC
         d2=(cL-cC)/hC
         a=1.0d0+TOL-(2.0d0*ABS(d1)**q*ABS(d2)**q+TOL)/(ABS(d1)**(2.0d0*q)+ABS(d2)**(2.0d0*q)+TOL)
         b=a/(a-1)
         c=((a-1.0d0)*(d2*(1.0d0-b)-d1))/(b-a)
         d=d1-c
         PhiLim=(c*hC*Etap(a)+d*hC*Etap(b))
       END IF  
    CASE DEFAULT 
      PhiLim=(k1*r+k2)*(cC-cR)
  END SELECT  
END FUNCTION PhiLim

FUNCTION Etap(k)
  REAL(RealKind) :: Etap,k
  Etap=-(LOG(ABS(1.0d0-k))+k)/(k**2.0d0)
END FUNCTION Etap

FUNCTION phiUnlim(r,k1,k2,cL,cC,cR,hC)
  REAL(RealKind) :: phiUnlim,r,k1,k2
  REAL(RealKind) :: cL,cC,cR,hC
  phiUnlim=(k1*r+k2)*(cR-cC)
END FUNCTION phiUnlim

FUNCTION phiLimSym(r,k1,k2,cL,cC,cR,hC)
  REAL(RealKind) :: phiLimSym,r,k1,k2
  REAL(RealKind) :: cL,cC,cR,hC
  phiLimSym=(Half*r)*(cR-cC)
END FUNCTION phiLimSym


FUNCTION phiLim1(r,k1,k2)
  REAL(RealKind) :: phiLim1,r,k1,k2
  SELECT CASE(MethAdv) 
    CASE('Koren')
      phiLim1=MAX(Zero,Min(r,MIN(k1*r+k2,One)))
    CASE('Third')
      phiLim1=k1*r+k2
    CASE('Upwind')  
      phiLim1=zero
    CASE('Leer1')
      philim1=Half*(r+r*r)/(One+r*r)
    CASE('Leer2')
      philim1=Half*(r+ABS(r))/(One+ABS(r))
    CASE('Central')
      philim1=Half*r
    CASE DEFAULT
      phiLim1=zero
  END SELECT  
END FUNCTION phiLim1

FUNCTION phiLim2(r,k1,k2)
  REAL(RealKind) :: phiLim2,r,k1,k2
  philim2=Half*r
END FUNCTION phiLim2

SUBROUTINE JacAdvectionCompute(FallF)

  INTERFACE
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: i,ix,iy,iz
  INTEGER :: in,jx,jy,jz
  REAL(RealKind) :: VL,VR
  REAL(RealKind) :: F
  REAL(RealKind) :: RhoLF,vFallRhoL
  REAL(RealKind) :: RhoCoarse,RhoFine,VolCoarse,VolFine
  INTEGER :: nxP2,nyP2,nzP2


  nxP2=ix1-ix0+2
  nyP2=iy1-iy0+2
  nzP2=iz1-iz0+2
  vFall=One

  IF (JacTransportX) THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1-1
          VL=VolC(ix,iy,iz)+Eps
          VR=VolC(ix+1,iy,iz)+Eps
          F=FU(ix,iy,iz)
!         uF > 0
          i=Index(ix,iy,iz)
          AT%Val(i,3)=AT%Val(i,3)+Half*(ABS(uF(ix,iy,iz))+uF(ix,iy,iz)) &
                     *F/VR/(Rho(ix,iy,iz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix,iy,iz))+uF(ix,iy,iz)) &
                     *F/VL/(Rho(ix,iy,iz,1)+Eps)
!         uF < 0
          i=Index(ix+1,iy,iz)
          AT%Val(i,5)=AT%Val(i,5)+Half*(ABS(uF(ix,iy,iz))-uF(ix,iy,iz)) &
                     *F/VL/(Rho(ix+1,iy,iz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix,iy,iz))-uF(ix,iy,iz)) &
                     *F/VR/(Rho(ix+1,iy,iz,1)+Eps)
        END DO
      END DO
    END DO
  END IF
  IF (JacTransportY) THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1-1
        DO ix=ix0+1,ix1
          VL=VolC(ix,iy,iz)+Eps
          VR=VolC(ix,iy+1,iz)+Eps
          F=FV(ix,iy,iz)
!         vF > 0
          i=Index(ix,iy,iz)
          AT%Val(i,2)=AT%Val(i,2)+Half*(ABS(vF(ix,iy,iz))+vF(ix,iy,iz)) &
                     *F/VR/(Rho(ix,iy,iz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(ix,iy,iz))+vF(ix,iy,iz)) &
                     *F/VL/(Rho(ix,iy,iz,1)+Eps)
!         vF < 0
          i=Index(ix,iy+1,iz)
          AT%Val(i,6)=AT%Val(i,6)+Half*(ABS(vF(ix,iy,iz))-vF(ix,iy,iz)) &
                     *F/VL/(Rho(ix,iy+1,iz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(ix,iy,iz))-vF(ix,iy,iz)) &
                     *F/VR/(Rho(ix,iy+1,iz,1)+Eps)
        END DO
      END DO
    END DO
  END IF
  IF (JacTransportZ) THEN
    DO iz=iz0+1,iz1-1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          i=Index(ix,iy,iz)
          VL=VolC(ix,iy,iz)+Eps
          VR=VolC(ix,iy,iz+1)+Eps
          F=FW(ix,iy,iz)
!         wF > 0
          i=Index(ix,iy,iz)
          AT%Val(i,1)=AT%Val(i,1)+Half*(ABS(wF(ix,iy,iz))+wF(ix,iy,iz)) &
                     *F/VR/(Rho(ix,iy,iz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(ix,iy,iz))+wF(ix,iy,iz)) &
                     *F/VL/(Rho(ix,iy,iz,1)+Eps)
!         wF < 0
          i=Index(ix,iy,iz+1)
          AT%Val(i,7)=AT%Val(i,7)+Half*(ABS(wF(ix,iy,iz))-wF(ix,iy,iz)) &
                     *F/VL/(Rho(ix,iy,iz+1,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(ix,iy,iz))-wF(ix,iy,iz)) &
                     *F/VR/(Rho(ix,iy,iz+1,1)+Eps)
          IF (PRESENT(FallF)) THEN
            RhoLF=CellToFaceVol(RhoR(ix,iy,iz,1),RhoR(ix,iy,iz+1,1) &
                            ,VL,VR)
            vFallRhoL=FallF(RhoLF)
            AFallRhoL%Val(i,2)=AFallRhoL%Val(i,2)-vFallRhoL*F/VL/(Rho(ix,iy,iz+1,1)+Eps)
            AFallRhoL%Val(i,1)=AFallRhoL%Val(i,1)+vFallRhoL*F/VR/(Rho(ix,iy,iz+1,1)+Eps)
          END IF
          AFall%Val(i,2)=AFall%Val(i,2)-F/VL/(Rho(ix,iy,iz+1,1)+Eps)
          AFall%Val(i,1)=AFall%Val(i,1)+F/VR/(Rho(ix,iy,iz+1,1)+Eps)
        END DO
      END DO
    END DO
  END IF

  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (JacTransportX) THEN
    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            RhoFine= &
               SUM(Rho(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* & 
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            RhoCoarse= &
               SUM(Rho(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            DO iz=jz,jz+IncrZ-1
              DO iy=jy,jy+IncrY-1
                VL=VolC(ix0,iy,iz)+Eps
                VR=VolC(ix0+1,iy,iz)+Eps
                F=FU(ix0,iy,iz)
!               uF > 0
                i=Index(ix0,iy,iz)
                AT%Val(i,3)=AT%Val(i,3)+Half*(ABS(uF(ix0,iy,iz))+uF(ix0,iy,iz)) &
                   *F/VR/(RhoCoarse+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix0,iy,iz))+uF(ix0,iy,iz)) &
                           *F/VL/(RhoCoarse+Eps)
!               uF < 0
                i=Index(ix0+1,iy,iz)
                AT%Val(i,5)=AT%Val(i,5)+Half*(ABS(uF(ix0,iy,iz))-uF(ix0,iy,iz)) &
                           *F/VL/(RhoFine+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix0,iy,iz))-uF(ix0,iy,iz)) &
                           *F/VR/(RhoFine+Eps)
              END DO
            END DO
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            VL=VolC(ix0,jy,jz)+Eps
            VR=VolC(ix0+1,jy,jz)+Eps
            F=FU(ix0,jy,jz)
!           uF > 0
            i=Index(ix0,jy,jz)
            AT%Val(i,3)=AT%Val(i,3)+Half*(ABS(uF(ix0,jy,jz))+uF(ix0,jy,jz)) &
                       *F/VR/(Rho(ix0,jy,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix0,jy,jz))+uF(ix0,jy,jz)) &
                       *F/VL/(Rho(ix0,jy,jz,1)+Eps)
!           uF < 0
            i=Index(ix0+1,jy,jz)
            AT%Val(i,5)=AT%Val(i,5)+Half*(ABS(uF(ix0,jy,jz))-uF(ix0,jy,jz)) &
                       *F/VL/(Rho(ix0+1,jy,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix0,jy,jz))-uF(ix0,jy,jz)) &
                       *F/VR/(Rho(ix0+1,jy,jz,1)+Eps)
          END DO
        END DO
      END IF
    ELSE IF (Nachbars(in)%nType=='ow') THEN
      DO jz=jz0+1,jz1
        DO jy=jy0+1,jy1
          VL=VolC(ix0,jy,jz)+Eps
          VR=VolC(ix0+1,jy,jz)+Eps
          F=FU(ix0,jy,jz)
!         uF > 0
!         i=Index(ix0,jy,jz)
!         AT%Val(i,3)=AT%Val(i,3)+Half*(ABS(uF(ix0,jy,jz))+uF(ix0,jy,jz)) &
!                    *F/VR/(Rho(ix0,jy,jz,1)+Eps)
!         AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix0,jy,jz))+uF(ix0,jy,jz)) &
!                    *F/VL/(Rho(ix0,jy,jz,1)+Eps)
!         uF < 0
          i=Index(ix0+1,jy,jz)
!         AT%Val(i,5)=AT%Val(i,5)+Half*(ABS(uF(ix0,jy,jz))-uF(ix0,jy,jz)) &
!                    *F/VL/(Rho(ix0+1,jy,jz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix0,jy,jz))-uF(ix0,jy,jz)) &
                     *F/VR/(Rho(ix0+1,jy,jz,1)+Eps)
        END DO
      END DO
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            RhoFine= &
               SUM(Rho(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* & 
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            RhoCoarse= &
               SUM(Rho(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            DO iz=jz,jz+IncrZ-1
              DO iy=jy,jy+IncrY-1
                VL=VolC(ix1,iy,iz)+Eps
                VR=VolC(ix1+1,iy,iz)+Eps
                F=FU(ix1,iy,iz)
!               uF > 0
                i=Index(ix1,iy,iz)
                AT%Val(i,3)=AT%Val(i,3)+Half*(ABS(uF(ix1,iy,iz))+uF(ix1,iy,iz)) &
                   *F/VR/(RhoFine+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix1,iy,iz))+uF(ix1,iy,iz)) &
                           *F/VL/(RhoFine+Eps)
!               uF < 0
                i=Index(ix1+1,iy,iz)
                AT%Val(i,5)=AT%Val(i,5)+Half*(ABS(uF(ix1,iy,iz))-uF(ix1,iy,iz)) &
                           *F/VL/(RhoCoarse+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix1,iy,iz))-uF(ix1,iy,iz)) &
                           *F/VR/(RhoCoarse+Eps)
              END DO
            END DO
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            VL=VolC(ix1,jy,jz)+Eps
            VR=VolC(ix1+1,jy,jz)+Eps
            F=FU(ix1,jy,jz)
!           uF > 0
            i=Index(ix1,jy,jz)
            AT%Val(i,3)=AT%Val(i,3)+Half*(ABS(uF(ix1,jy,jz))+uF(ix1,jy,jz)) &
                       *F/VR/(Rho(ix1,jy,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix1,jy,jz))+uF(ix1,jy,jz)) &
                       *F/VL/(Rho(ix1,jy,jz,1)+Eps)
!           uF < 0
            i=Index(ix1+1,jy,jz)
            AT%Val(i,5)=AT%Val(i,5)+Half*(ABS(uF(ix1,jy,jz))-uF(ix1,jy,jz)) &
                       *F/VL/(Rho(ix1+1,jy,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix1,jy,jz))-uF(ix1,jy,jz)) &
                       *F/VR/(Rho(ix1+1,jy,jz,1)+Eps)
          END DO
        END DO
      END IF
    ELSE IF (Nachbars(in)%nType=='oe') THEN
      DO jz=jz0+1,jz1
        DO jy=jy0+1,jy1
          VL=VolC(ix1,jy,jz)+Eps
          VR=VolC(ix1+1,jy,jz)+Eps
          F=FU(ix1,jy,jz)
!         uF > 0
          i=Index(ix1,jy,jz)
!         AT%Val(i,3)=AT%Val(i,3)+Half*(ABS(uF(ix1,jy,jz))+uF(ix1,jy,jz)) &
!                    *F/VR/(Rho(ix1,jy,jz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix1,jy,jz))+uF(ix1,jy,jz)) &
                     *F/VL/(Rho(ix1,jy,jz,1)+Eps)
!         uF < 0
!         i=Index(ix1+1,jy,jz)
!         AT%Val(i,5)=AT%Val(i,5)+Half*(ABS(uF(ix1,jy,jz))-uF(ix1,jy,jz)) &
!                    *F/VL/(Rho(ix1+1,jy,jz,1)+Eps)
!         AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(uF(ix1,jy,jz))-uF(ix1,jy,jz)) &
!                    *F/VR/(Rho(ix1+1,jy,jz,1)+Eps)
        END DO
      END DO
    END IF
    END IF
    IF (JacTransportY) THEN
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            RhoFine= &
               SUM(Rho(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            RhoCoarse= &
               SUM(Rho(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            DO iz=jz,jz+IncrZ-1
              DO ix=jx,jx+IncrX-1
                VL=VolC(ix,iy0,iz)+Eps
                VR=VolC(ix,iy0+1,iz)+Eps
                F=FV(ix,iy0,iz)
!               vF > 0
                i=Index(ix,iy0,iz)
                AT%Val(i,2)=AT%Val(i,2)+Half*(ABS(vF(ix,iy0,iz))+vF(ix,iy0,iz)) &
                           *F/VR/(RhoCoarse+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(ix,iy0,iz))+vF(ix,iy0,iz)) &
                           *F/VL/(RhoCoarse+Eps)
!               vF < 0
                i=Index(ix,iy0+1,iz)
                AT%Val(i,6)=AT%Val(i,6)+Half*(ABS(vF(ix,iy0,iz))-vF(ix,iy0,iz)) &
                           *F/VL/(RhoFine+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(ix,iy0,iz))-vF(ix,iy0,iz)) &
                           *F/VR/(RhoFine+Eps)
              END DO
            END DO
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            VL=VolC(jx,iy0,jz)+Eps
            VR=VolC(jx,iy0+1,jz)+Eps
            F=FV(jx,iy0,jz)
!           vF > 0
            i=Index(jx,iy0,jz)
            AT%Val(i,2)=AT%Val(i,2)+Half*(ABS(vF(jx,iy0,jz))+vF(jx,iy0,jz)) &
                       *F/VR/(Rho(jx,iy0,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy0,jz))+vF(jx,iy0,jz)) &
                       *F/VL/(Rho(jx,iy0,jz,1)+Eps)
!           vF < 0
            i=Index(jx,iy0+1,jz)
            AT%Val(i,6)=AT%Val(i,6)+Half*(ABS(vF(jx,iy0,jz))-vF(jx,iy0,jz)) &
                       *F/VL/(Rho(jx,iy0+1,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy0,jz))-vF(jx,iy0,jz)) &
                       *F/VR/(Rho(jx,iy0+1,jz,1)+Eps)
          END DO
        END DO
      END IF
    ELSE IF (Nachbars(in)%nType=='os') THEN
      DO jz=jz0+1,jz1
        DO jx=jx0+1,jx1
          VL=VolC(jx,iy0,jz)+Eps
          VR=VolC(jx,iy0+1,jz)+Eps
          F=FV(jx,iy0,jz)
!         vF > 0
!         i=Index(jx,iy0,jz)
!         AT%Val(i,2)=AT%Val(i,2)+Half*(ABS(vF(jx,iy0,jz))+vF(jx,iy0,jz)) &
!                    *F/VR/(Rho(jx,iy0,jz,1)+Eps)
!         AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy0,jz))+vF(jx,iy0,jz)) &
!                    *F/VL/(Rho(jx,iy0,jz,1)+Eps)
!         vF < 0
          i=Index(jx,iy0+1,jz)
!         AT%Val(i,6)=AT%Val(i,6)+Half*(ABS(vF(jx,iy0,jz))-vF(jx,iy0,jz)) &
!                    *F/VL/(Rho(jx,iy0+1,jz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy0,jz))-vF(jx,iy0,jz)) &
                     *F/VR/(Rho(jx,iy0+1,jz,1)+Eps)
        END DO
      END DO
    END IF

    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            RhoFine= &
               SUM(Rho(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            RhoCoarse= &
               SUM(Rho(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            DO iz=jz,jz+IncrZ-1
              DO ix=jx,jx+IncrX-1
                VL=VolC(ix,iy1,iz)+Eps
                VR=VolC(ix,iy1+1,iz)+Eps
                F=FV(ix,iy1,iz)
!               vF > 0
                i=Index(ix,iy1,iz)
                AT%Val(i,2)=AT%Val(i,2)+Half*(ABS(vF(ix,iy1,iz))+vF(ix,iy1,iz)) &
                           *F/VR/(RhoFine+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(ix,iy1,iz))+vF(ix,iy1,iz)) &
                           *F/VL/(RhoFine+Eps)
!               vF < 0
                i=Index(ix,iy1+1,iz)
                AT%Val(i,6)=AT%Val(i,6)+Half*(ABS(vF(ix,iy1,iz))-vF(ix,iy1,iz)) &
                           *F/VL/(RhoCoarse+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(ix,iy1,iz))-vF(ix,iy1,iz)) &
                           *F/VR/(RhoCoarse+Eps)
              END DO
            END DO
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            VL=VolC(jx,iy1,jz)+Eps
            VR=VolC(jx,iy1+1,jz)+Eps
            F=FV(jx,iy1,jz)
!           vF > 0
            i=Index(jx,iy1,jz)
            AT%Val(i,2)=AT%Val(i,2)+Half*(ABS(vF(jx,iy1,jz))+vF(jx,iy1,jz)) &
                       *F/VR/(Rho(jx,iy1,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy1,jz))+vF(jx,iy1,jz)) &
                       *F/VL/(Rho(jx,iy1,jz,1)+Eps)
!           vF < 0
            i=Index(jx,iy1+1,jz)
            AT%Val(i,6)=AT%Val(i,6)+Half*(ABS(vF(jx,iy1,jz))-vF(jx,iy1,jz)) &
                       *F/VL/(Rho(jx,iy1+1,jz,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy1,jz))-vF(jx,iy1,jz)) &
                       *F/VR/(Rho(jx,iy1+1,jz,1)+Eps)
          END DO
        END DO
      END IF
    ELSE IF (Nachbars(in)%nType=='on') THEN
      DO jz=jz0+1,jz1
        DO jx=jx0+1,jx1
          VL=VolC(jx,iy1,jz)+Eps
          VR=VolC(jx,iy1+1,jz)+Eps
          F=FV(jx,iy1,jz)
!           vF > 0
          i=Index(jx,iy1,jz)
!         AT%Val(i,2)=AT%Val(i,2)+Half*(ABS(vF(jx,iy1,jz))+vF(jx,iy1,jz)) &
!                    *F/VR/(Rho(jx,iy1,jz,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy1,jz))+vF(jx,iy1,jz)) &
                     *F/VL/(Rho(jx,iy1,jz,1)+Eps)
!           vF < 0
!         i=Index(jx,iy1+1,jz)
!         AT%Val(i,6)=AT%Val(i,6)+Half*(ABS(vF(jx,iy1,jz))-vF(jx,iy1,jz)) &
!                    *F/VL/(Rho(jx,iy1+1,jz,1)+Eps)
!         AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(vF(jx,iy1,jz))-vF(jx,iy1,jz)) &
!                    *F/VR/(Rho(jx,iy1+1,jz,1)+Eps)
        END DO
      END DO
    END IF
    END IF
    IF (JacTransportZ) THEN
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            RhoFine= &
               SUM(Rho(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            RhoCoarse= &
               SUM(Rho(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (VolCoarse+Eps)
            DO iy=jy,jy+IncrY-1
              DO ix=jx,jx+IncrX-1
                VL=VolC(ix,iy,iz0)+Eps
                VR=VolC(ix,iy,iz0+1)+Eps
                F=FW(ix,iy,iz0)
!               wF > 0
                i=Index(ix,iy,iz0)
                AT%Val(i,1)=AT%Val(i,1)+Half*(ABS(wF(ix,iy,iz0))+wF(ix,iy,iz0)) &
                           *F/VR/(RhoCoarse+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(ix,iy,iz0))+wF(ix,iy,iz0)) &
                           *F/VL/(RhoCoarse+Eps)
!               wF < 0
                i=Index(ix,iy,iz0+1)
                AT%Val(i,7)=AT%Val(i,7)+Half*(ABS(wF(ix,iy,iz0))-wF(ix,iy,iz0)) &
                           *F/VL/(RhoFine+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(ix,iy,iz0))-wF(ix,iy,iz0)) &
                           *F/VR/(RhoFine+Eps)
                IF (PRESENT(FallF)) THEN
                  RhoLF=CellToFaceVol(RhoR(ix,iy,iz0,1),RhoR(ix,iy,iz0+1,1) &
                                  ,VL,VR)
                  vFallRhoL=FallF(RhoLF)
                  AFallRhoL%Val(i,2)=AFallRhoL%Val(i,2)-vFallRhoL*F/VL/(RhoCoarse+Eps)
                  AFallRhoL%Val(i,1)=AFallRhoL%Val(i,1)+vFallRhoL*F/VR/(RhoCoarse+Eps)
                END IF
                AFall%Val(i,2)=AFall%Val(i,2)-F/VL/(RhoCoarse+Eps)
                AFall%Val(i,1)=AFall%Val(i,1)+F/VR/(RhoCoarse+Eps)
              END DO
            END DO
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            i=Index(jx,jy,iz0)
            VL=VolC(jx,jy,iz0)+Eps
            VR=VolC(jx,jy,iz0+1)+Eps
            F=FW(jx,jy,iz0)
!           wF > 0
            i=Index(jx,jy,iz0)
            AT%Val(i,1)=AT%Val(i,1)+Half*(ABS(wF(jx,jy,iz0))+wF(jx,jy,iz0)) &
                       *F/VR/(Rho(jx,jy,iz0,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz0))+wF(jx,jy,iz0)) &
                       *F/VL/(Rho(jx,jy,iz0,1)+Eps)
!           wF < 0
            i=Index(jx,jy,iz0+1)
            AT%Val(i,7)=AT%Val(i,7)+Half*(ABS(wF(jx,jy,iz0))-wF(jx,jy,iz0)) &
                       *F/VL/(Rho(jx,jy,iz0+1,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz0))-wF(jx,jy,iz0)) &
                       *F/VR/(Rho(jx,jy,iz0+1,1)+Eps)
            IF (PRESENT(FallF)) THEN 
              RhoLF=CellToFaceVol(RhoR(jx,jy,iz0,1),RhoR(jx,jy,iz0+1,1) &
                              ,VL,VR)
              vFallRhoL=FallF(RhoLF)
              AFallRhoL%Val(i,2)=AFallRhoL%Val(i,2)-vFallRhoL*F/VL/(Rho(jx,jy,iz0+1,1)+Eps)
              AFallRhoL%Val(i,1)=AFallRhoL%Val(i,1)+vFallRhoL*F/VR/(Rho(jx,jy,iz0+1,1)+Eps)
            END IF
            AFall%Val(i,2)=AFall%Val(i,2)-F/VL/(Rho(jx,jy,iz0+1,1)+Eps)
            AFall%Val(i,1)=AFall%Val(i,1)+F/VR/(Rho(jx,jy,iz0+1,1)+Eps)
          END DO
        END DO
      END IF
    ELSE IF (Nachbars(in)%nType=='ob') THEN
      DO jy=jy0+1,jy1
        DO jx=jx0+1,jx1
          i=Index(jx,jy,iz0)
          VL=VolC(jx,jy,iz0)+Eps
          VR=VolC(jx,jy,iz0+1)+Eps
          F=FW(jx,jy,iz0)
!         wF > 0
!         i=Index(jx,jy,iz0)
!         AT%Val(i,1)=AT%Val(i,1)+Half*(ABS(wF(jx,jy,iz0))+wF(jx,jy,iz0)) &
!                    *F/VR/(Rho(jx,jy,iz0,1)+Eps)
!         AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz0))+wF(jx,jy,iz0)) &
!                    *F/VL/(Rho(jx,jy,iz0,1)+Eps)
!         wF < 0
          i=Index(jx,jy,iz0+1)
!         AT%Val(i,7)=AT%Val(i,7)+Half*(ABS(wF(jx,jy,iz0))-wF(jx,jy,iz0)) &
!                    *F/VL/(Rho(jx,jy,iz0+1,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz0))-wF(jx,jy,iz0)) &
                     *F/VR/(Rho(jx,jy,iz0+1,1)+Eps)
          IF (PRESENT(FallF)) THEN 
            RhoLF=CellToFaceVol(RhoR(jx,jy,iz0,1),RhoR(jx,jy,iz0+1,1) &
                            ,VL,VR)
            vFallRhoL=FallF(RhoLF)
            AFallRhoL%Val(i,1)=AFallRhoL%Val(i,1)+vFallRhoL*F/VR/(Rho(jx,jy,iz0+1,1)+Eps)
          END IF
          AFall%Val(i,1)=AFall%Val(i,1)+F/VR/(Rho(jx,jy,iz0+1,1)+Eps)
        END DO
      END DO
    END IF

    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            RhoFine= &
               SUM(Rho(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            RhoCoarse= &
               SUM(Rho(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            DO iy=jy,jy+IncrY-1
              DO ix=jx,jx+IncrX-1
                i=Index(ix,iy,iz1)
                VL=VolC(ix,iy,iz1)+Eps
                VR=VolC(ix,iy,iz1+1)+Eps
                F=FW(ix,iy,iz1)
!               wF > 0
                i=Index(ix,iy,iz1)
                AT%Val(i,1)=AT%Val(i,1)+Half*(ABS(wF(ix,iy,iz1))+wF(ix,iy,iz1)) &
                           *F/VR/(RhoFine+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(ix,iy,iz1))+wF(ix,iy,iz1)) &
                           *F/VL/(RhoFine+Eps)
!               wF < 0
                i=Index(ix,iy,iz1+1)
                AT%Val(i,7)=AT%Val(i,7)+Half*(ABS(wF(ix,iy,iz1))-wF(ix,iy,iz1)) &
                           *F/VL/(RhoCoarse+Eps)
                AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(ix,iy,iz1))-wF(ix,iy,iz1)) &
                           *F/VR/(RhoCoarse+Eps)
                IF (PRESENT(FallF)) THEN
                  RhoLF=CellToFaceVol(RhoR(ix,iy,iz1,1),RhoR(ix,iy,iz1+1,1) &
                                  ,VL,VR)
                  vFallRhoL=FallF(RhoLF)
                  AFallRhoL%Val(i,2)=AFallRhoL%Val(i,2)-vFallRhoL*F/VL/(RhoFine+Eps)
                  AFallRhoL%Val(i,1)=AFallRhoL%Val(i,1)+vFallRhoL*F/VR/(RhoFine+Eps)
                END IF
                AFall%Val(i,2)=AFall%Val(i,2)-F/VL/(RhoFine+Eps)
                AFall%Val(i,1)=AFall%Val(i,1)+F/VR/(RhoFine+Eps)
              END DO
            END DO
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            i=Index(jx,jy,iz1)
            VL=VolC(jx,jy,iz1)+Eps
            VR=VolC(jx,jy,iz1+1)+Eps
            F=FW(jx,jy,iz1)
!           wF > 0
            i=Index(jx,jy,iz1)
            AT%Val(i,1)=AT%Val(i,1)+Half*(ABS(wF(jx,jy,iz1))+wF(jx,jy,iz1)) &
                       *F/VR/(Rho(jx,jy,iz1,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz1))+wF(jx,jy,iz1)) &
                       *F/VL/(Rho(jx,jy,iz1,1)+Eps)
!           wF < 0
            i=Index(jx,jy,iz1+1)
            AT%Val(i,7)=AT%Val(i,7)+Half*(ABS(wF(jx,jy,iz1))-wF(jx,jy,iz1)) &
                       *F/VL/(Rho(jx,jy,iz1+1,1)+Eps)
            AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz1))-wF(jx,jy,iz1)) &
                       *F/VR/(Rho(jx,jy,iz1+1,1)+Eps)
            IF (PRESENT(FallF)) THEN 
              RhoLF=CellToFaceVol(RhoR(jx,jy,iz1,1),RhoR(jx,jy,iz1+1,1) &
                              ,VL,VR)
              vFallRhoL=FallF(RhoLF)
              AFallRhoL%Val(i,2)=AFallRhoL%Val(i,2)-vFallRhoL*F/VL/(Rho(jx,jy,iz1+1,1)+Eps)
              AFallRhoL%Val(i,1)=AFallRhoL%Val(i,1)+vFallRhoL*F/VR/(Rho(jx,jy,iz1+1,1)+Eps)
            END IF
            AFall%Val(i,2)=AFall%Val(i,2)-F/VL/(Rho(jx,jy,iz1+1,1)+Eps)
            AFall%Val(i,1)=AFall%Val(i,1)+F/VR/(Rho(jx,jy,iz1+1,1)+Eps)
          END DO
        END DO
      END IF
    ELSE IF (Nachbars(in)%nType=='ot') THEN
      DO jy=jy0+1,jy1
        DO jx=jx0+1,jx1
          i=Index(jx,jy,iz1)
          VL=VolC(jx,jy,iz1)+Eps
          VR=VolC(jx,jy,iz1+1)+Eps
          F=FW(jx,jy,iz1)
!           wF > 0
          i=Index(jx,jy,iz1)
!         AT%Val(i,1)=AT%Val(i,1)+Half*(ABS(wF(jx,jy,iz1))+wF(jx,jy,iz1)) &
!                    *F/VR/(Rho(jx,jy,iz1,1)+Eps)
          AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz1))+wF(jx,jy,iz1)) &
                     *F/VL/(Rho(jx,jy,iz1,1)+Eps)
!           wF < 0
!         i=Index(jx,jy,iz1+1)
!         AT%Val(i,7)=AT%Val(i,7)+Half*(ABS(wF(jx,jy,iz1))-wF(jx,jy,iz1)) &
!                    *F/VL/(Rho(jx,jy,iz1+1,1)+Eps)
!         AT%Val(i,4)=AT%Val(i,4)-Half*(ABS(wF(jx,jy,iz1))-wF(jx,jy,iz1)) &
!                    *F/VR/(Rho(jx,jy,iz1+1,1)+Eps)
        END DO
      END DO
    END IF
    END IF
  END DO

CONTAINS
FUNCTION Index(ix,iy,iz)
  INTEGER :: Index,ix,iy,iz
  Index=ix-ix0+1+nxP2*(iy-iy0)+nxP2*nyP2*(iz-iz0)  
END FUNCTION Index
END SUBROUTINE JacAdvectionCompute

SUBROUTINE DiffusionCompute

  INTEGER :: ix,iy,iz,it
  REAL(RealKind) :: cL,cR
  REAL(RealKind) :: VL,VR
  REAL(RealKind) :: DL,DR
  REAL(RealKind) :: FF,DRhoF
  REAL(RealKind) :: Flux

  DO it=LBOUND(c,4),UBOUND(c,4)
! Fluxes
! x-Direction
  IF (TypeW(1:1)/='o') THEN
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        Flux=  &
             DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)-Flux
        f(ix  ,iy,iz,it)=f(ix  ,iy,iz,it)+Flux
      END DO
    END DO
  ELSE
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DH(ix+1,iy,iz,1)
        FF=FU(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL) 
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)-Flux
        f(ix  ,iy,iz,it)=f(ix  ,iy,iz,it)+Flux
      END DO
    END DO
  END DO
  IF (TypeE(1:1)/='o') THEN
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        Flux=  &
             DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix+1,iy,iz,it)=f(ix+1,iy,iz,it)-Flux
        f(ix  ,iy,iz,it)=f(ix  ,iy,iz,it)+Flux
      END DO
    END DO
  ELSE
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix+1,iy,iz,it)/(Rho(ix+1,iy,iz,1)+Eps)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DH(ix,iy,iz,1)
        FF=FU(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix  ,iy,iz,it)=f(ix  ,iy,iz,it)+Flux
      END DO
    END DO
  END IF

! y-Direction
  IF (TypeS(1:1)/='o') THEN
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        Flux=  &
             DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy+1,iz,it)=f(ix,iy+1,iz,it)-Flux
        f(ix,iy  ,iz,it)=f(ix,iy  ,iz,it)+Flux
      END DO
    END DO
  ELSE
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DH(ix,iy+1,iz,1)
        FF=FV(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy+1,iz,it)=f(ix,iy+1,iz,it)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy+1,iz,it)=f(ix,iy+1,iz,it)-Flux
        f(ix,iy  ,iz,it)=f(ix,iy  ,iz,it)+Flux
      END DO
   END DO
  END DO
  IF (TypeN(1:1)/='o') THEN
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        Flux=  &
             DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy+1,iz,it)=f(ix,iy+1,iz,it)-Flux
        f(ix,iy  ,iz,it)=f(ix,iy  ,iz,it)+Flux
      END DO
    END DO
  ELSE
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy+1,iz,it)/(Rho(ix,iy+1,iz,1)+Eps)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DH(ix,iy,iz,1)
        FF=FV(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy  ,iz,it)=f(ix,iy  ,iz,it)+Flux
      END DO
    END DO
  END IF
! z-Direction
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        Flux=  &
             DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy,iz+1,it)=f(ix,iy,iz+1,it)-Flux
        f(ix,iy,iz  ,it)=f(ix,iy,iz  ,it)+Flux
      END DO
    END DO
  ELSE
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DV(ix,iy,iz+1,1)
        FF=FW(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy,iz+1,it)=f(ix,iy,iz+1,it)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy,iz+1,it)=f(ix,iy,iz+1,it)-Flux
        f(ix,iy,iz  ,it)=f(ix,iy,iz  ,it)+Flux
      END DO
    END DO
  END DO
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        Flux=  &
             DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy,iz+1,it)=f(ix,iy,iz+1,it)-Flux
        f(ix,iy,iz  ,it)=f(ix,iy,iz  ,it)+Flux
      END DO
    END DO
  ELSE
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        cL=c(ix,iy,iz,it)/(Rho(ix,iy,iz,1)+Eps)
        VL=VolC(ix,iy,iz)
        cR=c(ix,iy,iz+1,it)/(Rho(ix,iy,iz+1,1)+Eps)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DV(ix,iy,iz,1)
        FF=FW(ix,iy,iz)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        f(ix,iy,iz  ,it)=f(ix,iy,iz  ,it)+Flux
      END DO
    END DO
  END IF

  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        f(ix,iy,iz,it)=f(ix,iy,iz,it)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
  END DO
END SUBROUTINE DiffusionCompute

SUBROUTINE DiffusionComputeU

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: cL,cR
  REAL(RealKind) :: VL,VR
  REAL(RealKind) :: DL,DR
  REAL(RealKind) :: FF,DRhoF
  REAL(RealKind) :: Flux,FluxCr
  REAL(RealKind) :: GradL,GradR

! Fluxes
! x-Direction
  IF (TypeW(1:1)/='o') THEN
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        FF=FU(ix,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)-Flux
        uRhsL(ix  ,iy,iz,1)=uRhsL(ix  ,iy,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsR(ix+1,iy,iz,1)=uRhsR(ix+1,iy,iz,1)-Flux
        uRhsR(ix  ,iy,iz,1)=uRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  ELSE
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DH(ix+1,iy,iz,1)
        FF=FU(ix,iy,iz)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)-Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsR(ix+1,iy,iz,1)=uRhsR(ix+1,iy,iz,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL) 
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)-Flux
        uRhsL(ix  ,iy,iz,1)=uRhsL(ix  ,iy,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL) 
        uRhsR(ix+1,iy,iz,1)=uRhsR(ix+1,iy,iz,1)-Flux
        uRhsR(ix  ,iy,iz,1)=uRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeE(1:1)/='o') THEN
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)-Flux
        uRhsL(ix  ,iy,iz,1)=uRhsL(ix  ,iy,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsR(ix+1,iy,iz,1)=uRhsR(ix+1,iy,iz,1)-Flux
        uRhsR(ix  ,iy,iz,1)=uRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  ELSE
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DH(ix,iy,iz,1)
        FF=FU(ix,iy,iz)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsL(ix  ,iy,iz,1)=uRhsL(ix  ,iy,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        uRhsR(ix  ,iy,iz,1)=uRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  END IF

! y-Direction
  IF (TypeS(1:1)/='o') THEN
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((vCL(ix-1,iy+1,iz,1)+vCR(ix-1,iy+1,iz,1))/(Rho(ix-1,iy+1,iz,1)+Eps) &
                            ,(vCL(ix  ,iy+1,iz,1)+vCR(ix  ,iy+1,iz,1))/(Rho(ix  ,iy+1,iz,1)+Eps) &
                            ,(vCL(ix+1,iy+1,iz,1)+vCR(ix+1,iy+1,iz,1))/(Rho(ix+1,iy+1,iz,1)+Eps) &
                             ,FU(ix-1,iy+1,iz),FU(ix,iy+1,iz)          & 
                             ,VolC(ix-1,iy+1,iz),VolC(ix,iy+1,iz),VolC(ix+1,iy+1,iz)) 
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy+1,iz,1)=uRhsL(ix,iy+1,iz,1)-Flux
        uRhsL(ix,iy  ,iz,1)=uRhsL(ix,iy  ,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy+1,iz,1)=uRhsR(ix,iy+1,iz,1)-Flux
        uRhsR(ix,iy  ,iz,1)=uRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DH(ix,iy+1,iz,1)
        FF=FV(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((vCL(ix-1,iy+1,iz,1)+vCR(ix-1,iy+1,iz,1))/(Rho(ix-1,iy+1,iz,1)+Eps) &
                            ,(vCL(ix  ,iy+1,iz,1)+vCR(ix  ,iy+1,iz,1))/(Rho(ix  ,iy+1,iz,1)+Eps) &
                            ,(vCL(ix+1,iy+1,iz,1)+vCR(ix+1,iy+1,iz,1))/(Rho(ix+1,iy+1,iz,1)+Eps) &
                             ,FU(ix-1,iy+1,iz),FU(ix,iy+1,iz)          &
                             ,VolC(ix-1,iy+1,iz),VolC(ix,iy+1,iz),VolC(ix+1,iy+1,iz))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy+1,iz,1)=uRhsL(ix,iy+1,iz,1)-Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy+1,iz,1)=uRhsR(ix,iy+1,iz,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        GradL=Zero
        GradL=Half*GradCentr((vCL(ix-1,iy,iz,1)+vCR(ix-1,iy,iz,1))/(Rho(ix-1,iy,iz,1)+Eps) &
                            ,(vCL(ix  ,iy,iz,1)+vCR(ix  ,iy,iz,1))/(Rho(ix  ,iy,iz,1)+Eps) &
                            ,(vCL(ix+1,iy,iz,1)+vCR(ix+1,iy,iz,1))/(Rho(ix+1,iy,iz,1)+Eps) &
                             ,FU(ix-1,iy,iz),FU(ix,iy,iz)          &
                             ,VolC(ix-1,iy,iz),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        GradR=Half*GradCentr((vCL(ix-1,iy+1,iz,1)+vCR(ix-1,iy+1,iz,1))/(Rho(ix-1,iy+1,iz,1)+Eps) &
                            ,(vCL(ix  ,iy+1,iz,1)+vCR(ix  ,iy+1,iz,1))/(Rho(ix  ,iy+1,iz,1)+Eps) &
                            ,(vCL(ix+1,iy+1,iz,1)+vCR(ix+1,iy+1,iz,1))/(Rho(ix+1,iy+1,iz,1)+Eps) &
                             ,FU(ix-1,iy+1,iz),FU(ix,iy+1,iz)          &
                             ,VolC(ix-1,iy+1,iz),VolC(ix,iy+1,iz),VolC(ix+1,iy+1,iz))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy+1,iz,1)=uRhsL(ix,iy+1,iz,1)-Flux
        uRhsL(ix,iy  ,iz,1)=uRhsL(ix,iy  ,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy+1,iz,1)=uRhsR(ix,iy+1,iz,1)-Flux
        uRhsR(ix,iy  ,iz,1)=uRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeN(1:1)/='o') THEN
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        GradL=Zero
        GradL=Half*GradCentr((vCL(ix-1,iy,iz,1)+vCR(ix-1,iy,iz,1))/(Rho(ix-1,iy,iz,1)+Eps) &
                            ,(vCL(ix  ,iy,iz,1)+vCR(ix  ,iy,iz,1))/(Rho(ix  ,iy,iz,1)+Eps) &
                            ,(vCL(ix+1,iy,iz,1)+vCR(ix+1,iy,iz,1))/(Rho(ix+1,iy,iz,1)+Eps) &
                             ,FU(ix-1,iy,iz),FU(ix,iy,iz)          &
                             ,VolC(ix-1,iy,iz),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy+1,iz,1)=uRhsL(ix,iy+1,iz,1)-Flux
        uRhsL(ix,iy  ,iz,1)=uRhsL(ix,iy  ,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy+1,iz,1)=uRhsR(ix,iy+1,iz,1)-Flux
        uRhsR(ix,iy  ,iz,1)=uRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DH(ix,iy,iz,1)
        FF=FV(ix,iy,iz)
        GradL=Zero
        GradL=Half*GradCentr((vCL(ix-1,iy,iz,1)+vCR(ix-1,iy,iz,1))/(Rho(ix-1,iy,iz,1)+Eps) &
                            ,(vCL(ix  ,iy,iz,1)+vCR(ix  ,iy,iz,1))/(Rho(ix  ,iy,iz,1)+Eps) &
                            ,(vCL(ix+1,iy,iz,1)+vCR(ix+1,iy,iz,1))/(Rho(ix+1,iy,iz,1)+Eps) &
                             ,FU(ix-1,iy,iz),FU(ix,iy,iz)          &
                             ,VolC(ix-1,iy,iz),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy  ,iz,1)=uRhsL(ix,iy  ,iz,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy  ,iz,1)=uRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END IF
! z-Direction
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR) 
        FF=FW(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((wCL(ix-1,iy,iz+1,1)+wCR(ix-1,iy,iz+1,1))/(Rho(ix-1,iy,iz+1,1)+Eps) &
                            ,(wCL(ix  ,iy,iz+1,1)+wCR(ix  ,iy,iz+1,1))/(Rho(ix  ,iy,iz+1,1)+Eps) &
                            ,(wCL(ix+1,iy,iz+1,1)+wCR(ix+1,iy,iz+1,1))/(Rho(ix+1,iy,iz+1,1)+Eps) &
                             ,FU(ix-1,iy,iz+1),FU(ix,iy,iz+1)          &
                             ,VolC(ix-1,iy,iz+1),VolC(ix,iy,iz+1),VolC(ix+1,iy,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy,iz+1,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy,iz+1,1)=uRhsL(ix,iy,iz+1,1)-Flux
        uRhsL(ix,iy,iz  ,1)=uRhsL(ix,iy,iz  ,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy,iz+1,1)=uRhsR(ix,iy,iz+1,1)-Flux
        uRhsR(ix,iy,iz  ,1)=uRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  ELSE
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DV(ix,iy,iz+1,1)  
        FF=FW(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((wCL(ix-1,iy,iz+1,1)+wCR(ix-1,iy,iz+1,1))/(Rho(ix-1,iy,iz+1,1)+Eps) &
                            ,(wCL(ix  ,iy,iz+1,1)+wCR(ix  ,iy,iz+1,1))/(Rho(ix  ,iy,iz+1,1)+Eps) &
                            ,(wCL(ix+1,iy,iz+1,1)+wCR(ix+1,iy,iz+1,1))/(Rho(ix+1,iy,iz+1,1)+Eps) &
                             ,FU(ix-1,iy,iz+1),FU(ix,iy,iz+1)          &
                             ,VolC(ix-1,iy,iz+1),VolC(ix,iy,iz+1),VolC(ix+1,iy,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy,iz+1,1)=uRhsL(ix,iy,iz+1,1)-Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy,iz+1,1)=uRhsR(ix,iy,iz+1,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR) 
        FF=FW(ix,iy,iz)
        GradL=Half*GradCentr((wCL(ix-1,iy,iz,1)+wCR(ix-1,iy,iz,1))/(Rho(ix-1,iy,iz,1)+Eps) &
                            ,(wCL(ix  ,iy,iz,1)+wCR(ix  ,iy,iz,1))/(Rho(ix  ,iy,iz,1)+Eps) &
                            ,(wCL(ix+1,iy,iz,1)+wCR(ix+1,iy,iz,1))/(Rho(ix+1,iy,iz,1)+Eps) &
                             ,FU(ix-1,iy,iz),FU(ix,iy,iz)          &
                             ,VolC(ix-1,iy,iz),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        GradR=Half*GradCentr((wCL(ix-1,iy,iz+1,1)+wCR(ix-1,iy,iz+1,1))/(Rho(ix-1,iy,iz+1,1)+Eps) &
                            ,(wCL(ix  ,iy,iz+1,1)+wCR(ix  ,iy,iz+1,1))/(Rho(ix  ,iy,iz+1,1)+Eps) &
                            ,(wCL(ix+1,iy,iz+1,1)+wCR(ix+1,iy,iz+1,1))/(Rho(ix+1,iy,iz+1,1)+Eps) &
                             ,FU(ix-1,iy,iz+1),FU(ix,iy,iz+1)          &
                             ,VolC(ix-1,iy,iz+1),VolC(ix,iy,iz+1),VolC(ix+1,iy,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy,iz+1,1)=uRhsL(ix,iy,iz+1,1)-Flux
        uRhsL(ix,iy,iz  ,1)=uRhsL(ix,iy,iz  ,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy,iz+1,1)=uRhsR(ix,iy,iz+1,1)-Flux
        uRhsR(ix,iy,iz  ,1)=uRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)  
        FF=FW(ix,iy,iz)
        GradL=Half*GradCentr((wCL(ix-1,iy,iz,1)+wCR(ix-1,iy,iz,1))/(Rho(ix-1,iy,iz,1)+Eps) &
                            ,(wCL(ix  ,iy,iz,1)+wCR(ix  ,iy,iz,1))/(Rho(ix  ,iy,iz,1)+Eps) &
                            ,(wCL(ix+1,iy,iz,1)+wCR(ix+1,iy,iz,1))/(Rho(ix+1,iy,iz,1)+Eps) &
                             ,FU(ix-1,iy,iz),FU(ix,iy,iz)          &
                             ,VolC(ix-1,iy,iz),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy,iz+1,1)=uRhsL(ix,iy,iz+1,1)-Flux
        uRhsL(ix,iy,iz  ,1)=uRhsL(ix,iy,iz  ,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy,iz+1,1)=uRhsR(ix,iy,iz+1,1)-Flux
        uRhsR(ix,iy,iz  ,1)=uRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  ELSE
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DV(ix,iy,iz,1) 
        FF=FW(ix,iy,iz)
        GradL=Half*GradCentr((wCL(ix-1,iy,iz,1)+wCR(ix-1,iy,iz,1))/(Rho(ix-1,iy,iz,1)+Eps) &
                            ,(wCL(ix  ,iy,iz,1)+wCR(ix  ,iy,iz,1))/(Rho(ix  ,iy,iz,1)+Eps) &
                            ,(wCL(ix+1,iy,iz,1)+wCR(ix+1,iy,iz,1))/(Rho(ix+1,iy,iz,1)+Eps) &
                             ,FU(ix-1,iy,iz),FU(ix,iy,iz)          &
                             ,VolC(ix-1,iy,iz),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=ucL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsL(ix,iy,iz  ,1)=uRhsL(ix,iy,iz  ,1)+Flux
        cL=ucR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=ucR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        uRhsR(ix,iy,iz  ,1)=uRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  END IF

  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
END SUBROUTINE DiffusionComputeU

SUBROUTINE DiffusionComputeV

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: cL,cR
  REAL(RealKind) :: VL,VR
  REAL(RealKind) :: DL,DR
  REAL(RealKind) :: FF,DRhoF
  REAL(RealKind) :: Flux,FluxCr
  REAL(RealKind) :: GradL,GradR

! Fluxes
! x-Direction
  IF (TypeW(1:1)/='o') THEN
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((uCL(ix+1,iy-1,iz,1)+uCR(ix+1,iy-1,iz,1))/(Rho(ix+1,iy-1,iz,1)+Eps) &
                            ,(uCL(ix+1,iy  ,iz,1)+uCR(ix+1,iy  ,iz,1))/(Rho(ix+1,iy  ,iz,1)+Eps) &
                            ,(uCL(ix+1,iy+1,iz,1)+uCR(ix+1,iy+1,iz,1))/(Rho(ix+1,iy+1,iz,1)+Eps) &
                             ,FV(ix+1,iy-1,iz),FV(ix+1,iy,iz)          &
                             ,VolC(ix+1,iy-1,iz),VolC(ix+1,iy,iz),VolC(ix+1,iy+1,iz))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix+1,iy,iz,1)=vRhsL(ix+1,iy,iz,1)-Flux
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix+1,iy,iz,1)=vRhsR(ix+1,iy,iz,1)-Flux
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DH(ix+1,iy,iz,1)
        FF=FU(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((uCL(ix+1,iy-1,iz,1)+uCR(ix+1,iy-1,iz,1))/(Rho(ix+1,iy-1,iz,1)+Eps) &
                            ,(uCL(ix+1,iy  ,iz,1)+uCR(ix+1,iy  ,iz,1))/(Rho(ix+1,iy  ,iz,1)+Eps) &
                            ,(uCL(ix+1,iy+1,iz,1)+uCR(ix+1,iy+1,iz,1))/(Rho(ix+1,iy+1,iz,1)+Eps) &
                             ,FV(ix+1,iy-1,iz),FV(ix+1,iy,iz)          &
                             ,VolC(ix+1,iy-1,iz),VolC(ix+1,iy,iz),VolC(ix+1,iy+1,iz))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix+1,iy,iz,1)=vRhsL(ix+1,iy,iz,1)-Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix+1,iy,iz,1)=vRhsR(ix+1,iy,iz,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        GradL=Half*GradCentr((uCL(ix,iy-1,iz,1)+uCR(ix,iy-1,iz,1))/(Rho(ix,iy-1,iz,1)+Eps) &
                            ,(uCL(ix,iy  ,iz,1)+uCR(ix,iy  ,iz,1))/(Rho(ix,iy  ,iz,1)+Eps) &
                            ,(uCL(ix,iy+1,iz,1)+uCR(ix,iy+1,iz,1))/(Rho(ix,iy+1,iz,1)+Eps) &
                             ,FV(ix,iy-1,iz),FV(ix,iy,iz)          &
                             ,VolC(ix,iy-1,iz),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        GradR=Half*GradCentr((uCL(ix+1,iy-1,iz,1)+uCR(ix+1,iy-1,iz,1))/(Rho(ix+1,iy-1,iz,1)+Eps) &
                            ,(uCL(ix+1,iy  ,iz,1)+uCR(ix+1,iy  ,iz,1))/(Rho(ix+1,iy  ,iz,1)+Eps) &
                            ,(uCL(ix+1,iy+1,iz,1)+uCR(ix+1,iy+1,iz,1))/(Rho(ix+1,iy+1,iz,1)+Eps) &
                             ,FV(ix+1,iy-1,iz),FV(ix+1,iy,iz)          &
                             ,VolC(ix+1,iy-1,iz),VolC(ix+1,iy,iz),VolC(ix+1,iy+1,iz))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix+1,iy,iz,1)=vRhsL(ix+1,iy,iz,1)-Flux
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix+1,iy,iz,1)=vRhsR(ix+1,iy,iz,1)-Flux
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeE(1:1)/='o') THEN
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        GradL=Half*GradCentr((uCL(ix,iy-1,iz,1)+uCR(ix,iy-1,iz,1))/(Rho(ix,iy-1,iz,1)+Eps) &
                            ,(uCL(ix,iy  ,iz,1)+uCR(ix,iy  ,iz,1))/(Rho(ix,iy  ,iz,1)+Eps) &
                            ,(uCL(ix,iy+1,iz,1)+uCR(ix,iy+1,iz,1))/(Rho(ix,iy+1,iz,1)+Eps) &
                             ,FV(ix,iy-1,iz),FV(ix,iy,iz)          &
                             ,VolC(ix,iy-1,iz),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix+1,iy,iz,1)=vRhsL(ix+1,iy,iz,1)-Flux
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix+1,iy,iz,1)=vRhsR(ix+1,iy,iz,1)-Flux
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DH(ix,iy,iz,1)
        FF=FU(ix,iy,iz)
        GradL=Half*GradCentr((uCL(ix,iy-1,iz,1)+uCR(ix,iy-1,iz,1))/(Rho(ix,iy-1,iz,1)+Eps) &
                            ,(uCL(ix,iy  ,iz,1)+uCR(ix,iy  ,iz,1))/(Rho(ix,iy  ,iz,1)+Eps) &
                            ,(uCL(ix,iy+1,iz,1)+uCR(ix,iy+1,iz,1))/(Rho(ix,iy+1,iz,1)+Eps) &
                             ,FV(ix,iy-1,iz),FV(ix,iy,iz)          &
                             ,VolC(ix,iy-1,iz),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END IF

! y-Direction
  IF (TypeS(1:1)/='o') THEN
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)-Flux
        vRhsL(ix,iy  ,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsR(ix,iy+1,iz,1)=vRhsR(ix,iy+1,iz,1)-Flux
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DH(ix,iy+1,iz,1)
        FF=FV(ix,iy,iz)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)-Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsR(ix,iy+1,iz,1)=vRhsR(ix,iy+1,iz,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)-Flux
        vRhsL(ix,iy  ,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsR(ix,iy+1,iz,1)=vRhsR(ix,iy+1,iz,1)-Flux
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeN(1:1)/='o') THEN
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)-Flux
        vRhsL(ix,iy  ,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsR(ix,iy+1,iz,1)=vRhsR(ix,iy+1,iz,1)-Flux
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DH(ix,iy,iz,1)
        FF=FV(ix,iy,iz)
        cL=vcL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsL(ix,iy  ,iz,1)=vRhsL(ix,iy  ,iz,1)+Flux
        cL=vcR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vcR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        vRhsR(ix,iy  ,iz,1)=vRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END IF
! z-Direction
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        FF=FW(ix,iy,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR) 
        GradL=Zero
        GradR=Half*GradCentr((wCL(ix,iy-1,iz+1,1)+wCR(ix,iy-1,iz+1,1))/(Rho(ix,iy-1,iz+1,1)+Eps) &
                            ,(wCL(ix,iy  ,iz+1,1)+wCR(ix,iy  ,iz+1,1))/(Rho(ix,iy  ,iz+1,1)+Eps) &
                            ,(wCL(ix,iy+1,iz+1,1)+wCR(ix,iy+1,iz+1,1))/(Rho(ix,iy+1,iz+1,1)+Eps) &
                            ,FV(ix,iy-1,iz+1),FV(ix,iy,iz+1)          & 
                            ,VolC(ix,iy-1,iz+1),VolC(ix,iy,iz+1),VolC(ix,iy+1,iz+1)) 
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr) 
        vRhsL(ix,iy,iz+1,1)=vRhsL(ix,iy,iz+1,1)-Flux
        vRhsL(ix,iy,iz  ,1)=vRhsL(ix,iy,iz  ,1)+Flux
        cL=vCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr) 
        vRhsR(ix,iy,iz+1,1)=vRhsR(ix,iy,iz+1,1)-Flux
        vRhsR(ix,iy,iz  ,1)=vRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  ELSE
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        FF=FW(ix,iy,iz)
        DRhoF=DV(ix,iy,iz+1,1) 
        GradL=Zero
        GradR=Half*GradCentr((wCL(ix,iy-1,iz+1,1)+wCR(ix,iy-1,iz+1,1))/(Rho(ix,iy-1,iz+1,1)+Eps) &
                            ,(wCL(ix,iy  ,iz+1,1)+wCR(ix,iy  ,iz+1,1))/(Rho(ix,iy  ,iz+1,1)+Eps) &
                            ,(wCL(ix,iy+1,iz+1,1)+wCR(ix,iy+1,iz+1,1))/(Rho(ix,iy+1,iz+1,1)+Eps) &
                            ,FV(ix,iy-1,iz+1),FV(ix,iy,iz+1)          &
                            ,VolC(ix,iy-1,iz+1),VolC(ix,iy,iz+1),VolC(ix,iy+1,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix,iy,iz+1,1)=vRhsL(ix,iy,iz+1,1)-Flux
        cL=vCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix,iy,iz+1,1)=vRhsR(ix,iy,iz+1,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        FF=FW(ix,iy,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)  
        GradL=Half*GradCentr((wCL(ix,iy-1,iz,1)+wCR(ix,iy-1,iz,1))/(Rho(ix,iy-1,iz,1)+Eps) &
                            ,(wCL(ix,iy  ,iz,1)+wCR(ix,iy  ,iz,1))/(Rho(ix,iy  ,iz,1)+Eps) &
                            ,(wCL(ix,iy+1,iz,1)+wCR(ix,iy+1,iz,1))/(Rho(ix,iy+1,iz,1)+Eps) &
                            ,FV(ix,iy-1,iz),FV(ix,iy,iz)          &
                            ,VolC(ix,iy-1,iz),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        GradR=Half*GradCentr((wCL(ix,iy-1,iz+1,1)+wCR(ix,iy-1,iz+1,1))/(Rho(ix,iy-1,iz+1,1)+Eps) &
                            ,(wCL(ix,iy  ,iz+1,1)+wCR(ix,iy  ,iz+1,1))/(Rho(ix,iy  ,iz+1,1)+Eps) &
                            ,(wCL(ix,iy+1,iz+1,1)+wCR(ix,iy+1,iz+1,1))/(Rho(ix,iy+1,iz+1,1)+Eps) &
                            ,FV(ix,iy-1,iz+1),FV(ix,iy,iz+1)          &
                            ,VolC(ix,iy-1,iz+1),VolC(ix,iy,iz+1),VolC(ix,iy+1,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix,iy,iz+1,1)=vRhsL(ix,iy,iz+1,1)-Flux
        vRhsL(ix,iy,iz  ,1)=vRhsL(ix,iy,iz  ,1)+Flux
        cL=vCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix,iy,iz+1,1)=vRhsR(ix,iy,iz+1,1)-Flux
        vRhsR(ix,iy,iz  ,1)=vRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        FF=FW(ix,iy,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR) 
        GradL=Half*GradCentr((wCL(ix,iy-1,iz,1)+wCR(ix,iy-1,iz,1))/(Rho(ix,iy-1,iz,1)+Eps) &
                            ,(wCL(ix,iy  ,iz,1)+wCR(ix,iy  ,iz,1))/(Rho(ix,iy  ,iz,1)+Eps) &
                            ,(wCL(ix,iy+1,iz,1)+wCR(ix,iy+1,iz,1))/(Rho(ix,iy+1,iz,1)+Eps) &
                            ,FV(ix,iy-1,iz),FV(ix,iy,iz)          &
                            ,VolC(ix,iy-1,iz),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix,iy,iz+1,1)=vRhsL(ix,iy,iz+1,1)-Flux
        vRhsL(ix,iy,iz  ,1)=vRhsL(ix,iy,iz  ,1)+Flux
        cL=vCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix,iy,iz+1,1)=vRhsR(ix,iy,iz+1,1)-Flux
        vRhsR(ix,iy,iz  ,1)=vRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  ELSE
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        FF=FW(ix,iy,iz)
        DRhoF=DV(ix,iy,iz,1) 
        GradL=Half*GradCentr((wCL(ix,iy-1,iz,1)+wCR(ix,iy-1,iz,1))/(Rho(ix,iy-1,iz,1)+Eps) &
                            ,(wCL(ix,iy  ,iz,1)+wCR(ix,iy  ,iz,1))/(Rho(ix,iy  ,iz,1)+Eps) &
                            ,(wCL(ix,iy+1,iz,1)+wCR(ix,iy+1,iz,1))/(Rho(ix,iy+1,iz,1)+Eps) &
                            ,FV(ix,iy-1,iz),FV(ix,iy,iz)          &
                            ,VolC(ix,iy-1,iz),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=vCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsL(ix,iy,iz  ,1)=vRhsL(ix,iy,iz  ,1)+Flux
        cL=vCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=vCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        vRhsR(ix,iy,iz  ,1)=vRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  END IF

  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
END SUBROUTINE DiffusionComputeV

SUBROUTINE DiffusionComputeW

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: cL,cR
  REAL(RealKind) :: VL,VR
  REAL(RealKind) :: DL,DR
  REAL(RealKind) :: FF,DRhoF
  REAL(RealKind) :: Flux,FluxCr
  REAL(RealKind) :: GradL,GradR

! Fluxes
! x-Direction
  IF (TypeW(1:1)/='o') THEN
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((uCL(ix+1,iy,iz-1,1)+uCR(ix+1,iy,iz-1,1))/(Rho(ix+1,iy,iz-1,1)+Eps) &
                            ,(uCL(ix+1,iy,iz  ,1)+uCR(ix+1,iy,iz  ,1))/(Rho(ix+1,iy,iz  ,1)+Eps) &
                            ,(uCL(ix+1,iy,iz+1,1)+uCR(ix+1,iy,iz+1,1))/(Rho(ix+1,iy,iz+1,1)+Eps) &
                            ,FW(ix+1,iy,iz-1),FW(ix+1,iy,iz)          & 
                            ,VolC(ix+1,iy,iz-1),VolC(ix+1,iy,iz),VolC(ix+1,iy,iz+1)) 
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr) 
        wRhsL(ix+1,iy,iz,1)=wRhsL(ix+1,iy,iz,1)-Flux
        wRhsL(ix  ,iy,iz,1)=wRhsL(ix  ,iy,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr) 
        wRhsR(ix+1,iy,iz,1)=wRhsR(ix+1,iy,iz,1)-Flux
        wRhsR(ix  ,iy,iz,1)=wRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  ELSE
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DV(ix+1,iy,iz,1)
        FF=FU(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((uCL(ix+1,iy,iz-1,1)+uCR(ix+1,iy,iz-1,1))/(Rho(ix+1,iy,iz-1,1)+Eps) &
                            ,(uCL(ix+1,iy,iz  ,1)+uCR(ix+1,iy,iz  ,1))/(Rho(ix+1,iy,iz  ,1)+Eps) &
                            ,(uCL(ix+1,iy,iz+1,1)+uCR(ix+1,iy,iz+1,1))/(Rho(ix+1,iy,iz+1,1)+Eps) &
                            ,FW(ix+1,iy,iz-1),FW(ix+1,iy,iz)          &
                            ,VolC(ix+1,iy,iz-1),VolC(ix+1,iy,iz),VolC(ix+1,iy,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix+1,iy,iz,1)=wRhsL(ix+1,iy,iz,1)-Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix+1,iy,iz,1)=wRhsR(ix+1,iy,iz,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        GradL=Half*GradCentr((uCL(ix,iy,iz-1,1)+uCR(ix,iy,iz-1,1))/(Rho(ix,iy,iz-1,1)+Eps) &
                            ,(uCL(ix,iy,iz  ,1)+uCR(ix,iy,iz  ,1))/(Rho(ix,iy,iz  ,1)+Eps) &
                            ,(uCL(ix,iy,iz+1,1)+uCR(ix,iy,iz+1,1))/(Rho(ix,iy,iz+1,1)+Eps) &
                            ,FW(ix,iy,iz-1),FW(ix,iy,iz)          &
                            ,VolC(ix,iy,iz-1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        GradR=Half*GradCentr((uCL(ix+1,iy,iz-1,1)+uCR(ix+1,iy,iz-1,1))/(Rho(ix+1,iy,iz-1,1)+Eps) &
                            ,(uCL(ix+1,iy,iz  ,1)+uCR(ix+1,iy,iz  ,1))/(Rho(ix+1,iy,iz  ,1)+Eps) &
                            ,(uCL(ix+1,iy,iz+1,1)+uCR(ix+1,iy,iz+1,1))/(Rho(ix+1,iy,iz+1,1)+Eps) &
                            ,FW(ix+1,iy,iz-1),FW(ix+1,iy,iz)          &
                            ,VolC(ix+1,iy,iz-1),VolC(ix+1,iy,iz),VolC(ix+1,iy,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix+1,iy,iz,1)=wRhsL(ix+1,iy,iz,1)-Flux
        wRhsL(ix  ,iy,iz,1)=wRhsL(ix  ,iy,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix+1,iy,iz,1)=wRhsR(ix+1,iy,iz,1)-Flux
        wRhsR(ix  ,iy,iz,1)=wRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeE(1:1)/='o') THEN
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        GradL=Half*GradCentr((uCL(ix,iy,iz-1,1)+uCR(ix,iy,iz-1,1))/(Rho(ix,iy,iz-1,1)+Eps) &
                            ,(uCL(ix,iy,iz  ,1)+uCR(ix,iy,iz  ,1))/(Rho(ix,iy,iz  ,1)+Eps) &
                            ,(uCL(ix,iy,iz+1,1)+uCR(ix,iy,iz+1,1))/(Rho(ix,iy,iz+1,1)+Eps) &
                            ,FW(ix,iy,iz-1),FW(ix,iy,iz)          &
                            ,VolC(ix,iy,iz-1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix+1,iy,iz,1)=wRhsL(ix+1,iy,iz,1)-Flux
        wRhsL(ix  ,iy,iz,1)=wRhsL(ix  ,iy,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix+1,iy,iz,1)=wRhsR(ix+1,iy,iz,1)-Flux
        wRhsR(ix  ,iy,iz,1)=wRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  ELSE
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DV(ix,iy,iz,1)
        FF=FU(ix,iy,iz)
        GradL=Half*GradCentr((uCL(ix,iy,iz-1,1)+uCR(ix,iy,iz-1,1))/(Rho(ix,iy,iz-1,1)+Eps) &
                            ,(uCL(ix,iy,iz  ,1)+uCR(ix,iy,iz  ,1))/(Rho(ix,iy,iz  ,1)+Eps) &
                            ,(uCL(ix,iy,iz+1,1)+uCR(ix,iy,iz+1,1))/(Rho(ix,iy,iz+1,1)+Eps) &
                            ,FW(ix,iy,iz-1),FW(ix,iy,iz)          &
                            ,VolC(ix,iy,iz-1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix  ,iy,iz,1)=wRhsL(ix  ,iy,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix+1,iy,iz,1)/(Rho(ix+1,iy,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix  ,iy,iz,1)=wRhsR(ix  ,iy,iz,1)+Flux
      END DO
    END DO
  END IF

! y-Direction
  IF (TypeS(1:1)/='o') THEN
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((vCL(ix,iy+1,iz-1,1)+vCR(ix,iy+1,iz-1,1))/(Rho(ix,iy+1,iz-1,1)+Eps) &
                            ,(vCL(ix,iy+1,iz  ,1)+vCR(ix,iy+1,iz  ,1))/(Rho(ix,iy+1,iz  ,1)+Eps) &
                            ,(vCL(ix,iy+1,iz+1,1)+vCR(ix,iy+1,iz+1,1))/(Rho(ix,iy+1,iz+1,1)+Eps) &
                            ,FW(ix,iy+1,iz-1),FW(ix,iy+1,iz)          & 
                            ,VolC(ix,iy+1,iz-1),VolC(ix,iy+1,iz),VolC(ix,iy+1,iz+1)) 
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix,iy+1,iz,1)=wRhsL(ix,iy+1,iz,1)-Flux
        wRhsL(ix,iy  ,iz,1)=wRhsL(ix,iy  ,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix,iy+1,iz,1)=wRhsR(ix,iy+1,iz,1)-Flux
        wRhsR(ix,iy  ,iz,1)=wRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DV(ix,iy+1,iz,1)
        FF=FV(ix,iy,iz)
        GradL=Zero
        GradR=Half*GradCentr((vCL(ix,iy+1,iz-1,1)+vCR(ix,iy+1,iz-1,1))/(Rho(ix,iy+1,iz-1,1)+Eps) &
                            ,(vCL(ix,iy+1,iz  ,1)+vCR(ix,iy+1,iz  ,1))/(Rho(ix,iy+1,iz  ,1)+Eps) &
                            ,(vCL(ix,iy+1,iz+1,1)+vCR(ix,iy+1,iz+1,1))/(Rho(ix,iy+1,iz+1,1)+Eps) &
                            ,FW(ix,iy+1,iz-1),FW(ix,iy+1,iz)          &
                            ,VolC(ix,iy+1,iz-1),VolC(ix,iy+1,iz),VolC(ix,iy+1,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix,iy+1,iz,1)=wRhsL(ix,iy+1,iz,1)-Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix,iy+1,iz,1)=wRhsR(ix,iy+1,iz,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        GradL=Half*GradCentr((vCL(ix,iy,iz-1,1)+vCR(ix,iy,iz-1,1))/(Rho(ix,iy,iz-1,1)+Eps) &
                            ,(vCL(ix,iy,iz  ,1)+vCR(ix,iy,iz  ,1))/(Rho(ix,iy,iz  ,1)+Eps) &
                            ,(vCL(ix,iy,iz+1,1)+vCR(ix,iy,iz+1,1))/(Rho(ix,iy,iz+1,1)+Eps) &
                            ,FW(ix,iy,iz-1),FW(ix,iy,iz)          &
                            ,VolC(ix,iy,iz-1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        GradR=Half*GradCentr((vCL(ix,iy+1,iz-1,1)+vCR(ix,iy+1,iz-1,1))/(Rho(ix,iy+1,iz-1,1)+Eps) &
                            ,(vCL(ix,iy+1,iz  ,1)+vCR(ix,iy+1,iz  ,1))/(Rho(ix,iy+1,iz  ,1)+Eps) &
                            ,(vCL(ix,iy+1,iz+1,1)+vCR(ix,iy+1,iz+1,1))/(Rho(ix,iy+1,iz+1,1)+Eps) &
                            ,FW(ix,iy+1,iz-1),FW(ix,iy+1,iz)          &
                            ,VolC(ix,iy+1,iz-1),VolC(ix,iy+1,iz),VolC(ix,iy+1,iz+1))
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix,iy+1,iz,1)=wRhsL(ix,iy+1,iz,1)-Flux
        wRhsL(ix,iy  ,iz,1)=wRhsL(ix,iy  ,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(Two*FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix,iy+1,iz,1)=wRhsR(ix,iy+1,iz,1)-Flux
        wRhsR(ix,iy  ,iz,1)=wRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeN(1:1)/='o') THEN
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        GradL=Half*GradCentr((vCL(ix,iy,iz-1,1)+vCR(ix,iy,iz-1,1))/(Rho(ix,iy,iz-1,1)+Eps) &
                            ,(vCL(ix,iy,iz  ,1)+vCR(ix,iy,iz  ,1))/(Rho(ix,iy,iz  ,1)+Eps) &
                            ,(vCL(ix,iy,iz+1,1)+vCR(ix,iy,iz+1,1))/(Rho(ix,iy,iz+1,1)+Eps) &
                            ,FW(ix,iy,iz-1),FW(ix,iy,iz)          &
                            ,VolC(ix,iy,iz-1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix,iy+1,iz,1)=wRhsL(ix,iy+1,iz,1)-Flux
        wRhsL(ix,iy  ,iz,1)=wRhsL(ix,iy  ,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix,iy+1,iz,1)=wRhsR(ix,iy+1,iz,1)-Flux
        wRhsR(ix,iy  ,iz,1)=wRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  ELSE
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DV(ix,iy,iz,1)
        FF=FV(ix,iy,iz)
        GradL=Half*GradCentr((vCL(ix,iy,iz-1,1)+vCR(ix,iy,iz-1,1))/(Rho(ix,iy,iz-1,1)+Eps) &
                            ,(vCL(ix,iy,iz  ,1)+vCR(ix,iy,iz  ,1))/(Rho(ix,iy,iz  ,1)+Eps) &
                            ,(vCL(ix,iy,iz+1,1)+vCR(ix,iy,iz+1,1))/(Rho(ix,iy,iz+1,1)+Eps) &
                            ,FW(ix,iy,iz-1),FW(ix,iy,iz)          &
                            ,VolC(ix,iy,iz-1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        GradR=Zero
        FluxCr=IntCellToFace(GradL,GradR,VL,VR)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsL(ix,iy  ,iz,1)=wRhsL(ix,iy  ,iz,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy+1,iz,1)/(Rho(ix,iy+1,iz,1)+Eps)
        Flux=Two*DRhoF*FF*(FF/(VL+VR+Eps)*(cR-cL)+FluxCr)
        wRhsR(ix,iy  ,iz,1)=wRhsR(ix,iy  ,iz,1)+Flux
      END DO
    END DO
  END IF
! z-Direction
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)-Flux
        wRhsL(ix,iy,iz  ,1)=wRhsL(ix,iy,iz  ,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsR(ix,iy,iz+1,1)=wRhsR(ix,iy,iz+1,1)-Flux
        wRhsR(ix,iy,iz  ,1)=wRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  ELSE
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
       VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DV(ix,iy,iz+1,1)
        FF=FW(ix,iy,iz)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)-Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsR(ix,iy,iz+1,1)=wRhsR(ix,iy,iz+1,1)-Flux
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
       VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)-Flux
        wRhsL(ix,iy,iz  ,1)=wRhsL(ix,iy,iz  ,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsR(ix,iy,iz+1,1)=wRhsR(ix,iy,iz+1,1)-Flux
        wRhsR(ix,iy,iz  ,1)=wRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  END DO
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)-Flux
        wRhsL(ix,iy,iz  ,1)=wRhsL(ix,iy,iz  ,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Two*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsR(ix,iy,iz+1,1)=wRhsR(ix,iy,iz+1,1)-Flux
        wRhsR(ix,iy,iz  ,1)=wRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  ELSE
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DV(ix,iy,iz,1)
        FF=FW(ix,iy,iz)
        cL=wCL(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCL(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsL(ix,iy,iz  ,1)=wRhsL(ix,iy,iz  ,1)+Flux
        cL=wCR(ix,iy,iz,1)/(Rho(ix,iy,iz,1)+Eps)
        cR=wCR(ix,iy,iz+1,1)/(Rho(ix,iy,iz+1,1)+Eps)
        Flux=  &
             Four*DRhoF*FF*FF/(VL+VR+Eps)*(cR-cL)
        wRhsR(ix,iy,iz  ,1)=wRhsR(ix,iy,iz  ,1)+Flux
      END DO
    END DO
  END IF

  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        wRhsL(ix,iy,iz,1)=wRhsL(ix,iy,iz,1)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        wRhsR(ix,iy,iz,1)=wRhsR(ix,iy,iz,1)*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO
END SUBROUTINE DiffusionComputeW

SUBROUTINE JacDiffusionCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: VL,VR
  REAL(RealKind) :: DL,DR
  REAL(RealKind) :: FF,DRhoF
  REAL(RealKind) :: Temp
  INTEGER :: nxP2,nyP2,nzP2

  nxP2=ix1-ix0+2
  nyP2=iy1-iy0+2
  nzP2=iz1-iz0+2

! Dichte Einarbeiten -------------

! x-Direction
  IF (TypeW(1:1)/='o') THEN
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_i
        i=Index(ix,iy,iz)
        AT%Val(i,3)=AT%Val(i,3)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_i+1
        i=Index(ix+1,iy,iz)
        AT%Val(i,5)=AT%Val(i,5)+Temp/(VL+Eps)/(Rho(ix+1,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix+1,iy,iz,1)+Eps)
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_i
        i=Index(ix,iy,iz)
        AT%Val(i,3)=AT%Val(i,3)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_i+1
        i=Index(ix+1,iy,iz)
        AT%Val(i,5)=AT%Val(i,5)+Temp/(VL+Eps)/(Rho(ix+1,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix+1,iy,iz,1)+Eps)
      END DO
    END DO
  END DO
  IF (TypeE(1:1)/='o') THEN
    ix=ix1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix+1,iy,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix+1,iy,iz,1),VR)
        FF=FU(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_i
        i=Index(ix,iy,iz)
        AT%Val(i,3)=AT%Val(i,3)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_i+1
        i=Index(ix+1,iy,iz)
        AT%Val(i,5)=AT%Val(i,5)+Temp/(VL+Eps)/(Rho(ix+1,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix+1,iy,iz,1)+Eps)
      END DO
    END DO
  END IF
! y-Direction
  IF (TypeS(1:1)/='o') THEN
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_j
        i=Index(ix,iy,iz)
        AT%Val(i,2)=AT%Val(i,2)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_j+1
        i=Index(ix,iy+1,iz)
        AT%Val(i,6)=AT%Val(i,6)+Temp/(VL+Eps)/(Rho(ix,iy+1,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix,iy+1,iz,1)+Eps)
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_j
        i=Index(ix,iy,iz)
        AT%Val(i,2)=AT%Val(i,2)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_j+1
        i=Index(ix,iy+1,iz)
        AT%Val(i,6)=AT%Val(i,6)+Temp/(VL+Eps)/(Rho(ix,iy+1,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix,iy+1,iz,1)+Eps)
      END DO
    END DO
  END DO
  IF (TypeN(1:1)/='o') THEN
    iy=iy1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy+1,iz)
        DRhoF=DF(DH(ix,iy,iz,1),VL,DH(ix,iy+1,iz,1),VR)
        FF=FV(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_j
        i=Index(ix,iy,iz)
        AT%Val(i,2)=AT%Val(i,2)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_j+1
        i=Index(ix,iy+1,iz)
        AT%Val(i,6)=AT%Val(i,6)+Temp/(VL+Eps)/(Rho(ix,iy+1,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix,iy+1,iz,1)+Eps)
      END DO
    END DO
  END IF

! z-Direction
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_k
        i=Index(ix,iy,iz)
        AT%Val(i,1)=AT%Val(i,1)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_k+1
        i=Index(ix,iy,iz+1)
        AT%Val(i,7)=AT%Val(i,7)+Temp/(VL+Eps)/(Rho(ix,iy,iz+1,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix,iy,iz+1,1)+Eps)
      END DO
    END DO
  END IF
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        i=Index(ix,iy,iz)
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_k
        i=Index(ix,iy,iz)
        AT%Val(i,1)=AT%Val(i,1)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_k+1
        i=Index(ix,iy,iz+1)
        AT%Val(i,7)=AT%Val(i,7)+Temp/(VL+Eps)/(Rho(ix,iy,iz+1,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix,iy,iz+1,1)+Eps)
      END DO
    END DO
  END DO
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VL=VolC(ix,iy,iz)
        VR=VolC(ix,iy,iz+1)
        DRhoF=DF(DV(ix,iy,iz,1),VL,DV(ix,iy,iz+1,1),VR)
        FF=FW(ix,iy,iz)
        Temp=Two*DRhoF*FF*FF/(VL+VR+Eps)
!       Ableitung nach c_k
        i=Index(ix,iy,iz)
        AT%Val(i,1)=AT%Val(i,1)+Temp/(VR+Eps)/(Rho(ix,iy,iz,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VL+Eps)/(Rho(ix,iy,iz,1)+Eps)
!       Ableitung nach c_k+1
        i=Index(ix,iy,iz+1)
        AT%Val(i,7)=AT%Val(i,7)+Temp/(VL+Eps)/(Rho(ix,iy,iz+1,1)+Eps)
        AT%Val(i,4)=AT%Val(i,4)-Temp/(VR+Eps)/(Rho(ix,iy,iz+1,1)+Eps)
      END DO
    END DO
  END IF

CONTAINS
  FUNCTION Index(ix,iy,iz)
    INTEGER :: Index,ix,iy,iz
    Index=ix-ix0+1+nxP2*(iy-iy0)+nxP2*nyP2*(iz-iz0)  
  END FUNCTION Index
END SUBROUTINE JacDiffusionCompute

SUBROUTINE AdvectionUpdate(alpha)

  REAL(RealKind) :: alpha
  INTEGER :: it

  DO it=LBOUND(c,4),UBOUND(c,4)
    c(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,it)=c(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,it)+ &
           alpha*f(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1,it)/ &
           (VolC(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1) &
            +Eps)  
  END DO

END SUBROUTINE AdvectionUpdate

SUBROUTINE AdvectionScale

  INTEGER :: ix,iy,iz,it

  DO it=LBOUND(f,4),UBOUNd(f,4)
    f(ix0:ix1+1,iy0:iy1+1,iz0:iz1+1,it)=                                 &
           f(ix0:ix1+1,iy0:iy1+1,iz0:iz1+1,it)/ &
           (VolC(ix0:ix1+1,iy0:iy1+1,iz0:iz1+1) &
            +Eps)  
  END DO

END SUBROUTINE AdvectionScale

SUBROUTINE AuftriebDryCompute

  INTEGER :: ix,iy,iz

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        f(ix,iy,iz,1)=f(ix,iy,iz,1)- &
            Rho(ix,iy,iz,1)*Grav 
      END DO
    END DO
  END DO

END SUBROUTINE AuftriebDryCompute

SUBROUTINE AuftriebDryComputeLR
  IF (.NOT.Anelastic) THEN
    IF (GradFull) THEN
     CALL AuftriebDryComputeLRFull
    ELSE
      CALL AuftriebDryComputeLRVol
    END IF
  ELSE
    IF (GradFull) THEN
      CALL BousinesqComputeLRFull
    ELSE  
      CALL BousinesqComputeLRVol
    END IF
  END IF

END SUBROUTINE AuftriebDryComputeLR

SUBROUTINE AuftriebDryComputeLRFull

  INTEGER :: ix,iy,iz
  INTEGER :: jx,jy,jz
  INTEGER :: in
  REAL(RealKind) :: RhoLoc,F
  REAL(RealKind) :: RhoFine,VolFine
  REAL(RealKind) :: RhoCoarse,VolCoarse

  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps)*(dz(iz)*RhoD(ix,iy,iz,1) &
               +dz(iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(dz(iz)+dz(iz+1)+Eps) 
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1)- &
            RhoLoc*Grav
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1)- &
            RhoLoc*Grav
      END DO
    END DO
  END DO
  DO in=1,AnzahlNachbar
    CALL Set(Nachbars(in))
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            RhoFine= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            RhoCoarse= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (VolCoarse+Eps)
            RhoLoc=F/(F+Eps)*(RhoFine*dz(iz0+1)+RhoCoarse*dLoc)/(dz(iz0+1)+dLoc+Eps)

            fL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)=fL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1) &
               -Grav*RhoLoc
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            RhoLoc=FW(jx,jy,iz0)/(FW(jx,jy,iz0)+Eps)*(RhoD(jx,jy,iz0+1,1)*dz(iz0+1)+RhoD(jx,jy,iz0,1)*dLoc)/(dz(iz0+1)+dLoc+Eps)
            fL(jx,jy,iz0+1,1)=fL(jx,jy,iz0+1,1)-Grav*RhoLoc
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            RhoFine= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            RhoCoarse= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            RhoLoc=F/(F+Eps)*(RhoCoarse*dLoc+RhoFine*dz(iz1))/(dLoc+dz(iz1)+Eps)
            fR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)=fR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1) &
               -Grav*RhoLoc
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            RhoLoc=FW(jx,jy,iz1)/(FW(jx,jy,iz1)+Eps)*(RhoD(jx,jy,iz1,1)*dz(iz1)+RhoD(jx,jy,iz1+1,1)*dLoc)/(dz(iz1)+dLoc+Eps)
            fR(jx,jy,iz1,1)=fR(jx,jy,iz1,1)-Grav*RhoLoc
          END DO
        END DO
      END IF
    END IF
  END DO  

END SUBROUTINE AuftriebDryComputeLRFull

SUBROUTINE AuftriebDryComputeLRVol

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc

  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*RhoD(ix,iy,iz,1) &
               +VolC(ix,iy,iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1)- &
            RhoLoc*Grav
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1)- &
            RhoLoc*Grav
      END DO
    END DO
  END DO
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*RhoD(ix,iy,iz,1) &
               +VolC(ix,iy,iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1)- &
            RhoLoc*Grav
      END DO
    END DO
  END IF
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*RhoD(ix,iy,iz,1) &
               +VolC(ix,iy,iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1)- &
            RhoLoc*Grav
      END DO
    END DO
  END IF

END SUBROUTINE AuftriebDryComputeLRVol

SUBROUTINE HeightComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: HeightLoc

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        HeightLoc=(Rho(ix,iy,iz,1)+Rho(ix+1,iy,iz,1)) &
               *FU(ix,iy,iz)/(FU(ix,iy,iz)+Eps)*(HeightC(ix+1,iy,iz,1)-HeightC(ix,iy,iz,1)) &
               /(MetrX(iy)*(dx(ix)+dx(ix+1)+Eps))
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)- &
            HeightLoc*Grav
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)- &
            HeightLoc*Grav
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        HeightLoc=(Rho(ix,iy,iz,1)+Rho(ix,iy+1,iz,1)) &
               *FV(ix,iy,iz)/(FV(ix,iy,iz)+Eps)*(HeightC(ix,iy+1,iz,1)-HeightC(ix,iy,iz,1)) &
               /(MetrY(ix)*(dy(iy+1)+dy(iy)+Eps))
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)- &
            HeightLoc*Grav
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)- &
            HeightLoc*Grav
      END DO
    END DO
  END DO

END SUBROUTINE HeightComputeLR

SUBROUTINE AuftriebComputeF
  SELECT CASE(ThetaKind)
    CASE ('Pseudo')
      CALL BousinesqComputeF
    CASE DEFAULT
      IF (GradFull) THEN
        CALL AuftriebDryComputeFFull
      ELSE  
        CALL AuftriebDryComputeFVol
      END IF  
  END SELECT    
END SUBROUTINE AuftriebComputeF

SUBROUTINE AuftriebDryComputeFFull

  INTEGER :: ix,iy,iz
  INTEGER :: jx,jy,jz
  INTEGER :: in
  REAL(RealKind) :: RhoLoc,F
  REAL(RealKind) :: RhoFine,VolFine
  REAL(RealKind) :: RhoCoarse,VolCoarse

  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps)*(dz(iz)*RhoD(ix,iy,iz,1) &
               +dz(iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(dz(iz)+dz(iz+1)+Eps) 
        wfRhs(ix,iy,iz)=wfRhs(ix,iy,iz)- &
            RhoLoc*Grav
      END DO
    END DO
  END DO
  DO in=1,AnzahlNachbar
    CALL Set(Nachbars(in))
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            RhoFine= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            RhoCoarse= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (VolCoarse+Eps)
            RhoLoc=F/(F+Eps)*(RhoFine*dz(iz0+1)+RhoCoarse*dLoc)/(dz(iz0+1)+dLoc+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0) &
               -Grav*RhoLoc
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            RhoLoc=FW(jx,jy,iz0)/(FW(jx,jy,iz0)+Eps)*(RhoD(jx,jy,iz0+1,1)*dz(iz0+1)+RhoD(jx,jy,iz0,1)*dLoc)/(dz(iz0+1)+dLoc+Eps)
            wFRhs(jx,jy,iz0)=wFRhs(jx,jy,iz0)-Grav*RhoLoc
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            RhoFine= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            RhoCoarse= &
               SUM(RhoD(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            RhoLoc=F/(F+Eps)*(RhoCoarse*dLoc+RhoFine*dz(iz1))/(dLoc+dz(iz1)+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1) &
               -Grav*RhoLoc
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            RhoLoc=FW(jx,jy,iz1)/(FW(jx,jy,iz1)+Eps)*(RhoD(jx,jy,iz1,1)*dz(iz1)+RhoD(jx,jy,iz1+1,1)*dLoc)/(dz(iz1)+dLoc+Eps)
            wFRhs(jx,jy,iz1)=wFRhs(jx,jy,iz1)-Grav*RhoLoc
          END DO
        END DO
      END IF
    END IF
  END DO  

END SUBROUTINE AuftriebDryComputeFFull

SUBROUTINE AuftriebDryComputeFVol

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc

  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*RhoD(ix,iy,iz,1) &
               +VolC(ix,iy,iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)- &
            RhoLoc*Grav
      END DO
    END DO
  END DO
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*RhoD(ix,iy,iz,1) &
               +VolC(ix,iy,iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)- &
            RhoLoc*Grav
      END DO
    END DO
  END IF
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*RhoD(ix,iy,iz,1) &
               +VolC(ix,iy,iz+1)*RhoD(ix,iy,iz+1,1)) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)- &
            RhoLoc*Grav
      END DO
    END DO
  END IF

END SUBROUTINE AuftriebDryComputeFVol

SUBROUTINE JacAuftriebDryComputeLR

  IF (Anelastic) THEN
    CALL JacBousinesqComputeLR
  ELSE
    CALL JacAuftriebDryComComputeLR
  END IF
END SUBROUTINE JacAuftriebDryComputeLR

SUBROUTINE JacAuftriebDryCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: thL,thC,thR
  REAL(RealKind) :: GradL,GradR
  REAL(RealKind) :: VC,VR,VL
  REAL(RealKind) :: FR,FL

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        AS(IndexMet(wPosLJac,rhoPosJac))%c(ix,iy,iz,1)=-Grav 
        AS(IndexMet(wPosRJac,rhoPosJac))%c(ix,iy,iz,1)=-Grav 
      END DO
    END DO
  END DO

END SUBROUTINE JacAuftriebDryCompute

SUBROUTINE JacAuftriebDryComComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: thL,thC,thR
  REAL(RealKind) :: GradL,GradR
  REAL(RealKind) :: VC,VR,VL
  REAL(RealKind) :: FR,FL
  REAL(RealKind) :: Temp

  IF (.NOT.MultiTriTB.AND..NOT.MultiTriTR.AND..NOT.MultiMuTR) THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          AS(IndexMet(wPosLJac,rhoPosJac))%c(ix,iy,iz,1)=-Grav
          AS(IndexMet(wPosRJac,rhoPosJac))%c(ix,iy,iz,1)=-Grav
        END DO
      END DO
    END DO
  END IF

END SUBROUTINE JacAuftriebDryComComputeLR


SUBROUTINE AuftriebCloudComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc

  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*(RhoD(ix,iy,iz,1) &
               +qv(ix,iy,iz,1)   &
               +qc(ix,iy,iz,1)   &
                             )   &
               +VolC(ix,iy,iz+1)*(RhoD(ix,iy,iz+1,1) &
               +qv(ix,iy,iz+1,1)   &
               +qc(ix,iy,iz+1,1)   &
                             ))    &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1) &
                        -RhoLoc*Grav
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1) &
                      -RhoLoc*Grav
      END DO
    END DO
  END DO
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*(RhoD(ix,iy,iz,1) &
               +qv(ix,iy,iz,1)   &
               +qc(ix,iy,iz,1))   &
               +VolC(ix,iy,iz+1)*(RhoD(ix,iy,iz+1,1) &
               +qv(ix,iy,iz+1,1)   &
               +qc(ix,iy,iz+1,1)))   &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1) &
                      -RhoLoc*Grav
      END DO
    END DO
  END IF
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*(RhoD(ix,iy,iz,1) &
               +qv(ix,iy,iz,1)   &
               +qc(ix,iy,iz,1))   &
               +VolC(ix,iy,iz+1)*(RhoD(ix,iy,iz+1,1) &
               +qv(ix,iy,iz+1,1)   &
               +qc(ix,iy,iz+1,1)))   &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1) &
                        -RhoLoc*Grav
      END DO
    END DO
  END IF

END SUBROUTINE AuftriebCloudComputeLR

SUBROUTINE JacAuftriebCloudComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: thL,thC,thR
  REAL(RealKind) :: GradL,GradR
  REAL(RealKind) :: VC,VR,VL
  REAL(RealKind) :: FR,FL
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        AS(IndexMet(wPosLJac,rhoPosJac))%c(ix,iy,iz,1)=-Grav
        AS(IndexMet(wPosLJac,qvPosJac))%c(ix,iy,iz,1)=-Grav
        AS(IndexMet(wPosLJac,qcPosJac))%c(ix,iy,iz,1)=-Grav
        AS(IndexMet(wPosRJac,rhoPosJac))%c(ix,iy,iz,1)=-Grav
        AS(IndexMet(wPosRJac,qvPosJac))%c(ix,iy,iz,1)=-Grav
        AS(IndexMet(wPosRJac,qcPosJac))%c(ix,iy,iz,1)=-Grav
      END DO
    END DO
  END DO

END SUBROUTINE JacAuftriebCloudComputeLR

SUBROUTINE BousinesqComputeLRFull

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        RhoLoc=FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps) &
              *(dz(iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +dz(iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(dz(iz)+dz(iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1)+ &
            RhoLoc*Grav
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1)+ &
            RhoLoc*Grav
      END DO
    END DO
  END DO
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps) &
              *(dz(iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +dz(iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(dz(iz)+dz(iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1)+ &
            RhoLoc*Grav
      END DO
    END DO
  END IF
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps) &
              *(dz(iz)**BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +dz(iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(dz(iz)+dz(iz+1)+Eps)
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1)+ &
            RhoLoc*Grav
      END DO
    END DO
  END IF

END SUBROUTINE BousinesqComputeLRFull

SUBROUTINE BousinesqComputeLRVol

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc

  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +VolC(ix,iy,iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1)+ &
            RhoLoc*Grav
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1)+ &
            RhoLoc*Grav
      END DO
    END DO
  END DO
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +VolC(ix,iy,iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fL(ix,iy,iz+1,1)=fL(ix,iy,iz+1,1)+ &
            RhoLoc*Grav
      END DO
    END DO
  END IF
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +VolC(ix,iy,iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        fR(ix,iy,iz,1)=fR(ix,iy,iz,1)+ &
            RhoLoc*Grav
      END DO
    END DO
  END IF

END SUBROUTINE BousinesqComputeLRVol

SUBROUTINE BousinesqComputeF

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc

  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +VolC(ix,iy,iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)+ &
            RhoLoc*Grav
      END DO
    END DO
  END DO
  IF (TypeB(1:1)/='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +VolC(ix,iy,iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)+ &
            RhoLoc*Grav
      END DO
    END DO
  END IF
  IF (TypeT(1:1)/='o') THEN
    iz=iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=(VolC(ix,iy,iz)*BousinesqF(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1)) &
               +VolC(ix,iy,iz+1)*BousinesqF(Th(ix,iy,iz+1,1),ThProf(ix,iy,iz+1,1),Rho(ix,iy,iz+1,1))) &
               /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)+ &
            RhoLoc*Grav
      END DO
    END DO
  END IF

END SUBROUTINE BousinesqComputeF

FUNCTION BousinesqF(T,TProf,Rho)
  REAL(RealKind) BousinesqF,T,TProf,Rho
  
  BousinesqF=Rho
  SELECT CASE(BousinesqType) 
    CASE('Scaled')
      BousinesqF=Rho*(T-TProf)/(TProf+Eps)
    CASE('UnScaled')
      BousinesqF=alphaBous*(T-TProf)
  END SELECT    
END FUNCTION BousinesqF

FUNCTION BousinesqF1(T,TProf,Rho)
  REAL(RealKind) BousinesqF1,T,TProf,Rho
  
  BousinesqF1=Rho
  SELECT CASE(BousinesqType) 
    CASE('Scaled')
      BousinesqF1=Rho*(T-TProf)/(Tprof+Eps)+Rho
    CASE('UnScaled')
      BousinesqF1=-alphaBous*(T-TProf)+Rho
  END SELECT    
END FUNCTION BousinesqF1


FUNCTION BousinesqF2(T,TProf,Rho)
  REAL(RealKind) BousinesqF2,T,TProf,Rho
  
  BousinesqF2=Rho
  SELECT CASE(BousinesqType) 
    CASE('Scaled')
      BousinesqF2=Rho*(T-TProf)/(Tprof+Eps)+Rho
    CASE('UnScaled')
      BousinesqF2=-alphaBous*(T-TProf)
  END SELECT    
END FUNCTION BousinesqF2
SUBROUTINE JacBousinesqComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: thL,thC,thR
  REAL(RealKind) :: GradL,GradR
  REAL(RealKind) :: VC,VR,VL
  REAL(RealKind) :: FR,FL
  REAL(RealKind) :: Temp

  IF (.NOT.MultiTriTB.AND..NOT.MultiTriTR.AND..NOT.MultiMuTr) THEN
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          AS(IndexMet(wPosLJac,thPosJac))%c(ix,iy,iz,1) &
            =Grav*BousinesqJac(ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1))
          AS(IndexMet(wPosRJac,thPosJac))%c(ix,iy,iz,1) &
            =Grav*BousinesqJac(ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1))
        END DO
      END DO
    END DO
  END IF

END SUBROUTINE JacBousinesqComputeLR

FUNCTION BousinesqJac(TProf,Rho)
  REAL(RealKind) BousinesqJac,TProf,Rho
  
  BousinesqJac=One
  SELECT CASE(BousinesqType) 
    CASE('Scaled')
      BousinesqJac=Rho/(TProf+Eps)
    CASE('UnScaled')
      BousinesqJac=alphaBous
  END SELECT    
END FUNCTION BousinesqJac

FUNCTION BousinesqJac2(TProf,Rho)
  REAL(RealKind) BousinesqJac2,TProf,Rho
  
  BousinesqJac2=One
  SELECT CASE(BousinesqType) 
    CASE('Scaled')
      BousinesqJac2=Rho/(TProf+Eps)
    CASE('UnScaled')
      BousinesqJac2=-alphaBous
  END SELECT    
END FUNCTION BousinesqJac2


SUBROUTINE Cond(Rho,RhoV,RhoL,PotM,RhsRhoV,RhsRhoL,RhsPotM)

  REAL(RealKind) :: Rho,RhoV,RhoL,PotM,RhsRhoV,RhsRhoL,RhsPotM

  REAL(RealKind) :: RhoD,p,qL,T
  REAL(RealKind) :: pVs,DrvDt,DrlDt,Rm,Cpml,Cvml,Lv

  qL=RhoL/(Rho+Eps)
  RhoD=Rho-RhoV-RhoL+Eps
  p=PressureTheta(RhoD,RhoV,RhoL,PotM)+Eps
  T=AbsTemp(RhoD,RhoV,p)+Eps
  pVs=SaturVapor(T)
  DrvDt=RelCloud*((pVs/(Rv*T)-RhoV)+RhoL- &
        SQRT((pVs/(Rv*T)-RhoV)*(pVs/(Rv*T)-RhoV)+RhoL*RhoL))
  DrlDt=-DrvDt
  Rm=Rd*RhoD+Rv*RhoV+Eps
  Cpml=Cpd*RhoD+Cpv*RhoV+Cpl*RhoL+Eps
  Cvml=Cvd*RhoD+Cvv*RhoV+Cpl*RhoL+Eps
  Lv=LatHeat(T)
  RhsPotM=PotM*( &
                (-Lv/(Cpml*T) &  
                 -LOG(p/P0)*(Rm/Cpml)*(Rv/Rm-Cpv/Cpml) &
                 +Rv/Rm                                   &
                 )*DrvDt                                   &
                +(LOG(p/P0)*(Rm/Cpml)*(Cpl/Cpml)        &
                 )*DrlDt                                   &
                )
  RhsRhoV=DrvDt
  RhsRhoL=DrlDt

END SUBROUTINE Cond

SUBROUTINE CloudCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: PotMLoc,RhoLoc,RhoVLoc,RhoLLoc
  REAL(RealKind) :: RhsRhoV,RhsRhoL,RhsPotM

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        PotMLoc=th(ix,iy,iz,1)
        RhoLoc=Rho(ix,iy,iz,1)
        RhoVLoc=RhoV(ix,iy,iz,1)
        RhoLLoc=RhoL(ix,iy,iz,1)
        CALL Cond(RhoLoc,RhoVLoc,RhoLLoc,PotMLoc,RhsRhoV,RhsRhoL,RhsPotM) 
        thRhs(ix,iy,iz,1)=thRhs(ix,iy,iz,1)+RhsPotM
        RhoVRhs(ix,iy,iz,1)=RhoVRhs(ix,iy,iz,1)+RhsRhoV 
        RhoLRhs(ix,iy,iz,1)=RhoLRhs(ix,iy,iz,1)+RhsRhoL 
      END DO
    END DO
  END DO
        
END SUBROUTINE CloudCompute

SUBROUTINE JacCloudCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: PotMLoc,RhoLoc,RhoVLoc,RhoLLoc
  REAL(RealKind) :: RhsRhoV,RhsRhoL,RhsPotM
  REAL(RealKind) :: RhsRhoV1,RhsRhoL1,RhsPotM1
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        PotMLoc=th(ix,iy,iz,1)
        RhoLoc=Rho(ix,iy,iz,1)
        RhoVLoc=RhoV(ix,iy,iz,1)
        RhoLLoc=RhoL(ix,iy,iz,1)
        CALL Cond(RhoLoc,RhoVLoc,RhoLLoc,PotMLoc,RhsRhoV,RhsRhoL,RhsPotM)
        Temp=PotMLoc
        PotMLoc=Temp*(1.0d0+1.d-8)
        CALL Cond(RhoLoc,RhoVLoc,RhoLLoc,PotMLoc,RhsRhoV1,RhsRhoL1,RhsPotM1)
        AS(IndexMet(thPosJac,thPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(thPosJac,thPosJac))%c(ix,iy,iz,1)+(RhsPotM1-RhsPotM)/(PotMloc-Temp+Eps)
        AS(IndexMet(qvPosJac,thPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(qvPosJac,thPosJac))%c(ix,iy,iz,1)+(RhsRhoV1-RhsRhoV)/(PotMloc-Temp+Eps)
        AS(IndexMet(qcPosJac,thPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(qcPosJac,thPosJac))%c(ix,iy,iz,1)+(RhsRhoL1-RhsRhoL)/(PotMloc-Temp+Eps)
        PotMLoc=Temp

        Temp=RhoVLoc
        RhoVLoc=Temp*(1.0d0+1.d-8)
        CALL Cond(RhoLoc,RhoVLoc,RhoLLoc,PotMLoc,RhsRhoV1,RhsRhoL1,RhsPotM1)
        AS(IndexMet(thPosJac,qvPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(thPosJac,qvPosJac))%c(ix,iy,iz,1)+(RhsPotM1-RhsPotM)/(RhoVLoc-Temp+Eps)
        AS(IndexMet(qvPosJac,qvPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(qvPosJac,qvPosJac))%c(ix,iy,iz,1)+(RhsRhoV1-RhsRhoV)/(RhoVLoc-Temp+Eps)
        AS(IndexMet(qcPosJac,qvPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(qcPosJac,qvPosJac))%c(ix,iy,iz,1)+(RhsRhoL1-RhsRhoL)/(RhoVLoc-Temp+Eps)
        RhoVLoc=Temp

        Temp=RhoLLoc
        RhoLLoc=Temp*(1.0d0+1.d-8)
        CALL Cond(RhoLoc,RhoVLoc,RhoLLoc,PotMLoc,RhsRhoV1,RhsRhoL1,RhsPotM1)
        AS(IndexMet(thPosJac,qcPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(thPosJac,qcPosJac))%c(ix,iy,iz,1)+(RhsPotM1-RhsPotM)/(RhoLLoc-Temp+Eps)
        AS(IndexMet(qvPosJac,qcPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(qvPosJac,qcPosJac))%c(ix,iy,iz,1)+(RhsRhoV1-RhsRhoV)/(RhoLLoc-Temp+Eps)
        AS(IndexMet(qcPosJac,qcPosJac))%c(ix,iy,iz,1)= &
        AS(IndexMet(qcPosJac,qcPosJac))%c(ix,iy,iz,1)+(RhsRhoL1-RhsRhoL)/(RhoLLoc-Temp+Eps)
        RhoLLoc=Temp
      END DO
    END DO
  END DO

END SUBROUTINE JacCloudCompute
SUBROUTINE PGradComputeC
  IF (GradFull) THEN
    CALL PGradComputeCFull
  ELSE
    CALL PGradComputeC1
  END IF
END SUBROUTINE PGradComputeC
SUBROUTINE PGradComputeC1

  INTEGER :: ix,iy,iz,in,jx,jy,jz
  REAL(RealKind) :: Grad
  REAL(RealKind) :: F,VolFine,VolCoarse,pFine,pCoarse

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        Grad=FU(ix,iy,iz)*(p(ix+1,iy,iz,1)-p(ix,iy,iz,1))/(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)+Eps)
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)-Two*VolC(ix+1,iy,iz)*Grad
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)-Two*VolC(ix,iy,iz)*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        Grad=FV(ix,iy,iz)*(p(ix,iy+1,iz,1)-p(ix,iy,iz,1))/(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)+Eps)
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)-Two*VolC(ix,iy+1,iz)*Grad
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)-Two*VolC(ix,iy,iz)*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Grad=FW(ix,iy,iz)*(p(ix,iy,iz+1,1)-p(ix,iy,iz,1))/(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)+Eps)
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)-Two*VolC(ix,iy,iz+1)*Grad
        wRhsR(ix,iy,iz,1)=wRhsR(ix,iy,iz,1)-Two*VolC(ix,iy,iz)*Grad
      END DO
    END DO
  END DO


  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            uRhsL(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)=uRhsL(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1) &
                -Two*VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix0,jy,jz)*(p(ix0+1,jy,jz,1)-p(ix0,jy,jz,1))/(VolC(ix0+1,jy,jz)+VolC(ix0,jy,jz)+Eps) 
            uRhsL(ix0+1,jy,jz,1)=uRhsL(ix0+1,jy,jz,1)-Two*VolC(ix0+1,jy,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            uRhsR(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)=uRhsR(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1) &
                -Two*VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix1,jy,jz)*(p(ix1+1,jy,jz,1)-p(ix1,jy,jz,1))/(VolC(ix1,jy,jz)+VolC(ix1+1,jy,jz)+Eps) 
            uRhsR(ix1,jy,jz,1)=uRhsR(ix1,jy,jz,1)-Two*VolC(ix1,jy,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* & 
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            vRhsL(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)=vRhsL(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1) &
                -Two*VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy0,jz)*(p(jx,iy0+1,jz,1)-p(jx,iy0,jz,1))/(VolC(jx,iy0+1,jz)+VolC(jx,iy0,jz)+Eps)
            vRhsL(jx,iy0+1,jz,1)=vRhsL(jx,iy0+1,jz,1)-Two*VolC(jx,iy0+1,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            pFine= & 
               SUM(p(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            vRhsR(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)=vRhsR(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1) &
                -Two*VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy1,jz)*(p(jx,iy1+1,jz,1)-p(jx,iy1,jz,1))/(VolC(jx,iy1,jz)+VolC(jx,iy1+1,jz)+Eps)
            vRhsR(jx,iy1,jz,1)=vRhsR(jx,iy1,jz,1)-Two*VolC(jx,iy1,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (Volcoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            wRhsL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)=wRhsL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1) &
               -Two*VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1)*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz0)*(p(jx,jy,iz0+1,1)-p(jx,jy,iz0,1))/(VolC(jx,jy,iz0+1)+VolC(jx,jy,iz0)+Eps)
            wRhsL(jx,jy,iz0+1,1)=wRhsL(jx,jy,iz0+1,1)-Two*VolC(jx,jy,iz0+1)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            wRhsR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)=wRhsR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1) &
               -Two*VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz1)*(p(jx,jy,iz1+1,1)-p(jx,jy,iz1,1))/(VolC(jx,jy,iz1)+VolC(jx,jy,iz1+1)+Eps)
            wRhsR(jx,jy,iz1,1)=wRhsR(jx,jy,iz1,1)-Two*VolC(jx,jy,iz1)*Grad
          END DO
        END DO
      END IF
    END IF
  END DO

END SUBROUTINE PGradComputeC1

SUBROUTINE PGradComputeCFull

  INTEGER :: ix,iy,iz,in,jx,jy,jz
  REAL(RealKind) :: Grad
  REAL(RealKind) :: F,VolFine,VolCoarse,pFine,pCoarse
  REAL(RealKind) :: MetrLoc

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        Grad=DUU(ix,iy,iz)*FU(ix,iy,iz)/(FU(ix,iy,iz)+Eps)*(p(ix+1,iy,iz,1)-p(ix,iy,iz,1))/(MetrX(iy)*(dx(ix+1)+dx(ix)+Eps)) 
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)-Two*VolC(ix+1,iy,iz)*Grad
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)-Two*VolC(ix,iy,iz)*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        Grad=DUV(ix,iy,iz)*FV(ix,iy,iz)/(FV(ix,iy,iz)+Eps)*(p(ix,iy+1,iz,1)-p(ix,iy,iz,1))/(MetrY(ix)*(dy(iy+1)+dy(iy)+Eps)) 
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)-Two*VolC(ix,iy+1,iz)*Grad
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)-Two*VolC(ix,iy,iz)*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Grad=DUW(ix,iy,iz)*FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps)*(p(ix,iy,iz+1,1)-p(ix,iy,iz,1))/(dz(iz+1)+dz(iz)+Eps) 
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)-Two*VolC(ix,iy,iz+1)*Grad
        wRhsR(ix,iy,iz,1)=wRhsR(ix,iy,iz,1)-Two*VolC(ix,iy,iz)*Grad
      END DO
    END DO
  END DO


  DO in=1,AnzahlNachbar
    CALL Set(Nachbars(in))
    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrX(jy:jy+IncrY-1)*dy(jy:jy+IncrY-1)) &
                   /SUM(dy(jy:jy+IncrY-1))
            pFine= &
               SUM(p(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pFine-pCoarse)/(MetrLoc*(dLoc+dx(ix0+1)+Eps))
            uRhsL(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)=uRhsL(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1) &
                -Two*VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix0,jy,jz)/(FU(ix0,jy,jz)+Eps)*(p(ix0+1,jy,jz,1)-p(ix0,jy,jz,1))/(MetrX(jy)*(dx(ix0+1)+dLoc+Eps)) 
            uRhsL(ix0+1,jy,jz,1)=uRhsL(ix0+1,jy,jz,1)-Two*VolC(ix0+1,jy,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrX(jy:jy+IncrY-1)*dy(jy:jy+IncrY-1)) &
                   /SUM(dy(jy:jy+IncrY-1))
            pFine= &
               SUM(p(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pCoarse-pFine)/(MetrLoc*(dx(ix1)+dLoc+Eps))
            uRhsR(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)=uRhsR(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1) &
                -Two*VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix1,jy,jz)/(FU(ix1,jy,jz)+Eps)*(p(ix1+1,jy,jz,1)-p(ix1,jy,jz,1))/(MetrX(jy)*(dx(ix1)+dLoc+Eps)) 
            uRhsR(ix1,jy,jz,1)=uRhsR(ix1,jy,jz,1)-Two*VolC(ix1,jy,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrY(jx:jx+IncrX-1)*dx(jx:jx+IncrX-1)) &
                   /SUM(dx(jx:jx+IncrX-1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* & 
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pFine-pCoarse)/(MetrLoc*(dLoc+dy(iy0+1)+Eps))
            vRhsL(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)=vRhsL(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1) &
                -Two*VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy0,jz)/(FV(jx,iy0,jz)+Eps)*(p(jx,iy0+1,jz,1)-p(jx,iy0,jz,1))/(MetrY(jx)*(dy(iy0+1)+dLoc+Eps))
            vRhsL(jx,iy0+1,jz,1)=vRhsL(jx,iy0+1,jz,1)-Two*VolC(jx,iy0+1,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrY(jx:jx+IncrX-1)*dx(jx:jx+IncrX-1)) &
                   /SUM(dx(jx:jx+IncrX-1))
            pFine= & 
               SUM(p(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pCoarse-pFine)/(MetrLoc*(dy(iy1)+dLoc+Eps))
            vRhsR(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)=vRhsR(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1) &
                -Two*VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy1,jz)/(FV(jx,iy1,jz)+Eps)*(p(jx,iy1+1,jz,1)-p(jx,iy1,jz,1))/(MetrY(jx)*(dLoc+dy(iy1)+Eps))
            vRhsR(jx,iy1,jz,1)=vRhsR(jx,iy1,jz,1)-Two*VolC(jx,iy1,jz)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (Volcoarse+Eps)
            Grad=F/(F+Eps)*(pFine-pCoarse)/(dz(iz0+1)+dLoc+Eps)
            wRhsL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)=wRhsL(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1) &
               -Two*VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1)*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz0)/(FW(jx,jy,iz0)+Eps)*(p(jx,jy,iz0+1,1)-p(jx,jy,iz0,1))/(dz(iz0+1)+dLoc+Eps)
            wRhsL(jx,jy,iz0+1,1)=wRhsL(jx,jy,iz0+1,1)-Two*VolC(jx,jy,iz0+1)*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pCoarse-pFine)/(dLoc+dz(iz1)+Eps)
            wRhsR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)=wRhsR(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1) &
               -Two*VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz1)/(FW(jx,jy,iz1)+Eps)*(p(jx,jy,iz1+1,1)-p(jx,jy,iz1,1))/(dz(iz1)+dLoc+Eps)
            wRhsR(jx,jy,iz1,1)=wRhsR(jx,jy,iz1,1)-Two*VolC(jx,jy,iz1)*Grad
          END DO
        END DO
      END IF
    END IF
  END DO

END SUBROUTINE PGradComputeCFull

SUBROUTINE PGradComputeFLin

  INTEGER :: ix,iy,iz,in,jx,jy,jz
  REAL(RealKind) :: Grad
  REAL(RealKind) :: F,VolFine,VolCoarse,pFine,pCoarse
  REAL(RealKind) :: VolLoc

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        VolLoc=VolC(ix+1,iy,iz)+VolC(ix,iy,iz)
        Grad=pFU(ix,iy,iz)*FU(ix,iy,iz)*(th(ix+1,iy,iz,1)-th(ix,iy,iz,1))/(VolLoc+Eps) 
        uFRhs(ix,iy,iz)=uFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        VolLoc=VolC(ix,iy+1,iz)+VolC(ix,iy,iz)
        Grad=pFV(ix,iy,iz)*FV(ix,iy,iz)*(th(ix,iy+1,iz,1)-th(ix,iy,iz,1))/(VolLoc+Eps)
        vFRhs(ix,iy,iz)=vFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        VolLoc=VolC(ix,iy,iz+1)+VolC(ix,iy,iz)
        Grad=pFW(ix,iy,iz)*FW(ix,iy,iz)*(th(ix,iy,iz+1,1)-th(ix,iy,iz,1))/(VolLoc+Eps) 
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(pFU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)*FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(th(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(th(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=pFU(ix0,jy,jz)*FU(ix0,jy,jz)*(th(ix0+1,jy,jz,1)-th(ix0,jy,jz,1))/(VolC(ix0+1,jy,jz)+VolC(ix0,jy,jz)+Eps) 
            uFRhs(ix0,jy,jz)=uFRhs(ix0,jy,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(pFU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)*FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(th(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(th(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=pFU(ix1,jy,jz)*FU(ix1,jy,jz)*(th(ix1+1,jy,jz,1)-th(ix1,jy,jz,1))/(VolC(ix1,jy,jz)+VolC(ix1+1,jy,jz)+Eps) 
            uFRhs(ix1,jy,jz)=uFRhs(ix1,jy,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(pFV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)*FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            pFine= &
               SUM(th(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* & 
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(th(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=pFV(jx,iy0,jz)*FV(jx,iy0,jz)*(th(jx,iy0+1,jz,1)-th(jx,iy0,jz,1))/(VolC(jx,iy0+1,jz)+VolC(jx,iy0,jz)+Eps)
            vFRhs(jx,iy0,jz)=vFRhs(jx,iy0,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(pFV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)*FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            pFine= & 
               SUM(th(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(th(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=pFV(jx,iy1,jz)*FV(jx,iy1,jz)*(th(jx,iy1+1,jz,1)-th(jx,iy1,jz,1))/(VolC(jx,iy1,jz)+VolC(jx,iy1+1,jz)+Eps)
            vFRhs(jx,iy1,jz)=vFRhs(jx,iy1,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(pFW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            pFine= &
               SUM(th(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            pCoarse= &
               SUM(th(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (Volcoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0) &
               -Two*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=pFW(jx,jy,iz0)*FW(jx,jy,iz0)*(th(jx,jy,iz0+1,1)-th(jx,jy,iz0,1))/(VolC(jx,jy,iz0+1)+VolC(jx,jy,iz0)+Eps)
            wFRhs(jx,jy,iz0)=wFRhs(jx,jy,iz0)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(pFW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)*FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            pFine= &
               SUM(th(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            pCoarse= &
               SUM(th(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1) &
               -Two*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=pFW(jx,jy,iz1)*FW(jx,jy,iz1)*(th(jx,jy,iz1+1,1)-th(jx,jy,iz1,1))/(VolC(jx,jy,iz1)+VolC(jx,jy,iz1+1)+Eps)
            wFRhs(jx,jy,iz1)=wFRhs(jx,jy,iz1)-Two*Grad
          END DO
        END DO
      END IF
    END IF
  END DO

END SUBROUTINE PGradComputeFLin

SUBROUTINE PGradComputeF

  IF (GradFull) THEN
    CALL PGradComputeFFull
  ELSE
    CALL PGradComputeF1
  END IF

END SUBROUTINE PGradComputeF

SUBROUTINE PGradComputeFFull

  INTEGER :: ix,iy,iz,in,jx,jy,jz
  REAL(RealKind) :: Grad
  REAL(RealKind) :: F,VolFine,VolCoarse,pFine,pCoarse
  REAL(RealKind) :: MetrLoc

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        Grad=FU(ix,iy,iz)/(FU(ix,iy,iz)+Eps)*(p(ix+1,iy,iz,1)-p(ix,iy,iz,1))/(MetrX(iy)*(dx(ix+1)+dx(ix)+Eps))
        uFRhs(ix,iy,iz)=uFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        Grad=FV(ix,iy,iz)/(FV(ix,iy,iz)+Eps)*(p(ix,iy+1,iz,1)-p(ix,iy,iz,1))/(MetrY(ix)*(dy(iy+1)+dy(iy)+Eps))
        vFRhs(ix,iy,iz)=vFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Grad=FW(ix,iy,iz)/(FW(ix,iy,iz)+Eps)*(p(ix,iy,iz+1,1)-p(ix,iy,iz,1))/(dz(iz+1)+dz(iz)+Eps)
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO


  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrX(jy:jy+IncrY-1)*dy(jy:jy+IncrY-1)) &
                   /SUM(dy(jy:jy+IncrY-1))
            pFine= &
               SUM(p(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pFine-pCoarse)/(MetrLoc*(dLoc+dx(ix0+1)+Eps))
            uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix0,jy,jz)/(FU(ix0,jy,jz)+Eps)*(p(ix0+1,jy,jz,1)-p(ix0,jy,jz,1))/(MetrX(jy)*(dx(ix0+1)+dLoc+Eps)) 
            uFRhs(ix0,jy,jz)=uFRhs(ix0,jy,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrX(jy:jy+IncrY-1)*dy(jy:jy+IncrY-1)) &
                   /SUM(dy(jy:jy+IncrY-1))
            pFine= &
               SUM(p(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pCoarse-pFine)/(MetrLoc*(dx(ix1)+dLoc+Eps))
            uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix1,jy,jz)/(FU(ix1,jy,jz)+Eps)*(p(ix1+1,jy,jz,1)-p(ix1,jy,jz,1))/(MetrX(jy)*(dx(ix1)+dLoc+Eps)) 
            uFRhs(ix1,jy,jz)=uFRhs(ix1,jy,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrY(jx:jx+IncrX-1)*dx(jx:jx+IncrX-1)) &
                   /SUM(dx(jx:jx+IncrX-1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* & 
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pFine-pCoarse)/(MetrLoc*(dLoc+dy(iy0+1)+Eps))
            vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy0,jz)/(FV(jx,iy0,jz)+Eps)*(p(jx,iy0+1,jz,1)-p(jx,iy0,jz,1))/(MetrY(jx)*(dy(iy0+1)+dLoc+Eps))
            vFRhs(jx,iy0,jz)=vFRhs(jx,iy0,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            MetrLoc=SUM(MetrY(jx:jx+IncrX-1)*dx(jx:jx+IncrX-1)) &
                   /SUM(dx(jx:jx+IncrX-1))
            pFine= & 
               SUM(p(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pCoarse-pFine)/(MetrLoc*(dy(iy1)+dLoc+Eps))
            vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy1,jz)/(FV(jx,iy1,jz)+Eps)*(p(jx,iy1+1,jz,1)-p(jx,iy1,jz,1))/(MetrY(jx)*(dLoc+dy(iy1)+Eps))
            vFRhs(jx,iy1,jz)=vFRhs(jx,iy1,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (Volcoarse+Eps)
            Grad=F/(F+Eps)*(pFine-pCoarse)/(dz(iz0+1)+dLoc+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0) &
               -Two*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz0)/(FW(jx,jy,iz0)+Eps)*(p(jx,jy,iz0+1,1)-p(jx,jy,iz0,1))/(dz(iz0+1)+dLoc+Eps)
            wFRhs(jx,jy,iz0)=wFRhs(jx,jy,iz0)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            Grad=F/(F+Eps)*(pCoarse-pFine)/(dLoc+dz(iz1)+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1) &
               -Two*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz1)/(FW(jx,jy,iz1)+Eps)*(p(jx,jy,iz1+1,1)-p(jx,jy,iz1,1))/(dz(iz1)+dLoc+Eps)
            wFRhs(jx,jy,iz1)=wFRhs(jx,jy,iz1)-Two*Grad
          END DO
        END DO
      END IF
    END IF
  END DO

END SUBROUTINE PGradComputeFFull

SUBROUTINE PGradComputeF1

  INTEGER :: ix,iy,iz,in,jx,jy,jz
  REAL(RealKind) :: Grad
  REAL(RealKind) :: F,VolFine,VolCoarse,pFine,pCoarse

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        Grad=FU(ix,iy,iz)*(p(ix+1,iy,iz,1)-p(ix,iy,iz,1))/(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)+Eps) 
        uFRhs(ix,iy,iz)=uFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        Grad=FV(ix,iy,iz)*(p(ix,iy+1,iz,1)-p(ix,iy,iz,1))/(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)+Eps)
        vFRhs(ix,iy,iz)=vFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Grad=FW(ix,iy,iz)*(p(ix,iy,iz+1,1)-p(ix,iy,iz,1))/(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)+Eps) 
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)-Two*Grad
      END DO
    END DO
  END DO
  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jz=jz0+1,jz1
            Grad=FU(ix0,jy,jz)*(p(ix0+1,jy,jz,1)-p(ix0,jy,jz,1))/(VolC(ix0+1,jy,jz)+VolC(ix0,jy,jz)+Eps) 
            uFRhs(ix0,jy,jz)=uFRhs(ix0,jy,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix1,jy,jz)*(p(ix1+1,jy,jz,1)-p(ix1,jy,jz,1))/(VolC(ix1,jy,jz)+VolC(ix1+1,jy,jz)+Eps) 
            uFRhs(ix1,jy,jz)=uFRhs(ix1,jy,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* & 
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy0,jz)*(p(jx,iy0+1,jz,1)-p(jx,iy0,jz,1))/(VolC(jx,iy0+1,jz)+VolC(jx,iy0,jz)+Eps)
            vFRhs(jx,iy0,jz)=vFRhs(jx,iy0,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            pFine= & 
               SUM(p(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1) &
                -Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy1,jz)*(p(jx,iy1+1,jz,1)-p(jx,iy1,jz,1))/(VolC(jx,iy1,jz)+VolC(jx,iy1+1,jz)+Eps)
            vFRhs(jx,iy1,jz)=vFRhs(jx,iy1,jz)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jx=jx0+1,jx1,IncrX
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (Volcoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0) &
               -Two*Grad
          END DO
        END DO
      ELSE
        DO jx=jx0+1,jx1
          DO jy=jy0+1,jy1
            Grad=FW(jx,jy,iz0)*(p(jx,jy,iz0+1,1)-p(jx,jy,iz0,1))/(VolC(jx,jy,iz0+1)+VolC(jx,jy,iz0)+Eps)
            wFRhs(jx,jy,iz0)=wFRhs(jx,jy,iz0)-Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jx=jx0+1,jx1,IncrX
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1) &
               -Two*Grad
          END DO
        END DO
      ELSE
        DO jx=jx0+1,jx1
          DO jy=jy0+1,jy1
            Grad=FW(jx,jy,iz1)*(p(jx,jy,iz1+1,1)-p(jx,jy,iz1,1))/(VolC(jx,jy,iz1)+VolC(jx,jy,iz1+1)+Eps)
            wFRhs(jx,jy,iz1)=wFRhs(jx,jy,iz1)-Two*Grad
          END DO
        END DO
      END IF
    END IF
  END DO

END SUBROUTINE PGradComputeF1

SUBROUTINE DivergenceDampCompute

  INTEGER :: ix,iy,iz,in,jx,jy,jz
  REAL(RealKind) :: Grad
  REAL(RealKind) :: F,VolFine,VolCoarse,pFine,pCoarse

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        Grad=FU(ix,iy,iz)*(p(ix+1,iy,iz,1)-p(ix,iy,iz,1))/(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)+Eps) 
        uFRhs(ix,iy,iz)=uFRhs(ix,iy,iz)+DivDampU*Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        Grad=FV(ix,iy,iz)*(p(ix,iy+1,iz,1)-p(ix,iy,iz,1))/(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)+Eps)
        vFRhs(ix,iy,iz)=vFRhs(ix,iy,iz)+DivDampV*Two*Grad
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Grad=FW(ix,iy,iz)*(p(ix,iy,iz+1,1)-p(ix,iy,iz,1))/(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)+Eps) 
        wFRhs(ix,iy,iz)=wFRhs(ix,iy,iz)+DivDampW*Two*Grad
      END DO
    END DO
  END DO
  DO in=1,AnzahlNachbar

    CALL Set(Nachbars(in))

    IF (Nachbars(in)%nType=='iw'.OR.Nachbars(in)%nType=='pw') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix0,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                +DivDampU*Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix0,jy,jz)*(p(ix0+1,jy,jz,1)-p(ix0,jy,jz,1))/(VolC(ix0+1,jy,jz)+VolC(ix0,jy,jz)+Eps) 
            uFRhs(ix0,jy,jz)=uFRhs(ix0,jy,jz)+DivDampU*Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ie'.OR.Nachbars(in)%nType=='pe') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jy=jy0+1,jy1,IncrY
            F=SUM(FU(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1,1)* &
                   VolC(ix1+1,jy:jy+IncrY-1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1)=uFRhs(ix1,jy:jy+IncrY-1,jz:jz+IncrZ-1) &
                +DivDampU*Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jy=jy0+1,jy1
            Grad=FU(ix1,jy,jz)*(p(ix1+1,jy,jz,1)-p(ix1,jy,jz,1))/(VolC(ix1,jy,jz)+VolC(ix1+1,jy,jz)+Eps) 
            uFRhs(ix1,jy,jz)=uFRhs(ix1,jy,jz)+DivDampU*Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='is'.OR.Nachbars(in)%nType=='ps') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1,1)* & 
                   VolC(jx:jx+IncrX-1,iy0+1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1) &
                +DivDampV*Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy0,jz)*(p(jx,iy0+1,jz,1)-p(jx,iy0,jz,1))/(VolC(jx,iy0+1,jz)+VolC(jx,iy0,jz)+Eps)
            vFRhs(jx,iy0,jz)=vFRhs(jx,iy0,jz)+DivDampV*Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='in'.OR.Nachbars(in)%nType=='pn') THEN
      IF (Refine>RefineNachbar) THEN
        DO jz=jz0+1,jz1,IncrZ
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FV(jx:jx+IncrX-1,iy0,jz:jz+IncrZ-1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))
            pFine= & 
               SUM(p(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1,1)* &
                   VolC(jx:jx+IncrX-1,iy1+1,jz:jz+IncrZ-1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1)=vFRhs(jx:jx+IncrX-1,iy1,jz:jz+IncrZ-1) &
                +DivDampV*Two*Grad
          END DO
        END DO
      ELSE
        DO jz=jz0+1,jz1
          DO jx=jx0+1,jx1
            Grad=FV(jx,iy1,jz)*(p(jx,iy1+1,jz,1)-p(jx,iy1,jz,1))/(VolC(jx,iy1,jz)+VolC(jx,iy1+1,jz)+Eps)
            vFRhs(jx,iy1,jz)=vFRhs(jx,iy1,jz)+DivDampV*Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='ib'.OR.Nachbars(in)%nType=='pb') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0+1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0))/ &
               (Volcoarse+Eps)
            Grad=F*(pFine-pCoarse)/(VolFine+VolCoarse+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz0) &
               +DivDampW*Two*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz0)*(p(jx,jy,iz0+1,1)-p(jx,jy,iz0,1))/(VolC(jx,jy,iz0+1)+VolC(jx,jy,iz0)+Eps)
            wFRhs(jx,jy,iz0)=wFRhs(jx,jy,iz0)+DivDampW*Two*Grad
          END DO
        END DO
      END IF
    END IF
    IF (Nachbars(in)%nType=='it'.OR.Nachbars(in)%nType=='pt') THEN
      IF (Refine>RefineNachbar) THEN
        DO jy=jy0+1,jy1,IncrY
          DO jx=jx0+1,jx1,IncrX
            F=SUM(FW(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            VolFine= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))
            pFine= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1))/ &
               (VolFine+Eps)
            VolCoarse= &
               SUM(VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))+Eps
            pCoarse= &
               SUM(p(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1,1)* &
                   VolC(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1+1))/ &
               (VolCoarse+Eps)
            Grad=F*(pCoarse-pFine)/(VolFine+VolCoarse+Eps)
            wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1)=wFRhs(jx:jx+IncrX-1,jy:jy+IncrY-1,iz1) &
               +DivDampW*Two*Grad
          END DO
        END DO
      ELSE
        DO jy=jy0+1,jy1
          DO jx=jx0+1,jx1
            Grad=FW(jx,jy,iz1)*(p(jx,jy,iz1+1,1)-p(jx,jy,iz1,1))/(VolC(jx,jy,iz1)+VolC(jx,jy,iz1+1)+Eps)
            wFRhs(jx,jy,iz1)=wFRhs(jx,jy,iz1)+DivDampW*Two*Grad
          END DO
        END DO
      END IF
    END IF
  END DO

END SUBROUTINE DivergenceDampCompute

SUBROUTINE TurbTke

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: FluxL,FluxR

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        FluxL=2.0d0/3.0d0*FU(ix-1,iy,iz)*tke(ix,iy,iz,1)
        uRhsR(ix-1,iy,iz,1)=uRhsR(ix-1,iy,iz,1)-FluxL
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)-FluxL
        FluxR=2.0d0/3.0d0*FU(ix,iy,iz)*tke(ix,iy,iz,1)
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+FluxR
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)+FluxR

        FluxL=2.0d0/3.0d0*FV(ix,iy-1,iz)*tke(ix,iy,iz,1)
        vRhsR(ix,iy-1,iz,1)=vRhsR(ix,iy-1,iz,1)-FluxL
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)-FluxL
        FluxR=2.0d0/3.0d0*FV(ix,iy,iz)*tke(ix,iy,iz,1)
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)+FluxR
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)+FluxR

        FluxL=2.0d0/3.0d0*FW(ix,iy,iz-1)*tke(ix,iy,iz,1)
        wRhsR(ix,iy,iz-1,1)=wRhsR(ix,iy,iz-1,1)-FluxL
        wRhsL(ix,iy,iz,1)=wRhsL(ix,iy,iz,1)-FluxL
        FluxR=2.0d0/3.0d0*FW(ix,iy,iz)*tke(ix,iy,iz,1)
        wRhsR(ix,iy,iz,1)=wRhsR(ix,iy,iz,1)+FluxR
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)+FluxR
      END DO
    END DO
  END DO
  IF (TypeW(1:1)=='o') THEN
    ix=ix0
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        FluxR=2.0d0/3.0d0*FU(ix,iy,iz)*tke(ix,iy,iz,1)
        uRhsL(ix+1,iy,iz,1)=uRhsL(ix+1,iy,iz,1)+FluxR
        uRhsR(ix,iy,iz,1)=Zero
      END DO
    END DO
  END IF
  IF (TypeE(1:1)=='o') THEN
    ix=ix1+1
    DO iz=iz0+1,iz1
      DO iy=iy0+1,iy1
        FluxL=2.0d0/3.0d0*FU(ix-1,iy,iz)*tke(ix,iy,iz,1)
        uRhsR(ix-1,iy,iz,1)=uRhsR(ix-1,iy,iz,1)-FluxL
        uRhsL(ix,iy,iz,1)=Zero
      END DO
    END DO
  END IF
  IF (TypeS(1:1)=='o') THEN
    iy=iy0
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        FluxR=2.0d0/3.0d0*FV(ix,iy,iz)*tke(ix,iy,iz,1)
        vRhsL(ix,iy+1,iz,1)=vRhsL(ix,iy+1,iz,1)+FluxR
        vRhsR(ix,iy,iz,1)=Zero
      END DO
    END DO
  END IF
  IF (TypeN(1:1)=='o') THEN
    iy=iy1+1
    DO iz=iz0+1,iz1
      DO ix=ix0+1,ix1
        FluxL=2.0d0/3.0d0*FV(ix,iy-1,iz)*tke(ix,iy,iz,1)
        vRhsR(ix,iy-1,iz,1)=vRhsR(ix,iy-1,iz,1)-FluxL
        vRhsL(ix,iy,iz,1)=Zero
      END DO
    END DO
  END IF

  IF (TypeB(1:1)=='o') THEN
    iz=iz0
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        FluxR=2.0d0/3.0d0*FW(ix,iy,iz)*tke(ix,iy,iz,1)
        wRhsL(ix,iy,iz+1,1)=wRhsL(ix,iy,iz+1,1)+FluxR
        wRhsR(ix,iy,iz,1)=Zero
      END DO
    END DO
  END IF
  IF (TypeT(1:1)=='o') THEN
    iz=iz1+1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        FluxL=2.0d0/3.0d0*FW(ix,iy,iz-1)*tke(ix,iy,iz,1)
        wRhsR(ix,iy,iz-1,1)=wRhsR(ix,iy,iz-1,1)-FluxL
        wRhsL(ix,iy,iz,1)=Zero
      END DO
    END DO
  END IF

END SUBROUTINE TurbTke

SUBROUTINE DivCompute

  INTEGER :: ix,iy,iz

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoRhs(ix,iy,iz,1)=RhoRhs(ix,iy,iz,1)- &
                (uF(ix,iy,iz)*FU(ix,iy,iz)-uF(ix-1,iy,iz)*FU(ix-1,iy,iz) &
                +vF(ix,iy,iz)*FV(ix,iy,iz)-vF(ix,iy-1,iz)*FV(ix,iy-1,iz) &
                +wF(ix,iy,iz)*FW(ix,iy,iz)-wF(ix,iy,iz-1)*FW(ix,iy,iz-1))
      END DO
    END DO
  END DO

END SUBROUTINE DivCompute


SUBROUTINE DivPreCompute

  INTEGER :: ix,iy,iz

  REAL(RealKind) :: DivLoc(ix0+1:ix1,iy0+1:iy1,iz0+1:iz1)
  REAL(RealKind) :: PreFac,FluxLoc

  DivLoc=Zero

  ix=ix0
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      FluxLoc=uf(ix,iy,iz)*FU(ix,iy,iz)*(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)) &
              /(VolC(ix+1,iy,iz)*Rho(ix+1,iy,iz,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
      DivLoc(ix+1,iy,iz)=DivLoc(ix+1,iy,iz)-FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        FluxLoc=uf(ix,iy,iz)*FU(ix,iy,iz)*(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)) &
                /(VolC(ix+1,iy,iz)*Rho(ix+1,iy,iz,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        DivLoc(ix+1,iy,iz)=DivLoc(ix+1,iy,iz)-FluxLoc
        DivLoc(ix,iy,iz)=DivLoc(ix,iy,iz)+FluxLoc
      END DO
    END DO
  END DO
  ix=ix1
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      FluxLoc=uf(ix,iy,iz)*FU(ix,iy,iz)*(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)) &
              /(VolC(ix+1,iy,iz)*Rho(ix+1,iy,iz,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
      DivLoc(ix,iy,iz)=DivLoc(ix,iy,iz)+FluxLoc
    END DO
  END DO
 
  iy=iy0
  DO iz=iz0+1,iz1
    DO ix=ix0+1,ix1
      FluxLoc=vf(ix,iy,iz)*FV(ix,iy,iz)*(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)) &
              /(VolC(ix,iy+1,iz)*Rho(ix,iy+1,iz,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
      DivLoc(ix,iy+1,iz)=DivLoc(ix,iy+1,iz)-FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        FluxLoc=vf(ix,iy,iz)*FV(ix,iy,iz)*(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)) &
                /(VolC(ix,iy+1,iz)*Rho(ix,iy+1,iz,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        DivLoc(ix,iy+1,iz)=DivLoc(ix,iy+1,iz)-FluxLoc
        DivLoc(ix,iy,iz)=DivLoc(ix,iy,iz)+FluxLoc
      END DO
    END DO
  END DO
  iy=iy1
  DO iz=iz0+1,iz1
    DO ix=ix0+1,ix1
      FluxLoc=vf(ix,iy,iz)*FV(ix,iy,iz)*(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)) &
              /(VolC(ix,iy+1,iz)*Rho(ix,iy+1,iz,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
      DivLoc(ix,iy,iz)=DivLoc(ix,iy,iz)+FluxLoc
    END DO
  END DO
 
  iz=iz0
  DO iy=iy0+1,iy1
    DO ix=ix0+1,ix1
      FluxLoc=wf(ix,iy,iz)*FW(ix,iy,iz)*(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)) & 
              /(VolC(ix,iy,iz+1)*Rho(ix,iy,iz+1,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
      DivLoc(ix,iy,iz+1)=DivLoc(ix,iy,iz+1)-FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        FluxLoc=wf(ix,iy,iz)*FW(ix,iy,iz)*(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)) & 
                /(VolC(ix,iy,iz+1)*Rho(ix,iy,iz+1,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        DivLoc(ix,iy,iz+1)=DivLoc(ix,iy,iz+1)-FluxLoc
        DivLoc(ix,iy,iz)=DivLoc(ix,iy,iz)+FluxLoc
      END DO
    END DO
  END DO
  iz=iz1
  DO iy=iy0+1,iy1
    DO ix=ix0+1,ix1
      FluxLoc=wf(ix,iy,iz)*FW(ix,iy,iz)*(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)) & 
              /(VolC(ix,iy,iz+1)*Rho(ix,iy,iz+1,1)+VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
      DivLoc(ix,iy,iz)=DivLoc(ix,iy,iz)+FluxLoc
    END DO
  END DO
 
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        PreFac=Sound(ix,iy,iz,1)
        thRhs(ix,iy,iz,1)=thRhs(ix,iy,iz,1)-DivLoc(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)*PreFac  
      END DO
    END DO
  END DO

END SUBROUTINE DivPreCompute

SUBROUTINE DivEnCompute

  INTEGER :: ix,iy,iz

  REAL(RealKind) :: FluxLoc,Fac

  ix=ix0
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Fac=PreFace(p(ix,iy,iz,1),p(ix+1,iy,iz,1),Rho(ix,iy,iz,1)     &
                 ,Rho(ix+1,iy,iz,1),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
      FluxLoc=uFace(uf(ix,iy,iz),Rho(ix,iy,iz,1),Rho(ix+1,iy,iz,1) &
                   ,VolC(ix,iy,iz),VolC(ix+1,iy,iz)) &
             *FU(ix,iy,iz)*Fac
      f(ix+1,iy,iz,1)=f(ix+1,iy,iz,1)+FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        Fac=PreFace(p(ix,iy,iz,1),p(ix+1,iy,iz,1),Rho(ix,iy,iz,1)     &
                   ,Rho(ix+1,iy,iz,1),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        FluxLoc=uFace(uf(ix,iy,iz),Rho(ix,iy,iz,1),Rho(ix+1,iy,iz,1) &
                     ,VolC(ix,iy,iz),VolC(ix+1,iy,iz)) &
               *FU(ix,iy,iz)*Fac
        f(ix+1,iy,iz,1)=f(ix+1,iy,iz,1)+FluxLoc
        f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
      END DO
    END DO
  END DO
  ix=ix1
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Fac=PreFace(p(ix,iy,iz,1),p(ix+1,iy,iz,1),Rho(ix,iy,iz,1)     &
                 ,Rho(ix+1,iy,iz,1),VolC(ix,iy,iz),VolC(ix+1,iy,iz))
      FluxLoc=uFace(uf(ix,iy,iz),Rho(ix,iy,iz,1),Rho(ix+1,iy,iz,1) &
                   ,VolC(ix,iy,iz),VolC(ix+1,iy,iz)) &
             *FU(ix,iy,iz)*Fac
      f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
    END DO
  END DO
 
  iy=iy0
  DO iz=iz0+1,iz1
    DO ix=ix0+1,ix1
      Fac=PreFace(p(ix,iy,iz,1),p(ix,iy+1,iz,1),Rho(ix,iy,iz,1)     &
                 ,Rho(ix,iy+1,iz,1),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
      FluxLoc=vf(ix,iy,iz)*FV(ix,iy,iz)*Fac
      f(ix,iy+1,iz,1)=f(ix,iy+1,iz,1)+FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        Fac=PreFace(p(ix,iy,iz,1),p(ix,iy+1,iz,1),Rho(ix,iy,iz,1)     &
                   ,Rho(ix,iy+1,iz,1),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        FluxLoc=vf(ix,iy,iz)*FV(ix,iy,iz)*Fac
        f(ix,iy+1,iz,1)=f(ix,iy+1,iz,1)+FluxLoc
        f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
      END DO
    END DO
  END DO
  iy=iy1
  DO iz=iz0+1,iz1
    DO ix=ix0+1,ix1
      Fac=PreFace(p(ix,iy,iz,1),p(ix,iy+1,iz,1),Rho(ix,iy,iz,1)     &
                 ,Rho(ix,iy+1,iz,1),VolC(ix,iy,iz),VolC(ix,iy+1,iz))
      FluxLoc=vf(ix,iy,iz)*FV(ix,iy,iz)*Fac
      f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
    END DO
  END DO
 
  iz=iz0
  DO iy=iy0+1,iy1
    DO ix=ix0+1,ix1
      Fac=PreFace(p(ix,iy,iz,1),p(ix,iy,iz+1,1),Rho(ix,iy,iz,1)     &
                 ,Rho(ix,iy,iz+1,1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
      FluxLoc=wf(ix,iy,iz)*FW(ix,iy,iz)*Fac
      f(ix,iy,iz+1,1)=f(ix,iy,iz+1,1)+FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Fac=PreFace(p(ix,iy,iz,1),p(ix,iy,iz+1,1),Rho(ix,iy,iz,1)     &
                   ,Rho(ix,iy,iz+1,1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        FluxLoc=wf(ix,iy,iz)*FW(ix,iy,iz)*Fac
        f(ix,iy,iz+1,1)=f(ix,iy,iz+1,1)+FluxLoc
        f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
      END DO
    END DO
  END DO
  iz=iz1
  DO iy=iy0+1,iy1
    DO ix=ix0+1,ix1
      Fac=PreFace(p(ix,iy,iz,1),p(ix,iy,iz+1,1),Rho(ix,iy,iz,1)     &
                 ,Rho(ix,iy,iz+1,1),VolC(ix,iy,iz),VolC(ix,iy,iz+1))
      FluxLoc=wf(ix,iy,iz)*FW(ix,iy,iz)*Fac
      f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
    END DO
  END DO
 
END SUBROUTINE DivEnCompute

FUNCTION uFace(uF,RhoL,RhoR,VolL,VolR)
  REAL(RealKind) :: uFace
  REAL(RealKind) :: uF,RhoL,RhoR,VolL,VolR

  uFace=uF

END FUNCTION uFace

FUNCTION PreFace(pL,pR,RhoL,RhoR,VolL,VolR)

  REAL(RealKind) :: PreFace
  REAL(RealKind) :: pL,pR,RhoL,RhoR,VolL,VolR

  PreFace=(pL/(RhoL+Eps)*RhoR+pR/(RhoR+Eps)*RhoL)/(RhoL+RhoR+Eps)

END FUNCTION PreFace  

SUBROUTINE DivWeightCompute

  INTEGER :: ix,iy,iz

  REAL(RealKind) :: FluxLoc,Fac

  ix=ix0
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Fac=WFace(Weight(ix,iy,iz,1),Weight(ix+1,iy,iz,1)     &
               ,Rho(ix,iy,iz,1),Rho(ix+1,iy,iz,1)     &
               ,VolC(ix,iy,iz),VolC(ix+1,iy,iz))
      FluxLoc=uF(ix,iy,iz)*FU(Ix,iy,iz)*Fac
      f(ix+1,iy,iz,1)=f(ix+1,iy,iz,1)+FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1-1
        Fac=WFace(Weight(ix,iy,iz,1),Weight(ix+1,iy,iz,1)     &
                 ,Rho(ix,iy,iz,1),Rho(ix+1,iy,iz,1)     &
                 ,VolC(ix,iy,iz),VolC(ix+1,iy,iz))
        FluxLoc=uF(ix,iy,iz)*FU(Ix,iy,iz)*Fac
        f(ix+1,iy,iz,1)=f(ix+1,iy,iz,1)+FluxLoc
        f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
      END DO
    END DO
  END DO
  ix=ix1
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Fac=WFace(Weight(ix,iy,iz,1),Weight(ix+1,iy,iz,1)     &
               ,Rho(ix,iy,iz,1),Rho(ix+1,iy,iz,1)     &
               ,VolC(ix,iy,iz),VolC(ix+1,iy,iz))
      FluxLoc=uF(ix,iy,iz)*FU(Ix,iy,iz)*Fac
      f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
    END DO
  END DO
 
  iy=iy0
  DO iz=iz0+1,iz1
    DO ix=ix0+1,ix1
      Fac=WFace(Weight(ix,iy,iz,1),Weight(ix,iy+1,iz,1)     &
               ,Rho(ix,iy,iz,1),Rho(ix,iy+1,iz,1)     &
               ,VolC(ix,iy,iz),VolC(ix,iy+1,iz))
      FluxLoc=vF(ix,iy,iz)*FV(ix,iy,iz)*Fac
      f(ix,iy+1,iz,1)=f(ix,iy+1,iz,1)+FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1-1
      DO ix=ix0+1,ix1
        Fac=WFace(Weight(ix,iy,iz,1),Weight(ix,iy+1,iz,1)     &
                 ,Rho(ix,iy,iz,1),Rho(ix,iy+1,iz,1)     &
                 ,VolC(ix,iy,iz),VolC(ix,iy+1,iz))
        FluxLoc=vF(ix,iy,iz)*FV(ix,iy,iz)*Fac
        f(ix,iy+1,iz,1)=f(ix,iy+1,iz,1)+FluxLoc
        f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
      END DO
    END DO
  END DO
  iy=iy1
  DO iz=iz0+1,iz1
    DO ix=ix0+1,ix1
      Fac=WFace(Weight(ix,iy,iz,1),Weight(ix,iy+1,iz,1)     &
               ,Rho(ix,iy,iz,1),Rho(ix,iy+1,iz,1)     &
               ,VolC(ix,iy,iz),VolC(ix,iy+1,iz))
      FluxLoc=vF(ix,iy,iz)*FV(ix,iy,iz)*Fac
      f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
    END DO
  END DO
 
  iz=iz0
  DO iy=iy0+1,iy1
    DO ix=ix0+1,ix1
      Fac=WFace(Weight(ix,iy,iz,1),Weight(ix,iy,iz+1,1)     &
               ,Rho(ix,iy,iz,1),Rho(ix,iy,iz+1,1)     &
               ,VolC(ix,iy,iz),VolC(ix,iy,iz+1))
      FluxLoc=wF(ix,iy,iz)*FW(ix,iy,iz)*Fac
      f(ix,iy,iz+1,1)=f(ix,iy,iz+1,1)+FluxLoc
    END DO
  END DO
  DO iz=iz0+1,iz1-1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Fac=WFace(Weight(ix,iy,iz,1),Weight(ix,iy,iz+1,1)     &
                 ,Rho(ix,iy,iz,1),Rho(ix,iy,iz+1,1)     &
                 ,VolC(ix,iy,iz),VolC(ix,iy,iz+1))
        FluxLoc=wF(ix,iy,iz)*FW(ix,iy,iz)*Fac
        f(ix,iy,iz+1,1)=f(ix,iy,iz+1,1)+FluxLoc
        f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
      END DO
    END DO
  END DO
  iz=iz1
  DO iy=iy0+1,iy1
    DO ix=ix0+1,ix1
      Fac=WFace(Weight(ix,iy,iz,1),Weight(ix,iy,iz+1,1)     &
               ,Rho(ix,iy,iz,1),Rho(ix,iy,iz+1,1)     &
               ,VolC(ix,iy,iz),VolC(ix,iy,iz+1))
      FluxLoc=wF(ix,iy,iz)*FW(ix,iy,iz)*Fac
      f(ix,iy,iz,1)=f(ix,iy,iz,1)-FluxLoc
    END DO
  END DO
 
END SUBROUTINE DivWeightCompute


FUNCTION WFace(WeiL,WeiR,RhoL,RhoR,VolL,VolR)

  REAL(RealKind) :: WFace
  REAL(RealKind) :: WeiL,WeiR,RhoL,RhoR,VolL,VolR

  WFace=(WeiL/(RhoL+Eps)*VolL+WeiR/(RhoR+Eps)*VolR)/(VolL+VolR+Eps)

END FUNCTION WFace  


SUBROUTINE SoundCompute

  INTEGER :: ix,iy,iz

  REAL(RealKind) :: RhoLoc,RhoDLoc,RhoVLoc,RhoLLoc
  REAL(RealKind) :: qdLoc,qvLoc,qlLoc,Cvml
  REAL(RealKind) :: TLoc,eLoc,pLoc,PotEn,KinEnergy,SoSLoc,SoSLoc1,PreFac
  REAL(RealKind) :: DpDRho,DpDe,DpDRhoV,DpDRhoL

  SELECT CASE (ThetaKind)
    CASE ('PreEn')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            pLoc=Th(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc
            TLoc=pLoc/(RhoDLoc*Rd+RhoVLoc*Rv+Eps)
            Cvml=RhoDLoc*Cvd+RhoVLoc*Cvv+RhoLLoc*Cpl+Eps
            eLoc=(Cvml*TLoc+RhoVLoc*L00)/(RhoLoc+Eps)
            DpDRho=Rd*(RhoLoc*eLoc-RhoVLoc*L00)/Cvml &
                   -Cvd*(RhoLoc*eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2 &
                   +eLoc*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml
            DpDe=RhoLoc*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml
            DpDRhoV=(Rv-Rd)*(RhoLoc*eLoc-RhoVLoc*L00)/Cvml &
                    -L00*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml &
                    -(Cvv-Cvd)*(RhoLoc*eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2 
            DpDRhoL=-Rd*(RhoLoc*eLoc-RhoVLoc*L00)/Cvml &
                    -(Cpl-Cvd)*(RhoLoc*eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2
            SoSLoc=DpDRho+pLoc/(RhoLoc+Eps)**2*DpDe+RhoVLoc/(RhoLoc+Eps)*DpDRhoV+RhoLLoc/(RhoLoc+Eps)*DpDRhoL 
            PreFac=RhoLoc*SoSLoc
            Sound(ix,iy,iz,1)=PreFac
          END DO
        END DO
      END DO
    CASE('Density')  
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            pLoc=p(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc
            TLoc=T(ix,iy,iz,1)
            Cvml=RhoDLoc*Cvd+RhoVLoc*Cvv+RhoLLoc*Cpl+Eps
            eLoc=(Cvml*TLoc+RhoVLoc*L00)/(RhoLoc+Eps)
            DpDRho=Rd*(RhoLoc*eLoc-RhoVLoc*L00)/Cvml &
                   -Cvd*(RhoLoc*eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2 &
                   +eLoc*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml
            DpDe=RhoLoc*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml
            DpDRhoV=(Rv-Rd)*(RhoLoc*eLoc-RhoVLoc*L00)/Cvml &
                    -L00*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml &
                    -(Cvv-Cvd)*(RhoLoc*eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2 
            DpDRhoL=-Rd*(RhoLoc*eLoc-RhoVLoc*L00)/Cvml &
                    -(Cpl-Cvd)*(RhoLoc*eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2
            SoSLoc=DpDRho+pLoc/(RhoLoc+Eps)**2*DpDe+RhoVLoc/(RhoLoc+Eps)*DpDRhoV+RhoLLoc/(RhoLoc+Eps)*DpDRhoL 
            PreFac=RhoLoc*SoSLoc
            Sound(ix,iy,iz,1)=PreFac
          END DO
        END DO
      END DO
    CASE ('Exner')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            Sound(ix,iy,iz,1)=Th(ix,iy,iz,1)*Rd/Cvd  
          END DO
        END DO
      END DO
  END SELECT

END SUBROUTINE SoundCompute


SUBROUTINE DivFCompute

  INTEGER :: ix,iy,iz

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        DivC(ix,iy,iz,1)= &
                (uF(ix,iy,iz)*FU(ix,iy,iz)-uF(ix-1,iy,iz)*FU(ix-1,iy,iz) &
                +vF(ix,iy,iz)*FV(ix,iy,iz)-vF(ix,iy-1,iz)*FV(ix,iy-1,iz) &
                +wF(ix,iy,iz)*FW(ix,iy,iz)-wF(ix,iy,iz-1)*FW(ix,iy,iz-1))/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO

END SUBROUTINE DivFCompute


SUBROUTINE DivScalarCompute(FallF)

  INTERFACE
    FUNCTION FallF(qc)
      USE Kind_Mod
      REAL(RealKind) :: FallF,qc
    END FUNCTION FallF
  END INTERFACE

  OPTIONAL :: FallF

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Flux(SIZE(cFU,4)),FacLoc
  REAL(RealKind) :: wFLoc
  REAL(RealKind) :: RhoLF

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0,ix1
        Flux=FU(ix,iy,iz)*cFU(ix,iy,iz,:)*uF(ix,iy,iz) 
        f(ix,iy,iz,:)=f(ix,iy,iz,:)-Flux 
        f(ix+1,iy,iz,:)=f(ix+1,iy,iz,:)+Flux 
      END DO
    END DO
  END DO
  
  DO iz=iz0+1,iz1
    DO iy=iy0,iy1
      DO ix=ix0+1,ix1
        Flux=FV(ix,iy,iz)*cFV(ix,iy,iz,:)*vF(ix,iy,iz) 
        f(ix,iy,iz,:)=f(ix,iy,iz,:)-Flux 
        f(ix,iy+1,iz,:)=f(ix,iy+1,iz,:)+Flux 
      END DO
    END DO
  END DO

  IF (PRESENT(FallF)) THEN
    DO iz=iz0,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          RhoLF=CellToFaceVol(RhoR(ix,iy,iz,1),RhoR(ix,iy,iz+1,1) &
                             ,VolC(ix,iy,iz),VolC(ix,iy,iz+1))
          vFall=FallF(RhoLF)
          wFLoc=wF(ix,iy,iz)+CellToFaceVol(Rho(ix,iy,iz,1),Rho(ix,iy,iz+1,1) &
                                          ,VolC(ix,iy,iz),VolC(ix,iy,iz+1)) &
                            *(vFall+vSub(zP(iz)))
          Flux=FW(ix,iy,iz)*cFW(ix,iy,iz,:)*wFLoc
          f(ix,iy,iz,:)=f(ix,iy,iz,:)-Flux 
          f(ix,iy,iz+1,:)=f(ix,iy,iz+1,:)+Flux 
        END DO
      END DO
    END DO
  ELSE  
    DO iz=iz0,iz1
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          wFLoc=wF(ix,iy,iz)+CellToFaceVol(Rho(ix,iy,iz,1),Rho(ix,iy,iz+1,1) &
                                          ,VolC(ix,iy,iz),VolC(ix,iy,iz+1)) &
                            *(vFall+vSub(zP(iz)))
          Flux=FW(ix,iy,iz)*cFW(ix,iy,iz,:)*wFLoc
          f(ix,iy,iz,:)=f(ix,iy,iz,:)-Flux 
          f(ix,iy,iz+1,:)=f(ix,iy,iz+1,:)+Flux 
        END DO
      END DO
    END DO
  END IF
END SUBROUTINE DivScalarCompute

SUBROUTINE KinEnCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc
  REAL(RealKind) :: uFL,uFR
  REAL(RealKind) :: vFL,vFR
  REAL(RealKind) :: wFL,wFR
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        uFL=uF(ix-1,iy,iz)
        uFR=uF(ix,iy,iz)
        vFL=vF(ix,iy-1,iz)
        vFR=vF(ix,iy,iz)
        wFL=wF(ix,iy,iz-1)
        wFR=wF(ix,iy,iz)
        RhoLoc=Rho(ix,iy,iz,1)
        KinEn(ix,iy,iz,1)= &  ! ohne Rho (KinEn=v^2/2)
                           0.25d0*(uFL*uFL+uFR*uFR+vFL*vFL+vFR*vFR+wFL*wFL+wFR*wFR) &
                           /(RhoLoc+Eps)/(RhoLoc+Eps)
      END DO
    END DO
  END DO

END SUBROUTINE KinEnCompute 

SUBROUTINE KinEnCompute2

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc
  REAL(RealKind) :: uFL,uFR
  REAL(RealKind) :: vFL,vFR
  REAL(RealKind) :: wFL,wFR
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        uFL=uF(ix-1,iy,iz)*(VolC(ix-1,iy,iz)+VolC(ix,iy,iz)) &
                          /(VolC(ix-1,iy,iz)*Rho(ix-1,iy,iz,1) &
                           +VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        uFR=uF(ix,iy,iz)*(VolC(ix+1,iy,iz)+VolC(ix,iy,iz)) &
                          /(VolC(ix+1,iy,iz)*Rho(ix+1,iy,iz,1) &
                           +VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        vFL=vF(ix,iy-1,iz)*(VolC(ix,iy-1,iz)+VolC(ix,iy,iz)) &
                          /(VolC(ix,iy-1,iz)*Rho(ix,iy-1,iz,1) &
                           +VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        vFR=vF(ix,iy,iz)*(VolC(ix,iy+1,iz)+VolC(ix,iy,iz)) &
                          /(VolC(ix,iy+1,iz)*Rho(ix,iy+1,iz,1) &
                           +VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        wFL=wF(ix,iy,iz-1)*(VolC(ix,iy,iz-1)+VolC(ix,iy,iz)) &
                          /(VolC(ix,iy,iz-1)*Rho(ix,iy,iz-1,1) &
                           +VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        wFR=wF(ix,iy,iz)*(VolC(ix,iy,iz+1)+VolC(ix,iy,iz)) &
                          /(VolC(ix,iy,iz+1)*Rho(ix,iy,iz+1,1) &
                           +VolC(ix,iy,iz)*Rho(ix,iy,iz,1)+Eps)
        RhoLoc=Rho(ix,iy,iz,1)
        KinEn(ix,iy,iz,1)= &  ! ohne Rho (KinEn=v^2/2)
                           0.25d0*(uFL*uFL+uFR*uFR+vFL*vFL+vFR*vFR+wFL*wFL+wFR*wFR)
        KinEn(ix,iy,iz,1)= &  ! ohne Rho (KinEn=v^2/2)
                           0.125d0*(uFL+uFR)**2.0d0+(vFL+vFR)**2.0d0+(wFL+wFR)*2.0d0
      END DO
    END DO
  END DO

END SUBROUTINE KinEnCompute2 

SUBROUTINE KinEnCompute3

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc
  REAL(RealKind) :: uFL,uFR
  REAL(RealKind) :: vFL,vFR
  REAL(RealKind) :: wFL,wFR
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        uFL=uF(ix-1,iy,iz)
        uFR=uF(ix,iy,iz)
        vFL=vF(ix,iy-1,iz)
        vFR=vF(ix,iy,iz)
        wFL=wF(ix,iy,iz-1)
        wFR=wF(ix,iy,iz)
        RhoLoc=Rho(ix,iy,iz,1)
        KinEn(ix,iy,iz,1)=0.125d0*((uFL+uFR)**2.0d0+(vFL+vFR)**2.0d0+(wFL+wFR)**2.0d0)/(RhoLoc+Eps)**2.0d0
      END DO
    END DO
  END DO

END SUBROUTINE KinEnCompute3 

SUBROUTINE KinEnCompute4

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: uFLS,vFLS,wFLS
  REAL(RealKind) :: uFRS,vFRS,wFRS
  REAL(RealKind) :: Temp
  REAL(RealKind) :: KinV(ix0:ix1,iy0:iy1,iz0:iz1)
  REAL(RealKind) :: VolNode(ix0:ix1,iy0:iy1,iz0:iz1)

  KinV=0.0d0
  VoLNode=0.0d0
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=Two*uF(ix-1,iy,iz)/(Rho(ix-1,iy,iz,1)+Rho(ix,iy,iz,1)+Eps)
        uFLS=Temp*Temp
        Temp=Two*uF(ix,iy,iz)/(Rho(ix+1,iy,iz,1)+Rho(ix,iy,iz,1)+Eps)
        uFRS=Temp*Temp
        Temp=Two*vF(ix,iy-1,iz)/(Rho(ix,iy-1,iz,1)+Rho(ix,iy,iz,1)+Eps)
        vFLS=Temp*Temp
        Temp=Two*vF(ix,iy,iz)/(Rho(ix,iy+1,iz,1)+Rho(ix,iy,iz,1)+Eps)
        vFRS=Temp*Temp
        Temp=Two*wF(ix,iy,iz-1)/(Rho(ix,iy,iz-1,1)+Rho(ix,iy,iz,1)+Eps)
        wFLS=Temp*Temp
        Temp=Two*wF(ix,iy,iz)/(Rho(ix,iy,iz+1,1)+Rho(ix,iy,iz,1)+Eps)
        wFRS=Temp*Temp
        KinV(ix-1,iy-1,iz-1)=KinV(ix-1,iy-1,iz-1)+VolC(ix,iy,iz)*(uFLS+vFLS+wFLS) 
        KinV(ix  ,iy-1,iz-1)=KinV(ix  ,iy-1,iz-1)+VolC(ix,iy,iz)*(uFRS+vFLS+wFLS) 
        KinV(ix-1,iy  ,iz-1)=KinV(ix-1,iy  ,iz-1)+VolC(ix,iy,iz)*(uFLS+vFRS+wFLS) 
        KinV(ix-1,iy-1,iz  )=KinV(ix-1,iy-1,iz  )+VolC(ix,iy,iz)*(uFLS+vFLS+wFRS) 
        KinV(ix-1,iy  ,iz  )=KinV(ix-1,iy  ,iz  )+VolC(ix,iy,iz)*(uFLS+vFRS+wFRS) 
        KinV(ix  ,iy-1,iz  )=KinV(ix  ,iy-1,iz  )+VolC(ix,iy,iz)*(uFRS+vFLS+wFRS) 
        KinV(ix  ,iy  ,iz-1)=KinV(ix  ,iy  ,iz-1)+VolC(ix,iy,iz)*(uFRS+vFRS+wFLS) 
        KinV(ix  ,iy  ,iz  )=KinV(ix  ,iy  ,iz  )+VolC(ix,iy,iz)*(uFRS+vFRS+wFRS) 
        VolNode(ix-1,iy-1,iz-1)=VolNode(ix-1,iy-1,iz-1)+VolC(ix,iy,iz)
        VolNode(ix  ,iy-1,iz-1)=VolNode(ix  ,iy-1,iz-1)+VolC(ix,iy,iz)
        VolNode(ix-1,iy  ,iz-1)=VolNode(ix-1,iy  ,iz-1)+VolC(ix,iy,iz)
        VolNode(ix-1,iy-1,iz  )=VolNode(ix-1,iy-1,iz  )+VolC(ix,iy,iz)
        VolNode(ix-1,iy  ,iz  )=VolNode(ix-1,iy  ,iz  )+VolC(ix,iy,iz)
        VolNode(ix  ,iy-1,iz  )=VolNode(ix  ,iy-1,iz  )+VolC(ix,iy,iz)
        VolNode(ix  ,iy  ,iz-1)=VolNode(ix  ,iy  ,iz-1)+VolC(ix,iy,iz)
        VolNode(ix  ,iy  ,iz  )=VolNode(ix  ,iy  ,iz  )+VolC(ix,iy,iz)
      END DO
    END DO
  END DO
  KinV=KinV/(VolNode+Eps)
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
         KinEn(ix,iy,iz,1)=1.0d0/8.0d0*( &
                           KinV(ix-1,iy-1,iz-1) &
                          +KinV(ix  ,iy-1,iz-1) &
                          +KinV(ix-1,iy  ,iz-1) &
                          +KinV(ix-1,iy-1,iz  ) &
                          +KinV(ix  ,iy  ,iz-1) &
                          +KinV(ix  ,iy-1,iz  ) &
                          +KinV(ix-1,iy  ,iz  ) &
                          +KinV(ix  ,iy  ,iz  )) 
      END DO
    END DO
  END DO

END SUBROUTINE KinEnCompute4 

SUBROUTINE AbsTPreCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Rm,Cpml,KappaLoc
  REAL(RealKind) :: RhoLoc,RhoVLoc,RhoLLoc,RhoDLoc
  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=Rho(ix,iy,iz,1)
        RhoVLoc=RhoV(ix,iy,iz,1)
        RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
        RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
        Rm=Rd*RhoDLoc+Rv*RhoVLoc
        Cpml=Cpd*RhoDLoc+Cpv*RhoVLoc+Cpl*RhoLLoc
        KappaLoc=Rm/Cpml
        T(ix,iy,iz,1)=(Rd*Th(ix,iy,iz,1)/p0**KappaLoc)**(One/(One-KappaLoc))/Rm
        p(ix,iy,iz,1)=Rm*T(ix,iy,iz,1)
      END DO
    END DO
  END DO
END SUBROUTINE AbsTPreCompute

SUBROUTINE AbsTCompute(TotalEn,RhoLocEn)

  INTEGER :: ix,iy,iz
  REAL(RealKind), OPTIONAL :: TotalEn,RhoLocEn
  REAL(RealKind) :: ThLoc,RhoLoc,RhoVLoc,RhoLLoc,RhoDLoc,TLoc
  REAL(RealKind) :: TLoc1
  REAL(RealKind) :: Rm,Cpml,KappaLoc,Cp_eff
  REAL(RealKind) :: Acc,NewtonError,NewtonFunc,AbsT

  SELECT CASE(ThetaKind)
    CASE('Density')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
            Rm=Rd*RhoDLoc+Rv*RhoVLoc
            Cpml=Cpd*RhoDLoc+Cpv*RhoVLoc+Cpl*RhoLLoc
            KappaLoc=Rm/Cpml
            T(ix,iy,iz,1)=(Rd*Th(ix,iy,iz,1)/p0**KappaLoc)**(One/(One-KappaLoc))/Rm
          END DO
        END DO
      END DO
    CASE('Equiv')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
            ThLoc=Th(ix,iy,iz,1)/(RhoLoc+Eps)
            Rm=Rd*RhoDLoc+Rv*RhoVLoc
            Cpml=Cpd*RhoDLoc+Cpv*RhoVLoc+Cpl*RhoLLoc
            TLoc=T(ix,iy,iz,1)
            CALL AbsTNewton(TLoc,ThLoc,RhoDLoc,RhoVLoc,RhoLLoc)
            T(ix,iy,iz,1)=TLoc
          END DO
        END DO
      END DO
    CASE('Energy')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
            TLoc=(Th(ix,iy,iz,1) &
                   -RhoLoc*KinEn(ix,iy,iz,1) &
                   -RhoLoc*Half*(zP(iz-1)+zP(iz))*Grav &
                   -RhoVLoc*L00) &
                  /(RhoDLoc*Cvd+RhoVLoc*Cvv+RhoLLoc*Cpl+Eps)
            T(ix,iy,iz,1)=TLoc
          END DO
        END DO
      END DO
    CASE('PreEn') !p
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
            TLoc=Th(ix,iy,iz,1)/(RhoDLoc*Rd+RhoVLoc*Rv+Eps)
            T(ix,iy,iz,1)=TLoc
          END DO
        END DO
      END DO
    CASE('Exner') 
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
            TLoc=p0*Th(ix,iy,iz,1)**(1.0d0/kappa)/(RhoDLoc*Rd)
            T(ix,iy,iz,1)=TLoc
          END DO
        END DO
      END DO
  END SELECT

END SUBROUTINE AbsTCompute

SUBROUTINE ECompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoLoc,TLoc,RhoDLoc,RhoVLoc,RhoLLoc,KinEnLoc
  REAL(RealKind) :: Cvml 

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        RhoLoc=Rho(ix,iy,iz,1)
        RhoVLoc=RhoV(ix,iy,iz,1)
        RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
        RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc
        Cvml=Cvd*RhoDLoc+Cvv*RhoVLoc+Cpl*RhoLLoc
        TLoc=T(ix,iy,iz,1)
        KinEnLoc=KinEn(ix,iy,iz,1)
        E(ix,iy,iz,1)=Cvml*TLoc & 
                      +RhoLoc*KinEnLoc &
                      +RhoVLoc*L00 &
                      +Half*RhoLoc*(zP(iz-1)+zP(iz))*Grav
      END DO
    END DO
  END DO

END SUBROUTINE ECompute


SUBROUTINE PreCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Arg,ThLoc,RhoLoc,RhoVLoc,RhoLLoc,KappaLoc
  REAL(RealKind) :: Kinetic,Energy,zLoc
  REAL(RealKind) :: RhoDLoc,TLoc

  IF (Shallow) THEN
    DO iz=iz0,iz1+1
      DO iy=iy0,iy1+1
        DO ix=ix0,ix1+1
          p(ix,iy,iz,1)=Half*Grav*Th(ix,iy,iz,1)*Th(ix,iy,iz,1)
        END DO
      END DO
    END DO
  ELSE IF (Liquid) THEN
    DO iz=iz0,iz1+1
      DO iy=iy0,iy1+1
        DO ix=ix0,ix1+1
          RhoLoc=Rho(ix,iy,iz,1)
          ThLoc=Th(ix,iy,iz,1)/(RhoLoc+Eps)
          arg=(EXP(-alpha_liq*(ThLoc-t0_liq))- &
              alpha_liq/(rho0_liq*kappa_liq*cpl)) &
              /(RhoLoc/Rho0_liq-alpha_liq/(rho0_liq*kappa_liq*cpl))
          IF (arg>Zero) THEN
            p(ix,iy,iz,1)=-1.d0/kappa_liq*LOG(arg)+p0_liq
          END IF
        END DO
      END DO
    END DO
  ELSE IF (LiquidTam) THEN
    DO iz=iz0,iz1+1
      DO iy=iy0,iy1+1
        DO ix=ix0,ix1+1
          p(ix,iy,iz,1)=(Th(ix,iy,iz,1)*(1.0d0-1.0d0/gamma_tam)*Cpl_tam)**(gamma_tam) &
                        *(1.0d0/(p0+gamma_tam*p0_tam))**(gamma_tam-1.0d0)
        END DO
      END DO
    END DO
  ELSE  
    SELECT CASE(ThetaKind)
    CASE ('Pseudo')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            p(ix,iy,iz,1)=Half*cS0*Cs0/Rho0*Rho(ix,iy,iz,1)*Rho(ix,iy,iz,1)
          END DO
        END DO
      END DO
    CASE('PreEn') ! p (thPos) and E (enPos)
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            p(ix,iy,iz,1)=Th(ix,iy,iz,1)
          END DO
        END DO
      END DO
    CASE('EnergyFast') ! En (thPos) 
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
            TLoc=(Th(ix,iy,iz,1) &
                   -RhoLoc*Half*(zP(iz-1)+zP(iz))*Grav &
                   -RhoVLoc*L00) &
                  /(RhoDLoc*Cvd+RhoVLoc*Cvv+RhoLLoc*Cpl+Eps)
            p(ix,iy,iz,1)=(Rd*(Rho(ix,iy,iz,1)-RhoL(ix,iy,iz,1)-RhoR(ix,iy,iz,1)) &
                          +(Rv-Rd)*RhoV(ix,iy,iz,1))*TLoc
          END DO
        END DO
      END DO
    CASE('EnergySlow')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc+Eps
            TLoc=(-RhoLoc*KinEn(ix,iy,iz,1)) &
                  /(RhoDLoc*Cvd+RhoVLoc*Cvv+RhoLLoc*Cpl+Eps)
            p(ix,iy,iz,1)=(Rd*(Rho(ix,iy,iz,1)-RhoL(ix,iy,iz,1)-RhoR(ix,iy,iz,1)) &
                          +(Rv-Rd)*RhoV(ix,iy,iz,1))*TLoc
          END DO
        END DO
      END DO
    CASE('Exner') ! p (thPos) and E (enPos)
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            p(ix,iy,iz,1)=p0*Th(ix,iy,iz,1)**(1.0d0/kappa)
          END DO
        END DO
      END DO
    CASE DEFAULT
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            p(ix,iy,iz,1)=(Rd*(Rho(ix,iy,iz,1)-RhoL(ix,iy,iz,1)-RhoR(ix,iy,iz,1)) &
                          +(Rv-Rd)*RhoV(ix,iy,iz,1))*T(ix,iy,iz,1)
          END DO
        END DO
      END DO
    END SELECT
  END IF

IF (TypeW=='ow') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          p(ix0,iy,iz,:)=p(ix0+1,iy,iz,:)
        END DO
      END DO
  END IF

  IF (TypeE=='oe') THEN
      DO iz=iz0+1,iz1
        DO iy=iy0+1,iy1
          p(ix1+1,iy,iz,:)=p(ix1,iy,iz,:)
        END DO
      END DO
  END IF

  IF (TypeS=='os') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          p(ix,iy0,iz,:)=p(ix,iy0+1,iz,:)
        END DO
      END DO
  END IF
  IF (TypeN=='on') THEN
      DO iz=iz0+1,iz1
        DO ix=ix0+1,ix1
          p(ix,iy1+1,iz,:)=p(ix,iy1,iz,:)
        END DO
      END DO
  END IF

  IF (TypeB=='ob') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          p(ix,iy,iz0,:)=p(ix,iy,iz0+1,:)
        END DO
      END DO
  END IF
  IF (TypeT=='ot') THEN
      DO iy=iy0+1,iy1
        DO ix=ix0+1,ix1
          p(ix,iy,iz1+1,:)=p(ix,iy,iz1,:)
        END DO
      END DO
  END IF

END SUBROUTINE PreCompute

SUBROUTINE RhoLCompute 

  INTEGER :: ix,iy,iz,i

  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        RhoL(ix,iy,iz,1)=Sum(WaterLiq(ix,iy,iz,:))
      END DO
    END DO
  END DO

END SUBROUTINE RhoLCompute

SUBROUTINE PreFacCompute

  INTEGER :: ix,iy,iz

  DO iz=iz0,iz1+1
    DO iy=iy0,iy1+1
      DO ix=ix0,ix1+1
        p(ix,iy,iz,1)=Rd*(Rd*Th(ix,iy,iz,1)/p0)**(Kappa/(One-Kappa))
      END DO
    END DO
  END DO

END SUBROUTINE PreFacCompute

SUBROUTINE PreFacFCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: dpdthetaL,dpdthetaR

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0,ix1
        dpdthetaL=Rd/(One-Kappa)*(Rd*Th(ix,iy,iz,1)/p0)**(Kappa/(One-Kappa))
        dpdthetaR=Rd/(One-Kappa)*(Rd*Th(ix+1,iy,iz,1)/p0)**(Kappa/(One-Kappa))
        pFU(ix,iy,iz)=(VolC(ix,iy,iz)*dpdthetaL+VolC(ix+1,iy,iz)*dpdthetaR) &
                       /(VolC(ix,iy,iz)+VolC(ix+1,iy,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0,iy1
      DO ix=ix0+1,ix1
        dpdthetaL=Rd/(One-Kappa)*(Rd*Th(ix,iy,iz,1)/p0)**(Kappa/(One-Kappa))
        dpdthetaR=Rd/(One-Kappa)*(Rd*Th(ix,iy+1,iz,1)/p0)**(Kappa/(One-Kappa))
        pFV(ix,iy,iz)=(VolC(ix,iy,iz)*dpdthetaL+VolC(ix,iy+1,iz)*dpdthetaR) &
                       /(VolC(ix,iy,iz)+VolC(ix,iy+1,iz)+Eps)
      END DO
    END DO
  END DO
  DO iz=iz0+1,iz1
    DO iy=iy0,iy1
      DO ix=ix0+1,ix1
        dpdthetaL=Rd/(One-Kappa)*(Rd*Th(ix,iy,iz,1)/p0)**(Kappa/(One-Kappa))
        dpdthetaR=Rd/(One-Kappa)*(Rd*Th(ix,iy,iz+1,1)/p0)**(Kappa/(One-Kappa))
        pFW(ix,iy,iz)=(VolC(ix,iy,iz)*dpdthetaL+VolC(ix,iy,iz+1)*dpdthetaR) &
                       /(VolC(ix,iy,iz)+VolC(ix,iy,iz+1)+Eps)
      END DO
    END DO
  END DO

END SUBROUTINE PreFacFCompute

SUBROUTINE DpDThetaCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Rm,Cpml,Cp_eff,KappaLoc
  REAL(RealKind) :: RhoLoc,RhoVLoc,RhoLLoc,RhoDLoc

  SELECT CASE (ThetaKind)
    CASE('Density')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            RhoLoc=Rho(ix,iy,iz,1)
            RhoVLoc=RhoV(ix,iy,iz,1)
            RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
            RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc
            Rm=Rd+Rv*RhoV(ix,iy,iz,1)
            Cpml=Cpd+Cpv*RhoVLoc+Cpl*RhoLLoc
            KappaLoc=Rm/Cpml
            dpdtheta(ix,iy,iz,1)=Rd/(One-KappaLoc)*(Rd*Th(ix,iy,iz,1)/p0)**(KappaLoc/(One-Kappa))
          END DO
        END DO
      END DO
    CASE('Equiv')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            Cp_eff=Cpd+(RhoV(ix,iy,iz,1)+RhoL(ix,iy,iz,1))/RhoD(ix,iy,iz,1)*Cpl
            Rm=Rd+Rv*RhoV(ix,iy,iz,1)/RhoD(ix,iy,iz,1)
            Cpml=Cpd+Cpv*RhoV(ix,iy,iz,1)/RhoD(ix,iy,iz,1)+Cpl*(RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1))/RhoD(ix,iy,iz,1)
            dpdtheta(ix,iy,iz,1)=T(ix,iy,iz,1)/Th(ix,iy,iz,1)*((Cpml-Rm)/Cp_eff) &
                                  *(RhoD(ix,iy,iz,1)*Rd+RhoV(ix,iy,iz,1)*Rv)
          END DO
        END DO
      END DO
    CASE('Energy')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            dpdtheta(ix,iy,iz,1)=(RhoD(ix,iy,iz,1)*Rd+RhoV(ix,iy,iz,1)*Rv) &
                                  /(RhoD(ix,iy,iz,1)*Cvd+RhoV(ix,iy,iz,1)*Cvv+(RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1))*Cpl)
          END DO
        END DO
      END DO
    CASE('Pressure')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            dpdtheta(ix,iy,iz,1)=One
          END DO
        END DO
      END DO
    CASE('PreEn')
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            dpdtheta(ix,iy,iz,1)=One
          END DO
        END DO
      END DO
    CASE DEFAULT
      DO iz=iz0,iz1+1
        DO iy=iy0,iy1+1
          DO ix=ix0,ix1+1
            dpdtheta(ix,iy,iz,1)=Rd/(One-Kappa)*(Rd*Th(ix,iy,iz,1)/p0)**(Kappa/(One-Kappa))
          END DO
        END DO
      END DO
  END SELECT
END SUBROUTINE DpDThetaCompute



SUBROUTINE RhoTotalCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: RhoOld,Theta

  Rho=RhoD

END SUBROUTINE RhoTotalCompute


SUBROUTINE CoriolisFreeCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp

    DO iy=iy0+1,iy1
      Temp=fCor(ix,iy)
      DO iz=iz0+1,iz1
  DO ix=ix0+1,ix1
        uRhs(ix,iy,iz,1)=uRhs(ix,iy,iz,1)+Temp*vC(ix,iy,iz,1) 
        vRhs(ix,iy,iz,1)=vRhs(ix,iy,iz,1)-Temp*uC(ix,iy,iz,1) 
      END DO
    END DO
  END DO

END SUBROUTINE CoriolisFreeCompute

SUBROUTINE CoriolisFreeComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=fCor(ix,iy)
        TempV=Temp*(vCR(ix,iy,iz,1)*FV(ix,iy,iz)+vCL(ix,iy,iz,1)*FV(ix,iy-1,iz))/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        TempU=Temp*(uCR(ix,iy,iz,1)*FU(ix,iy,iz)+uCL(ix,iy,iz,1)*FU(ix-1,iy,iz))/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)+TempV*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+TempV*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)-TempU*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)-TempU*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO

END SUBROUTINE CoriolisFreeComputeLR

SUBROUTINE CoriolisCylFreeComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV,Temp1

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=fCor(ix,iy)
        Temp1=BousinesqF1(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1))/Rho(ix,iy,iz,1)
        TempV=Temp1*Temp*(vCR(ix,iy,iz,1)*FV(ix,iy,iz)+vCL(ix,iy,iz,1)*FV(ix,iy-1,iz))/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)+TempV*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+TempV*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        TempU=Temp1*Temp*(uCR(ix,iy,iz,1)*FU(ix,iy,iz)+uCL(ix,iy,iz,1)*FU(ix-1,iy,iz))/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)-TempU*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)-TempU*VolC(ix,iy,iz)/(VolC(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO

END SUBROUTINE CoriolisCylFreeComputeLR



SUBROUTINE CoriolisCompute1

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=fCor(ix,iy)
        uRhs(ix,iy,iz,1)=uRhs(ix,iy,iz,1) &
                        +Temp*(vC(ix,iy,iz,1)-vE(ix,iy,iz,1))
        vRhs(ix,iy,iz,1)=vRhs(ix,iy,iz,1) &
                        -Temp*(uC(ix,iy,iz,1)-uE(ix,iy,iz,1))
      END DO
    END DO
  END DO

END SUBROUTINE CoriolisCompute1

SUBROUTINE CoriolisCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=fCor(ix,iy)
        TempV=(vCR(ix,iy,iz,1)*FV(ix,iy,iz)+vCL(ix,iy,iz,1)*FV(ix,iy-1,iz))/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)+Temp*(TempV-Rho(ix,iy,iz,1)*vE(ix,iy,iz,1))
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+Temp*(TempV-Rho(ix,iy,iz,1)*vE(ix,iy,iz,1))
        TempU=(uCR(ix,iy,iz,1)*FU(ix,iy,iz)+uCL(ix,iy,iz,1)*FU(ix-1,iy,iz))/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)-Temp*(TempU-Rho(ix,iy,iz,1)*uE(ix,iy,iz,1))
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)-Temp*(TempU-Rho(ix,iy,iz,1)*uE(ix,iy,iz,1))
      END DO
    END DO
  END DO

END SUBROUTINE CoriolisCompute


SUBROUTINE JacCoriolisCompute1

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=fCor(ix,iy)
        AS(IndexMet(uPosJac,vPosJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosJac,vPosJac))%c(ix,iy,iz,1)+ &
          Temp
        AS(IndexMet(vPosJac,uPosJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosJac,uPosJac))%c(ix,iy,iz,1)- &
          Temp
      END DO
    END DO
  END DO

END SUBROUTINE JacCoriolisCompute1

SUBROUTINE JacCoriolisCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=fCor(ix,iy)
        AS(IndexMet(uPosLJac,vPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosLJac,vPosLJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy-1,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosLJac,vPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosLJac,vPosRJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosRJac,vPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosRJac,vPosLJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy-1,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosRJac,vPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosRJac,vPosRJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(vPosLJac,uPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosLJac,uPosLJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix-1,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        AS(IndexMet(vPosLJac,uPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosLJac,uPosRJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        AS(IndexMet(vPosRJac,uPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosRJac,uPosLJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix-1,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        AS(IndexMet(vPosRJac,uPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosRJac,uPosRJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO

END SUBROUTINE JacCoriolisCompute

SUBROUTINE JacCoriolisCylCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=Omega
        AS(IndexMet(uPosLJac,vPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosLJac,vPosLJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy-1,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosLJac,vPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosLJac,vPosRJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosRJac,vPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosRJac,vPosLJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy-1,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosRJac,vPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosRJac,vPosRJac))%c(ix,iy,iz,1)+ &
          Temp*FV(ix,iy,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(vPosLJac,uPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosLJac,uPosLJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix-1,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        AS(IndexMet(vPosLJac,uPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosLJac,uPosRJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        AS(IndexMet(vPosRJac,uPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosRJac,uPosLJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix-1,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        AS(IndexMet(vPosRJac,uPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosRJac,uPosRJac))%c(ix,iy,iz,1)- &
          Temp*FU(ix,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
      END DO
    END DO
  END DO

END SUBROUTINE JacCoriolisCylCompute

SUBROUTINE CurvatureCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: phi,Temp
  REAL(RealKind) :: phiL,phiR,TanPhi

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      phiL=yP(iy-1)
      phiR=yP(iy)
      phi=Half*(phiL+phiR)
      TanPhi=-Curv*(COS(phiR)-COS(phiL))/(SIN(phiR)-SIN(phiL))
      DO ix=ix0+1,ix1
        Temp=TAN(phi)*uC(ix,iy,iz,1)/RadEarth/(Rho(ix,iy,iz,1)+Eps)
        uRhs(ix,iy,iz,1)=uRhs(ix,iy,iz,1)+Temp*vC(ix,iy,iz,1)
        vRhs(ix,iy,iz,1)=vRhs(ix,iy,iz,1)-Temp*uC(ix,iy,iz,1)
      END DO
    END DO
  END DO

END SUBROUTINE CurvatureCompute


SUBROUTINE CurvatureComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: phi,Temp,TempU,TempV
  REAL(RealKind) :: TempE,TempUE,TempVE
  REAL(RealKind) :: phiL,phiR,TanPhi

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      phiL=yP(iy-1)
      phiR=yP(iy)
      phi=Half*(phiL+phiR)
      TanPhi=-Curv*(COS(phiR)-COS(phiL))/(SIN(phiR)-SIN(phiL))
      DO ix=ix0+1,ix1
        TempV=(vCR(ix,iy,iz,1)*FV(ix,iy,iz)+vCL(ix,iy,iz,1)*FV(ix,iy-1,iz))/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        TempU=(uCR(ix,iy,iz,1)*FU(ix,iy,iz)+uCL(ix,iy,iz,1)*FU(ix-1,iy,iz))/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        Temp=TanPhi/RadEarth/(Rho(ix,iy,iz,1)+Eps)
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)+Temp*uCL(ix,iy,iz,1)*TempV
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+Temp*uCR(ix,iy,iz,1)*TempV
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)-Temp*TempU*TempU
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)-Temp*TempU*TempU
      END DO
    END DO
  END DO

END SUBROUTINE CurvatureComputeLR

SUBROUTINE JacCurvatureCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: phi,Temp,TempU,TempV
  REAL(RealKind) :: phiL,phiR,TanPhi

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      phi=yP(iy-1)+0.5e0*dy(iy)
      phiL=yP(iy-1)
      phiR=yP(iy)
      TanPhi=-Curv*(COS(phiR)-COS(phiL))/(SIN(phiR)-SIN(phiL))
      DO ix=ix0+1,ix1
        TempV=(vCR(ix,iy,iz,1)*FV(ix,iy,iz)+vCL(ix,iy,iz,1)*FV(ix,iy-1,iz))/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        TempU=(uCR(ix,iy,iz,1)*FU(ix,iy,iz)+uCL(ix,iy,iz,1)*FU(ix-1,iy,iz))/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        Temp=TanPhi/RadEarth/(Rho(ix,iy,iz,1)+Eps)

        AS(IndexMet(uPosLJac,uPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosLJac,uPosLJac))%c(ix,iy,iz,1)+ &
          Temp*TempV
        AS(IndexMet(uPosRJac,uPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosRJac,uPosRJac))%c(ix,iy,iz,1)+ &
          Temp*TempV

        AS(IndexMet(uPosLJac,vPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosLJac,vPosLJac))%c(ix,iy,iz,1)+ &
          Temp*uCL(ix,iy,iz,1)*FV(ix,iy-1,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosLJac,vPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosLJac,vPosRJac))%c(ix,iy,iz,1)+ &
          Temp*uCL(ix,iy,iz,1)*FV(ix,iy,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosRJac,vPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosRJac,vPosLJac))%c(ix,iy,iz,1)+ &
          Temp*uCR(ix,iy,iz,1)*FV(ix,iy-1,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        AS(IndexMet(uPosRJac,vPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosRJac,vPosRJac))%c(ix,iy,iz,1)+ &
          Temp*uCR(ix,iy,iz,1)*FV(ix,iy,iz)/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
          
        AS(IndexMet(vPosLJac,uPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosLJac,uPosLJac))%c(ix,iy,iz,1)- &
          Two*Temp*FU(ix-1,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)*TempU
        AS(IndexMet(vPosLJac,uPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosLJac,uPosRJac))%c(ix,iy,iz,1)- &
          Two*Temp*FU(ix,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)*TempU
        AS(IndexMet(vPosRJac,uPosLJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosRJac,uPosLJac))%c(ix,iy,iz,1)- &
          Two*Temp*FU(ix-1,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)*TempU
        AS(IndexMet(vPosRJac,uPosRJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosRJac,uPosRJac))%c(ix,iy,iz,1)- &
          Two*Temp*FU(ix,iy,iz)/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)*TempU
      END DO
    END DO
  END DO

END SUBROUTINE JacCurvatureCompute

SUBROUTINE CurvatureCylComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV
  REAL(RealKind) :: Rad

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Rad=Half*(yP(iy-1)+yP(iy))
      DO ix=ix0+1,ix1
        TempV=(vCR(ix,iy,iz,1)*FV(ix,iy,iz)+vCL(ix,iy,iz,1)*FV(ix,iy-1,iz))/(FV(ix,iy-1,iz)+FV(ix,iy,iz)+Eps)
        TempU=(uCR(ix,iy,iz,1)*FU(ix,iy,iz)+uCL(ix,iy,iz,1)*FU(ix-1,iy,iz))/(FU(ix-1,iy,iz)+FU(ix,iy,iz)+Eps)
        Temp=TempU/Rad/(Rho(ix,iy,iz,1)+Eps)
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)+Temp*TempV
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+Temp*TempV
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)-Temp*TempU
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)-Temp*TempU
      END DO
    END DO
  END DO

END SUBROUTINE CurvatureCylComputeLR

SUBROUTINE JacCurvatureCylCompute

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp
  REAL(RealKind) :: Rad

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Rad=Half*(yP(iy-1)+yP(iy))
      DO ix=ix0+1,ix1
        Temp=uC(ix,iy,iz,1)/Rad/(Rho(ix,iy,iz,1)+Eps)
        AS(IndexMet(uPosJac,vPosJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosJac,vPosJac))%c(ix,iy,iz,1)+ &
          Temp
        AS(IndexMet(vPosJac,uPosJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosJac,uPosJac))%c(ix,iy,iz,1)- &
              2.0d0*Temp
        Temp=vC(ix,iy,iz,1)/Rad/(Rho(ix,iy,iz,1)+Eps)
        AS(IndexMet(uPosJac,uPosJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosJac,uPosJac))%c(ix,iy,iz,1)+ &
          Temp
      END DO
    END DO
  END DO

END SUBROUTINE JacCurvatureCylCompute


SUBROUTINE CentrifugalComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV,RhoLoc

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Temp=Half*fCor(ix,iy)
      DO ix=ix0+1,ix1
        RhoLoc=BousinesqF2(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1))
        TempU=RhoLoc*TemP*Temp*(xP(ix-1)+Half*dx(ix))
        TempV=RhoLoc*TemP*Temp*(yP(iy-1)+Half*dy(iy))
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)+TempU
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+TempU
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)+TempV
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)+TempV
      END DO
    END DO
  END DO

END SUBROUTINE CentrifugalComputeLR

SUBROUTINE JacCentrifugalComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV,Temp1

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Temp=Half*fCor(ix,iy)
      DO ix=ix0+1,ix1
        Temp1=BousinesqJac(ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1))
        TempU=Temp1*TemP*Temp*(xP(ix-1)+Half*dx(ix))
        TempV=Temp1*TemP*Temp*(yP(iy-1)+Half*dy(iy))
        IF (RhoPosJac>0) THEN
          AS(IndexMet(uPosJac,RhoPosJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosJac,RhoPosJac))%c(ix,iy,iz,1)+ &
            TempU
          AS(IndexMet(vPosJac,RhoPosJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosJac,RhoPosJac))%c(ix,iy,iz,1)+ &
            TempV
        ELSE IF (ThPosJac>0) THEN
          AS(IndexMet(uPosJac,ThPosJac))%c(ix,iy,iz,1)=AS(IndexMet(uPosJac,ThPosJac))%c(ix,iy,iz,1)+ &
            TempU
          AS(IndexMet(vPosJac,ThPosJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosJac,ThPosJac))%c(ix,iy,iz,1)+ &
            TempV
        END IF
      END DO
    END DO
  END DO

END SUBROUTINE JacCentrifugalComputeLR

SUBROUTINE CentrifugalCylComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV,RhoLoc

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      Temp=Half*fCor(ix,iy)
      DO ix=ix0+1,ix1
        RhoLoc=BousinesqF2(Th(ix,iy,iz,1),ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1))
        TempV=RhoLoc*TemP*Temp*(yP(iy-1)+Half*dy(iy))
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)+TempV
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)+TempV
      END DO
    END DO
  END DO

END SUBROUTINE CentrifugalCylComputeLR

SUBROUTINE JacCentrifugalCylComputeLR

  INTEGER :: ix,iy,iz
  REAL(RealKind) :: Temp,TempU,TempV,Temp1

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        Temp=Half*fCor(ix,iy)
        Temp1=BousinesqJac2(ThProf(ix,iy,iz,1),Rho(ix,iy,iz,1))
        TempV=Temp1*Temp*Temp*(yP(iy-1)+Half*dy(iy))
        IF (RhoPosJac>0) THEN
          AS(IndexMet(vPosJac,RhoPosJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosJac,RhoPosJac))%c(ix,iy,iz,1)+ &
            TempV
        ELSE IF (ThPosJac>0) THEN
          AS(IndexMet(vPosJac,ThPosJac))%c(ix,iy,iz,1)=AS(IndexMet(vPosJac,ThPosJac))%c(ix,iy,iz,1)+ &
            TempV
        END IF
      END DO
    END DO
  END DO

END SUBROUTINE JacCentrifugalCylComputeLR

SUBROUTINE ForceVelCompute(Time)

  REAL(RealKind) :: Time
  INTEGER :: ix,iy,iz
  REAL(RealKind) :: xPL,yPL,zPL

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        xPL=xP(ix-1)+0.5e0*dx(ix)
        yPL=yP(iy-1)+0.5e0*dy(iy)
        zPL=zP(iz-1)+0.5e0*dz(iz)
        uRhsL(ix,iy,iz,1)=uRhsL(ix,iy,iz,1)+ForceU(xPL,yPL,zPL,zH(ix,iy),Time)
        uRhsR(ix,iy,iz,1)=uRhsR(ix,iy,iz,1)+ForceU(xPL,yPL,zPL,zH(ix,iy),Time)
        vRhsL(ix,iy,iz,1)=vRhsL(ix,iy,iz,1)+ForceV(xPL,yPL,zPL,zH(ix,iy),Time)
        vRhsR(ix,iy,iz,1)=vRhsR(ix,iy,iz,1)+ForceV(xPL,yPL,zPL,zH(ix,iy),Time)
        wRhsL(ix,iy,iz,1)=wRhsL(ix,iy,iz,1)+ForceW(xPL,yPL,zPL,zH(ix,iy),Time)
        wRhsR(ix,iy,iz,1)=wRhsR(ix,iy,iz,1)+ForceW(xPL,yPL,zPL,zH(ix,iy),Time)
      END DO
    END DO
  END DO

END SUBROUTINE ForceVelCompute


SUBROUTINE ForceScalarCompute(Rhs,Time)

  TYPE(Vec4_T), POINTER :: Rhs(:)
  REAL(RealKind) :: Time
  INTEGER :: ix,iy,iz
  REAL(RealKind) :: xPL,yPL,zPL
  INTEGER :: x0p,x1p,y0p,y1p,BlockSize,BlockNum,nBlock,iBlock,jBlock
  INTEGER, ALLOCATABLE :: BlockX0(:),BlockX1(:),BlockY0(:),BlockY1(:)
  REAL(RealKind),ALLOCATABLE :: r(:)
  REAL(RealKind) :: RhoLoc,RhoVLoc,RhoLLoc,RhoDLoc,TLoc,pLoc,eLoc
  REAL(RealKind) :: Rm,Cpml,Cvml,pvs,Lv,Cp_eff 
  REAL(RealKind) :: drvdt,rrv,rrl,dPotdt,PotM,ThDens,ThEquiv,Kinetic,Energy 
  REAL(RealKind) :: DpDRho,DpDe,DpDRhoV 
  REAL(RealKind) :: Theta 
  REAL(RealKind) :: PreFacQv,PreFacQvEn
  INTEGER :: SizeMySeed=12
  INTEGER,Dimension(12) :: Myseed

  ! Cell Perturbation Method
  ! Check for perturbation time
  IF (ThPos>0.AND.ForcingCellPert.AND.MOD(INT(Time),ForcingCellPertTime)==0) THEN 
    ! Check for perturbation area 
    OPEN(99,FILE=ForcingCellPertFile,STATUS='OLD',ACTION='READ')
    READ(99,*) x0p,y0p
    READ(99,*) x1p,y1p
    READ(99,*) BlockSize
    CLOSE(99)
    BlockNum=3*(y1p-y0p)/BlockSize
    ALLOCATE(BlockX0(BlockNum))
    ALLOCATE(BlockX1(BlockNum))
    ALLOCATE(BlockY0(BlockNum))
    ALLOCATE(BlockY1(BlockNum))
    ALLOCATE(r(BlockNum))
    nBlock=0
    DO iBlock=1,3
      DO jBlock=1,(y1p-y0p)/BlockSize
        nBlock=nBlock+1
        Myseed=nBlock+INT(Time) 
        CALL Random_seed(put=Myseed)            
        CALL Random_number(r(nBlock))
        BlockX0(nBlock)=x0p+8*(iBlock-1)
        BlockY0(nBlock)=y0p+8*(jBlock-1)
        BlockX1(nBlock)=x0p+8*(iBlock)
        BlockY1(nBlock)=y0p+8*(jBlock)
      END DO
    END DO
  END IF

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        xPL=xP(ix-1)+0.5e0*dx(ix)
        yPL=yP(iy-1)+0.5e0*dy(iy)
        zPL=zP(iz-1)+0.5e0*dz(iz)
        IF (RhoPos>0) THEN
          Rhs(RhoPos)%c(ix,iy,iz,1)=Rhs(RhoPos)%c(ix,iy,iz,1) &
                       +ForceRho(xPL,yPL,zPL,zH(ix,iy),Time)
        END IF
        IF (qvPos>0) THEN
          Rhs(qvPos)%c(ix,iy,iz,1)=Rhs(qvPos)%c(ix,iy,iz,1) &
                       +ForceRho(xPL,yPL,zPL,zH(ix,iy),Time)
        END IF
        IF (ThPos>0.AND..NOT.ForcingCellPert) THEN
          RhoLoc=Rho(ix,iy,iz,1)
          RhoVLoc=RhoV(ix,iy,iz,1)
          RhoLLoc=RhoL(ix,iy,iz,1)+RhoR(ix,iy,iz,1)
          RhoDLoc=RhoLoc-RhoVLoc-RhoLLoc
          rrv=RhoVLoc/RhoDLoc
          rrl=RhoLLoc/RhoDLoc
          pLoc=p(ix,iy,iz,1)
          TLoc=T(ix,iy,iz,1)
          Theta=Th(ix,iy,iz,1)
          pVs=SaturVapor(TLoc)
          Lv=LatHeat(TLoc)
          Rm=RhoDLoc*Rd+RhoVLoc*Rv
          Cpml=RhoDLoc*Cpd+RhoVLoc*Cpv+RhoLLoc*Cpl
          Cp_eff=Cpd+(rrv+rrl)*Cpl
          PotM=TLoc*(p0/pLoc)**(Rm/Cpml)
          SELECT CASE(ThetaKind)
          CASE('Density')
            PreFacQv=Theta*(Rv/Rm &
                            +LOG(p0/((RhoDLoc*Rd+RhoVLoc*Rv)*TLoc)) &
                             *(-cpv*Rd*RhoDLoc+cpd*Rv*RhoDLoc+cpl*Rv*RholLoc)/Cpml**2.0d0  &
                           )
            Rhs(ThPos)%c(ix,iy,iz,1)=Rhs(ThPos)%c(ix,iy,iz,1) &
                                     +ForceTh(xPL,yPL,zPL,zH(ix,iy),Time)*RhoLoc
          CASE('Equiv')
            PreFacQv=Theta/(RhoDLoc*Cpd+(RhoVLoc+RhoLLoc)*Cpl)**2   &
                      *(-RhoDLoc*Rd*Cpl*LOG(p0/(RhoDLoc*Rd*TLoc))   &
                        +(RhoDLoc*Cpd+RhoLLoc*Cpl)*(Lv/TLoc-Rv*LOG(RelHumidity(TLoc,RhoVLoc))) &
                       ) &
                     +Theta/RhoLoc
          CASE('Energy')
            Kinetic=KinEn(ix,iy,iz,1)
            PreFacQv=(Cpv*TLoc+L00)+Grav*zPL+Kinetic
          CASE('PreEn')
            Cvml=RhoDLoc*Cvd+RhoVLoc*Cvv+RhoLLoc*Cpl
            eLoc=Cvml*TLoc+RhoVLoc*L00
            DpDRho=Rd*(eLoc-RhoVLoc*L00)/Cvml &
                   -Cvd*(eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2 &
                   +eLoc/(RhoLoc+Eps)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml
            DpDe=RhoLoc*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml
            DpDRhoV=(Rv-Rd)*(eLoc-RhoVLoc*L00)/Cvml &
                    -L00*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml &
                    -(Cvv-Cvd)*(eLoc-RhoVLoc*L00)*(RhoDLoc*Rd+RhoVLoc*Rv)/Cvml**2 
            PreFacQv=Cpv*TLoc+L00
            Rhs(enPos)%c(ix,iy,iz,1)=Rhs(enPos)%c(ix,iy,iz,1) &
                       +ForceRho(xPL,yPL,zPL,zH(ix,iy),Time)*PreFacQv
            PreFacQv=DpDRho+(Cpv*TLoc+L00)/(RhoLoc+Eps)*DpDe+DpDRhoV
          END SELECT  
          Rhs(ThPos)%c(ix,iy,iz,1)=Rhs(ThPos)%c(ix,iy,iz,1) &
                     +ForceRho(xPL,yPL,zPL,zH(ix,iy),Time)*PreFacQv
        END IF
        ! Cell perturbation
        IF (ThPos>0.AND.ForcingCellPert.AND.MOD(INT(Time),ForcingCellPertTime)==0) THEN
          nBlock=0
          DO iBlock=1,3
            DO jBlock=1,(y1p-y0p)/BlockSize
              nBlock=nBlock+1
              IF (ix>=BlockX0(nBlock).AND.ix<BlockX1(nBlock).AND.iy>=BlockY0(nBlock).AND.iy<BlockY1(nBlock)) THEN
                RhoLoc=Rho(ix,iy,iz,1)
                Rhs(ThPos)%c(ix,iy,iz,1)=Rhs(ThPos)%c(ix,iy,iz,1) &
                                         +ForceTh(xPL,yPL,zPL,zH(ix,iy),Time)*RhoLoc*Two*(r(nBlock)-0.5d0)
                EXIT
              END IF
            END DO
          END DO  
        END IF
        IF (ThPos>0.AND.Shallow) THEN
          Rhs(ThPos)%c(ix,iy,iz,1)=Rhs(ThPos)%c(ix,iy,iz,1) &
                       +ForceRho(xPL,yPL,zPL,zH(ix,iy),Time)
        END IF
      END DO
    END DO
  END DO

END SUBROUTINE ForceScalarCompute

SUBROUTINE DampingCompute(Time)

  REAL(RealKind) :: Time
  INTEGER :: ix,iy,iz
  REAL(RealKind) :: TempEnv

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        TempEnv=Rho(ix,iy,iz,1)*((Time2-Time)*ce1(ix,iy,iz,1) &
               +(Time-Time1)*ce2(ix,iy,iz,1)) &
               /(Time2-Time1)
        f(ix,iy,iz,1)=f(ix,iy,iz,1)- &
               DampKoeff(ix,iy,iz,1)*(c(ix,iy,iz,1)-TempEnv)
      END DO
    END DO
  END DO

END SUBROUTINE DampingCompute

SUBROUTINE JacDampingCompute

  INTEGER :: ix,iy,iz

  DO iz=iz0+1,iz1
    DO iy=iy0+1,iy1
      DO ix=ix0+1,ix1
        AS(Diag)%c(ix,iy,iz,1)=AS(Diag)%c(ix,iy,iz,1)- &
               DampKoeff(ix,iy,iz,1)
      END DO
    END DO
  END DO

END SUBROUTINE JacDampingCompute

SUBROUTINE DampingInit

  INTEGER :: ix,iy,iz
  INTEGER :: ibLoc
  REAL(RealKind) :: xPLoc,yPLoc,zPLoc

  IF (Damping) THEN
    CALL Allocate(DampKoeffCell)
    DampKoeffCell=Zero
    DO ibLoc=1,nbLoc
      ib=LocGlob(ibLoc)
      CALL Set(Floor(ib))
      DO ix=ix0+1,ix1
        xPLoc=xP(ix-1)+Half*dx(ix)
!       West Boundary
        IF (xPLoc<=Domain%x0+StrideDamp%R_W) THEN
          DampKoeffCell(ibLoc)%c(ix,iy0+1:iy1,iz0+1:iz1,1) &
            =MAX(DampKoeffCell(ibLoc)%c(ix,iy0+1:iy1,iz0+1:iz1,1) &
                ,Damp%R_W*DampF(One-(xPLoc-Domain%x0)/StrideDamp%R_W))
        END IF
!       East Boundary
        IF (xPLoc>=Domain%x1-StrideDamp%R_E) THEN
          DampKoeffCell(ibLoc)%c(ix,iy0+1:iy1,iz0+1:iz1,1) &
            =MAX(DampKoeffCell(ibLoc)%c(ix,iy0+1:iy1,iz0+1:iz1,1) &
                ,Damp%R_E*DampF(One-(Domain%x1-xPLoc)/StrideDamp%R_E))
        END IF
      END DO
      DO iy=iy0+1,iy1
        yPLoc=yP(iy-1)+Half*dy(iy)
!       South Boundary
        IF (yPLoc<=Domain%y0+StrideDamp%R_S) THEN
          DampKoeffCell(ibLoc)%c(ix0+1:ix1,iy,iz0+1:iz1,1) &
            =MAX(DampKoeffCell(ibLoc)%c(ix0+1:ix1,iy,iz0+1:iz1,1) &
                ,Damp%R_S*DampF(One-(yPLoc-Domain%y0)/StrideDamp%R_S))
        END IF
!       North Boundary
        IF (yPLoc>=Domain%y1-StrideDamp%R_N) THEN
          DampKoeffCell(ibLoc)%c(ix0+1:ix1,iy,iz0+1:iz1,1) &
            =MAX(DampKoeffCell(ibLoc)%c(ix0+1:ix1,iy,iz0+1:iz1,1) &
                ,Damp%R_N*DampF(One-(Domain%y1-yPLoc)/StrideDamp%R_N))
        END IF
      END DO

      DO iz=iz0+1,iz1
        zPLoc=zP(iz-1)+Half*dz(iz)
!       Top Boundary
        IF (zPLoc>=Domain%z1-StrideDamp%R_T) THEN
          DampKoeffCell(ibLoc)%c(ix0+1:ix1,iy0+1:iy1,iz,1) &
            =MAX(DampKoeffCell(ibLoc)%c(ix0+1:ix1,iy0+1:iy1,iz,1) &
                ,Damp%R_T*DampF(One-(Domain%z1-zpLoc)/StrideDamp%R_T))
        END IF
      END DO
    END DO
  END IF
CONTAINS 
FUNCTION DampF(alpha)

  REAL(RealKind) :: DampF
  REAL(RealKind) :: alpha

  DampF=alpha
  DampF=SIN(Half*Pi*alpha)**2

END FUNCTION DampF

END SUBROUTINE DampingInit

FUNCTION vSub(zHeight)  

  REAL(RealKind) :: vSub
  REAL(RealKind) :: zHeight

    SELECT CASE(vSubProfile)
    CASE('BOMEX')
      IF(zHeight<1500.0d0) THEN
        vSub=(vSubConst/1500.0d0)*zHeight
      ELSE IF(zHeight>=1500.0d0.AND.zHeight<2100.0d0) THEN
        vSub=vSubConst-vSubConst/(2100.0d0-1500.0d0)*(zHeight-1500.0d0)  
      ELSE
        vSub=Zero
      END IF   
    CASE('RICO')
      IF(zHeight<2260.0d0) THEN
        vSub=(vSubConst/2260.0d0)*zHeight
      ELSE IF(zHeight>=2260.0d0.AND.zHeight<4000.0d0) THEN
        vSub=vSubConst
      ELSE
        vSub=Zero
      END IF   
    CASE DEFAULT
       vSub=vSubConst
    END SELECT

END FUNCTION vSub

END MODULE Function_Mod
