MODULE Subdom_Mod

USE Kind_Mod
USE Block_Mod, ONLY: Block
USE MatSpRowCol_Mod, ONLY: SpRowCol, Axpy_SpRowCol, SpAVec_SpRowCol, SpMm_SpRowCol
USE Boundary_Mod, ONLY: BoundCommInterface, HaloType, Bound, copy_data_on_bnd, &
                        copy_data_from_bnd, laplace_boundary_condition, gradient_boundary_condition, &
                        gradientp_boundary_condition, matmul_boundary_condition, intcell2face_boundary_condition, &
                        init_two_sided_exchange, finish_two_sided_exchange, matmul_bl_boundary_condition, &
                        matmul_rd_boundary_condition
USE MPI_mod
USE Index_Mod, ONLY: IndexC3, IndexC3block, IndexU3block, IndexV3block, IndexW3block, &
                     findloc_real

USE Smooth_Mod, ONLY: SorSolver

TYPE :: SubDomain
  INTEGER :: nblocks  !number of blocks contained in subdomain
  INTEGER :: myrank   !process id
  INTEGER, ALLOCATABLE :: blockids_comp(:)
  LOGICAL, ALLOCATABLE :: blockiscomp(:)
  INTEGER, ALLOCATABLE :: blockids_compghst(:)
  INTEGER, ALLOCATABLE :: inds1d_type(:)
  INTEGER, ALLOCATABLE :: indsface1d_type(:)
  INTEGER, ALLOCATABLE :: btype(:)
  !Predefined subdomain boundaries generated by a partitioning algorithm or manually.
  !Ghost layers have still to be added, so this defines the computation subdomain:
  REAL(Realkind) :: x2_first, x2_last, & !x-coordinates of first and last x-normal cell face
                    y2_first, y2_last, & !y-coordinates of first and last y-normal cell face
                    z2_first, z2_last    !z-coordinates of first and last z-normal cell face
  INTEGER :: ncells_tmp  !Number of cell volumes contained in subdomain before cropping
  INTEGER :: nfaces_tmp  !Number of cell volumes contained in subdomain before cropping
  INTEGER :: ncells  !Number of cells contained in subdomain
  INTEGER :: nfaces  !Number of cell-faces contained in subdomain
  INTEGER :: nghost !Number of ghost cells in subdomain
  INTEGER :: nbound !Number of boundary cells
  INTEGER :: ncoarse !Number of cells of similar coarse-grid subdomain (sharing the same rank)
  TYPE(Block), POINTER :: blocks(:)  => NULL() !Pointer to the blocks

  TYPE(Bound), POINTER :: transfer_recv => NULL()
  TYPE(Bound), POINTER :: transfer_send => NULL()

  TYPE(SpRowCol) :: Prol_samerank, Restr_samerank           !Prolongation and restriction operators
  TYPE(SpRowCol) :: div3d, grad3d, gradp3d, lapl3d, lapl3dp !Divergence, gradient and Laplacian operators of entire computation subdomain
  TYPE(SpRowCol) :: intc2f                                  !Interpolation operator from cell centres to cell faces
  TYPE(SpRowCol) :: eye                                     !Identity matrix
  TYPE(SpRowCol) :: Rd, Bl                                  !Checkerboard operators for red-black smoothing

  TYPE(SpRowCol), POINTER :: mat => NULL(),    &   !more general Laplacian operator (e.g. from compressible pressure equation)
                             mat_rd => NULL(), &   !operator for red grid points
                             mat_bl => NULL()      !operator for black grid points

  TYPE(SorSolver), POINTER :: smoother => NULL()        ! smoother type
  TYPE(BoundCommInterface), POINTER :: bc_if => NULL()  ! boundary type communication interface
  TYPE(TransfCommInterface), POINTER :: tr_if => NULL() ! transfer type communication interface

  TYPE(SubDomain), POINTER :: next_coarse => NULL() !pointer to next coarse grid level
  TYPE(SubDomain), POINTER :: next_fine => NULL()   !pointer to next fine grid level

  CONTAINS
  
  PROCEDURE :: init_boundcomm_interface, init_smoother, set_cell_type, set_face_type, &
               prolongate, restrict, lapl_mul, grad_mul, gradp_mul, div_mul, mat_mul, mat_mul_bl, mat_mul_rd, &
               intc2f_mul, v_cycle, solve_mg, solve_mgbicgstab
END TYPE SubDomain


TYPE TransfCommInterface
  INTEGER :: myrank
  TYPE(Bound), POINTER :: send_bnds => NULL()
  TYPE(Bound), POINTER :: recv_bnds => NULL()
  TYPE(SpRowCol) :: Restr_offrank, Prol_offrank
  REAL(Realkind), POINTER :: commbuff(:)
  INTEGER, ALLOCATABLE :: rank_ptr(:)
END TYPE TransfCommInterface

!INTERFACE

!  SUBROUTINE prolongate(self, field1d_coarse, field1d_fine, mode)
!    IMPORT SubDomain
!    IMPORT Realkind
!    IMPLICIT NONE

!    CLASS(SubDomain) :: self
!    REAL(Realkind), INTENT(in) :: field1d_fine(:)
!    REAL(Realkind), INTENT(inout) :: field1d_coarse(:)
!    CHARACTER(len=3), INTENT(in) :: mode
!  END SUBROUTINE prolongate

!  SUBROUTINE restrict(self, field1d_fine, field1d_coarse)
!    IMPORT SubDomain
!    IMPORT Realkind
!    IMPLICIT NONE

!    CLASS(SubDomain) :: self
!    REAL(Realkind), INTENT(in) :: field1d_fine(:)
!    REAL(Realkind), INTENT(inout) :: field1d_coarse(:)

!  END SUBROUTINE restrict

!END INTERFACE

CONTAINS


RECURSIVE SUBROUTINE v_cycle(self, x, b, nsmooth_pre, nsmooth_post, nsmooth_coarsest)

  IMPLICIT NONE

  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: b(:)
  REAL(Realkind), INTENT(inout) :: x(:)
  INTEGER, OPTIONAL, INTENT(in) :: nsmooth_pre, nsmooth_post, nsmooth_coarsest
  INTEGER :: nsmooth_pre_def, nsmooth_post_def, nsmooth_coarsest_def

  REAL(Realkind) :: r(SIZE(x, 1))
  REAL(Realkind) :: r_coarse(self%ncoarse)
  REAL(Realkind) :: x_coarse(self%ncoarse)

  TYPE(SubDomain), POINTER :: coarse => NULL()
  INTEGER :: i

  nsmooth_pre_def = 2
  nsmooth_post_def = 2
  nsmooth_coarsest_def = 10

  IF (PRESENT(nsmooth_pre)) nsmooth_pre_def = nsmooth_pre
  IF (PRESENT(nsmooth_post)) nsmooth_post_def = nsmooth_post
  IF (PRESENT(nsmooth_coarsest)) nsmooth_coarsest_def = nsmooth_coarsest
  
  IF (ASSOCIATED(self%next_coarse)) THEN
    CALL self%smoother%smooth(x, b, nsmooth_pre_def)
    CALL self%mat_mul(r, x)
    DO i = 1, SIZE(b, 1)
      r(i) = b(i) - r(i)
    END DO
    CALL self%restrict(r, r_coarse)

    coarse => self%next_coarse
    x_coarse(:) = 0.0
    CALL coarse%v_cycle(x_coarse, r_coarse, nsmooth_pre_def, nsmooth_post_def, nsmooth_coarsest_def)

    CALL self%prolongate(x_coarse, x, mode='add')
    CALL self%smoother%smooth(x, b, nsmooth_post_def)
  ELSE
    CALL self%smoother%smooth(x, b, nsmooth_coarsest_def)
  END IF
  
END SUBROUTINE v_cycle

SUBROUTINE solve_mg(self, x, b, n_iter, nsmooth_pre, nsmooth_post, nsmooth_coarsest)

  IMPLICIT NONE
 
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: b(:)
  REAL(Realkind), INTENT(inout) :: x(:)
  INTEGER, INTENT(in) :: n_iter
  INTEGER, OPTIONAL, INTENT(in) :: nsmooth_pre, nsmooth_post, nsmooth_coarsest
  INTEGER :: nsmooth_pre_def, nsmooth_post_def, nsmooth_coarsest_def

  REAL(Realkind) :: r(SIZE(x, 1))

  INTEGER :: i, j, n

  nsmooth_pre_def = 2
  nsmooth_post_def = 2
  nsmooth_coarsest_def = 10

  IF (PRESENT(nsmooth_pre)) nsmooth_pre_def = nsmooth_pre
  IF (PRESENT(nsmooth_post)) nsmooth_post_def = nsmooth_post
  IF (PRESENT(nsmooth_coarsest)) nsmooth_coarsest_def = nsmooth_coarsest

  n = SIZE(x, 1)

  DO i = 1, n_iter
    CALL self%v_cycle(x, b, nsmooth_pre, nsmooth_post, nsmooth_coarsest)
    CALL self%mat_mul(r, x)
    DO j = 1, n
      r(j) = b(j) - r(j)
    END DO
    WRITE(*,*) "RMAX:",  maxval(abs(r))
  END DO

END SUBROUTINE solve_mg


SUBROUTINE solve_mgbicgstab(self, x, b, n_iter, nsmooth_pre, nsmooth_post, nsmooth_coarsest)

  IMPLICIT NONE

  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: b(:)
  REAL(Realkind), INTENT(inout) :: x(:)
  INTEGER, INTENT(in) :: n_iter
  INTEGER, OPTIONAL, INTENT(in) :: nsmooth_pre, nsmooth_post, nsmooth_coarsest
  INTEGER :: nsmooth_pre_def, nsmooth_post_def, nsmooth_coarsest_def

  REAL(Realkind) :: r(SIZE(x, 1)), &
                    r_tilde(SIZE(x, 1)), &
                    y(SIZE(x, 1)), &
                    z(SIZE(x, 1)), &
                    p(SIZE(x, 1)), &
                    v(SIZE(x, 1)), &
                    s(SIZE(x, 1)), &
                    t(SIZE(x, 1))

  REAL(Realkind) :: rho_tilde, rho, alpha, beta, om, eps

  INTEGER :: i, j, n

  nsmooth_pre_def = 2
  nsmooth_post_def = 2
  nsmooth_coarsest_def = 10

  IF (PRESENT(nsmooth_pre)) nsmooth_pre_def = nsmooth_pre
  IF (PRESENT(nsmooth_post)) nsmooth_post_def = nsmooth_post
  IF (PRESENT(nsmooth_coarsest)) nsmooth_coarsest_def = nsmooth_coarsest

  n = SIZE(x, 1)

  rho = 1.0 
  alpha = 1.0
  om = 1.0
  eps = 1e-30

  v(:) = b

  CALL self%mat_mul(r, x)
  DO j = 1, n
    r(j) = b(j) - r(j)
  END DO
 
  r_tilde(:) = r

  DO i = 1, n_iter
    rho_tilde = dot_para(r, r_tilde)
    IF (i .EQ. 1) THEN
      p(:) = r
    ELSE
      beta = rho_tilde / rho * (alpha / om)
      DO j = 1, n
        p(j) = r(j) + beta * (p(j) - om * v(j))
      END DO
    END IF

    y(:) = 0.0
    CALL self%v_cycle(y, p, nsmooth_pre, nsmooth_post, nsmooth_coarsest)
   
    CALL self%mat_mul(v, y)
    alpha = rho_tilde / (dot_para(r_tilde, v) + eps)

    DO j = 1, n
      s(j) = r(j) - alpha * v(j)
    END DO

    z(:) = 0.0
    CALL self%v_cycle(z, s, nsmooth_pre, nsmooth_post, nsmooth_coarsest)

    CALL self%mat_mul(t, z)

    om = dot_para(t, s) / (dot_para(t, t) + eps)

    DO j = 1, n
      x(j) = x(j) + om * z(j) + alpha * y(j)
      r(j) = s(j) - om * t(j)
    END DO
  
    rho = rho_tilde
 
    WRITE(*,*) "RMAX:",  maxval(abs(r))
  END DO

END SUBROUTINE solve_mgbicgstab


SUBROUTINE restrict(self, field1d_fine, field1d_coarse)
  IMPLICIT NONE

  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: field1d_fine(:)
  REAL(Realkind), INTENT(inout) :: field1d_coarse(:)
  TYPE(Bound), POINTER :: current => NULL()

  IF (ASSOCIATED(self%tr_if)) THEN
    CALL SpAVec_SpRowCol(self%tr_if%commbuff, &
                         self%tr_if%Restr_offrank, field1d_fine)

    IF (ASSOCIATED(self%tr_if%send_bnds)) THEN
      current => self%tr_if%send_bnds
      CALL MPI_ISEND(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                     current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL MPI_ISEND(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                       current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      END DO
    END IF
    IF (ASSOCIATED(self%tr_if%recv_bnds)) THEN
      current => self%tr_if%recv_bnds
      CALL MPI_IRECV(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                     current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL MPI_IRECV(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                       current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      END DO
    END IF
  END IF

  CALL SpAVec_SpRowCol(field1d_coarse, self%Restr_samerank, field1d_fine)

  IF (ASSOCIATED(self%tr_if)) THEN
    IF (ASSOCIATED(self%tr_if%send_bnds)) THEN
      current => self%tr_if%send_bnds
      CALL MPI_WAIT(current%req, status, MPIErr)
      DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL MPI_WAIT(current%req, status, MPIErr)
      END DO
    END IF
    IF (ASSOCIATED(self%tr_if%recv_bnds)) THEN
      current => self%tr_if%recv_bnds
      CALL MPI_WAIT(current%req, status, MPIErr)
      CALL copy_data_from_bnd(current, field1d_coarse, mode='add')
     DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL MPI_WAIT(current%req, status, MPIErr)
        CALL copy_data_from_bnd(current, field1d_coarse, mode='add')
      END DO
    END IF
  END IF

END SUBROUTINE restrict

SUBROUTINE prolongate(self, field1d_coarse, field1d_fine, mode)
  IMPLICIT NONE

  CLASS(SubDomain) :: self

  REAL(Realkind), INTENT(in) :: field1d_fine(:)
  REAL(Realkind), INTENT(inout) :: field1d_coarse(:)
  TYPE(Bound), POINTER :: current => NULL()
  CHARACTER(len=3), INTENT(in) :: mode

  IF (ASSOCIATED(self%tr_if)) THEN
    IF (ASSOCIATED(self%tr_if%recv_bnds)) THEN
      current => self%tr_if%recv_bnds
      CALL copy_data_on_bnd(current, field1d_coarse, mode='rep')
      CALL MPI_ISEND(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                     current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL copy_data_on_bnd(current, field1d_coarse, mode='rep')
        CALL MPI_ISEND(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                       current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      END DO
    END IF
    IF (ASSOCIATED(self%tr_if%send_bnds)) THEN
      current => self%tr_if%send_bnds
      CALL MPI_IRECV(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                     current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL MPI_IRECV(current%fld_data, SIZE(current%fld_data), MPI_RealKind, &
                       current%rank_comm, current%tag, MPI_COMM_WORLD, current%req, MPIErr)
      END DO
    END IF
  END IF

  IF (mode .EQ. 'add') THEN
    CALL Axpy_SpRowCol(self%Prol_samerank, field1d_coarse, field1d_fine)
  ELSE
    CALL SpAVec_SpRowCol(field1d_fine, self%Prol_samerank, field1d_coarse)
  END IF

  IF (ASSOCIATED(self%tr_if)) THEN
    IF (ASSOCIATED(self%tr_if%recv_bnds)) THEN
      current => self%tr_if%recv_bnds
      CALL MPI_WAIT(current%req, status, MPIErr)
      DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL MPI_WAIT(current%req, status, MPIErr)
      END DO
    END IF

    IF (ASSOCIATED(self%tr_if%send_bnds)) THEN
      current => self%tr_if%send_bnds
      CALL MPI_WAIT(current%req, status, MPIErr)
      DO WHILE(ASSOCIATED(current%next))
        current => current%next
        CALL MPI_WAIT(current%req, status, MPIErr)
      END DO
    END IF
    CALL Axpy_SpRowCol(self%tr_if%Prol_offrank, &
                       self%tr_if%commbuff, field1d_fine)
  END IF

END SUBROUTINE prolongate


SUBROUTINE mat_mul(self, ax, x, mode)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: ax(:)
  CHARACTER(len=3), OPTIONAL, INTENT(in) :: mode

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL init_two_sided_exchange(self%bc_if, x)
  END IF
  CALL SpAVec_SpRowCol(ax, self%mat, x)

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL finish_two_sided_exchange(self%bc_if)
    CALL matmul_boundary_condition(self%bc_if, ax, mode)
  END IF

END SUBROUTINE mat_mul


SUBROUTINE mat_mul_bl(self, ax, x, mode)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: ax(:)
  CHARACTER(len=3), OPTIONAL, INTENT(in) :: mode

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL init_two_sided_exchange(self%bc_if, x)
  END IF
  CALL SpAVec_SpRowCol(ax, self%smoother%mat_bl, x)

  IF (ASSOCIATED(self%bc_if)) THEN
  CALL finish_two_sided_exchange(self%bc_if)
  CALL matmul_bl_boundary_condition(self%bc_if, ax, mode)
  END IF

END SUBROUTINE mat_mul_bl


SUBROUTINE mat_mul_rd(self, ax, x, mode)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: ax(:)
  CHARACTER(len=3), OPTIONAL, INTENT(in) :: mode

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL init_two_sided_exchange(self%bc_if, x)
  END IF
  CALL SpAVec_SpRowCol(ax, self%smoother%mat_rd, x)

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL finish_two_sided_exchange(self%bc_if)
    CALL matmul_rd_boundary_condition(self%bc_if, ax, mode)
  END IF

END SUBROUTINE mat_mul_rd


SUBROUTINE lapl_mul(self, ax, x, mode)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: ax(:)
  CHARACTER(len=3), OPTIONAL, INTENT(in) :: mode

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL init_two_sided_exchange(self%bc_if, x)
  END IF
  CALL SpAVec_SpRowCol(ax, self%lapl3d, x)

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL finish_two_sided_exchange(self%bc_if)
    CALL laplace_boundary_condition(self%bc_if, ax, mode)
  END IF

END SUBROUTINE lapl_mul


SUBROUTINE grad_mul(self, g, x)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: g(:)

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL init_two_sided_exchange(self%bc_if, x)
  END IF

  CALL SpAVec_SpRowCol(g, self%grad3d, x)

  IF (ASSOCIATED(self%bc_if)) THEN
    CALL finish_two_sided_exchange(self%bc_if)
    CALL gradient_boundary_condition(self%bc_if, g)
  END IF

END SUBROUTINE grad_mul


SUBROUTINE gradp_mul(self, g, x)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: g(:)
    
  IF (ASSOCIATED(self%bc_if)) THEN
    CALL init_two_sided_exchange(self%bc_if, x)
  END IF

  CALL SpAVec_SpRowCol(g, self%gradp3d, x)
    
  IF (ASSOCIATED(self%bc_if)) THEN
    CALL finish_two_sided_exchange(self%bc_if)
    CALL gradientp_boundary_condition(self%bc_if, g)
  END IF

END SUBROUTINE gradp_mul


SUBROUTINE intc2f_mul(self, i, x)
  
  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: i(:)


  IF (ASSOCIATED(self%bc_if)) THEN
    CALL init_two_sided_exchange(self%bc_if, x)
  END IF
  
  CALL SpAVec_SpRowCol(i, self%intc2f, x)
    
  IF (ASSOCIATED(self%bc_if)) THEN
    CALL finish_two_sided_exchange(self%bc_if)
    CALL intcell2face_boundary_condition(self%bc_if, i)
  END IF

END SUBROUTINE intc2f_mul

SUBROUTINE div_mul(self, d, x)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: x(:)
  REAL(Realkind), INTENT(inout) :: d(:)

  CALL SpAVec_SpRowCol(d, self%div3d, x)

END SUBROUTINE div_mul

!-----------------------------------------------------------------------
!Routines to initialize things

SUBROUTINE init_smoother(self, omega)

  IMPLICIT NONE
  CLASS(SubDomain) :: self
  REAL(Realkind), INTENT(in) :: omega
  INTEGER :: i

  IF (.NOT. ASSOCIATED(self%smoother)) THEN
    ALLOCATE(self%smoother)
    ALLOCATE(self%smoother%mat_rd)
    ALLOCATE(self%smoother%mat_bl)
    CALL SpMm_SpRowCol(self%smoother%mat_rd, self%Rd, self%mat)
    CALL SpMm_SpRowCol(self%smoother%mat_bl, self%Bl, self%mat)
    ALLOCATE(self%smoother%diaginv_rd(self%mat%m))
    ALLOCATE(self%smoother%diaginv_bl(self%mat%m))

!    ALLOCATE(self%smoother%diaginv(self%mat%m))

    IF (ASSOCIATED(self%bc_if)) THEN
       self%smoother%comm_interf => self%bc_if
    END IF
  END IF

!  self%smoother%mat => self%mat

  DO i = 1, self%mat%m

!    IF (self%smoother%mat%Diagptr(i) == -1) THEN
!      self%smoother%diaginv(i) = 0.0
!    ELSE
!      self%smoother%diaginv(i) = omega / (self%smoother%mat%Val(self%smoother%mat%Diagptr(i)) + 1e-20) ** 2 * &
!                                    self%smoother%mat%Val(self%smoother%mat%Diagptr(i))
!    END IF


    IF (self%smoother%mat_rd%Diagptr(i) == -1) THEN
      self%smoother%diaginv_rd(i) = 0.0
    ELSE
      self%smoother%diaginv_rd(i) = omega / (self%smoother%mat_rd%Val(self%smoother%mat_rd%Diagptr(i)) + 1e-20) ** 2 * &
                                    self%smoother%mat_rd%Val(self%smoother%mat_rd%Diagptr(i))
    END IF

    IF (self%smoother%mat_bl%Diagptr(i) == -1) THEN
      self%smoother%diaginv_bl(i) = 0.0
    ELSE
      self%smoother%diaginv_bl(i) = omega / (self%smoother%mat_bl%Val(self%smoother%mat_bl%Diagptr(i)) + 1e-20) ** 2 * &
                                    self%smoother%mat_bl%Val(self%smoother%mat_bl%Diagptr(i))
    END IF
  END DO

  ALLOCATE(self%smoother%comm_interf%halo%mat_rd_halo)
  ALLOCATE(self%smoother%comm_interf%halo%mat_bl_halo)
  CALL SpMm_SpRowCol(self%smoother%comm_interf%halo%mat_rd_halo, self%smoother%comm_interf%halo%Rd_halo, &
                     self%smoother%comm_interf%halo%mat_halo)
  CALL SpMm_SpRowCol(self%smoother%comm_interf%halo%mat_bl_halo, self%smoother%comm_interf%halo%Bl_halo, &
                     self%smoother%comm_interf%halo%mat_halo)

END SUBROUTINE init_smoother


SUBROUTINE init_boundcomm_interface(self, blockranks)

  IMPLICIT NONE

  CLASS(SubDomain) :: self
  INTEGER, INTENT(in) :: blockranks(:)
!  TYPE(SpRowCol), INTENT(in) :: lapl3d, grad3d, div3d, intc2f
!  TYPE(SpRowCol), OPTIONAL, INTENT(in) :: Rd, Bl

!  TYPE(SpRowCol), TARGET, SAVE :: OP_crop_halo_T, OP_crop_bound
!  TYPE(SpRowCol), TARGET, SAVE :: Rd_halo, Bl_halo, lapl3d_rd_halo, lapl3d_bl_halo
!  TYPE(SpRowCol) :: OP_crop_halo_face_T, OP_crop_bound_face
!  TYPE(SpRowCol) :: Lapl3d_bnd_tmp, Grad3d_bnbd_tmp, Div3d_bnd_tmp, intc2f_bnd_tmp
!  TYPE(SpRowCol) :: eye, eye_tmp
!  TYPE(SpRowCol) :: Rd_tmp, Bl_tmp, OP_crop_bound_T

!  CALL make_crop_operator_halo_T(mysubdom, OP_crop_halo_T)
!  CALL make_crop_operator_boundary(mysubdom, OP_crop_bound)
!  CALL make_crop_operator_halo_face_T(mysubdom, OP_crop_halo_face_T)
!  CALL make_crop_operator_boundary_face(mysubdom, OP_crop_bound_face)

!  new_comm_interface%halo%OP_crop_bound => OP_crop_bound
!  new_comm_interface%halo%OP_crop_halo_T => OP_crop_halo_T

!  CALL make_eye(eye, lapl3d%m)

!  CALL SpMm_SpRowCol(Lapl3d_bnd_tmp, OP_crop_bound, lapl3d)
!  CALL SpMm_SpRowCol(new_comm_interface%halo%Lapl3d_halo, Lapl3d_bnd_tmp, OP_crop_halo_T)

!  CALL SpMm_SpRowCol(Grad3d_bnbd_tmp, OP_crop_bound_face, grad3d)
!  CALL SpMm_SpRowCol(new_comm_interface%halo%Grad3d_halo, Grad3d_bnbd_tmp, OP_crop_halo_T)

!  CALL SpMm_SpRowCol(Div3d_bnd_tmp, OP_crop_bound, div3d)
!  CALL SpMm_SpRowCol(new_comm_interface%halo%Div3d_halo, Div3d_bnd_tmp, OP_crop_halo_face_T)

!  CALL SpMm_SpRowCol(eye_tmp, OP_crop_bound, eye)
!  CALL SpMm_SpRowCol(new_comm_interface%halo%Eye, eye_tmp, OP_crop_halo_T)

!  CALL SpMm_SpRowCol(intc2f_bnd_tmp, OP_crop_bound_face, intc2f)
!  CALL SpMm_SpRowCol(new_comm_interface%halo%Intc2f_halo, intc2f_bnd_tmp, OP_crop_halo_T)

!  IF (PRESENT(Rd) .AND. PRESENT(Bl)) THEN

!    CALL SpTrans_SpRowCol(OP_crop_bound_T, OP_crop_bound)
!    IF (ASSOCIATED(Rd%RowPtr)) THEN
!      CALL SpMm_SpRowCol(Rd_tmp, OP_crop_bound, Rd)
!      CALL SpMm_SpRowCol(Rd_halo, Rd_tmp, OP_crop_bound_T)
!    END IF
!    IF (ASSOCIATED(Bl%RowPtr)) THEN
!      CALL SpMm_SpRowCol(Bl_tmp, OP_crop_bound, Bl)
!      CALL SpMm_SpRowCol(Bl_halo, Bl_tmp, OP_crop_bound_T)
!    END IF

!    CALL SpMm_SpRowCol(lapl3d_rd_halo, Rd_halo, new_comm_interface%halo%Lapl3d_halo)
!    CALL SpMm_SpRowCol(lapl3d_bl_halo, Bl_halo, new_comm_interface%halo%Lapl3d_halo)

!    new_comm_interface%halo%Rd_halo => Rd_halo
!    new_comm_interface%halo%Bl_halo => Bl_halo

!    new_comm_interface%halo%lapl3d_rd_halo => lapl3d_rd_halo
!    new_comm_interface%halo%lapl3d_bl_halo => lapl3d_bl_halo

!    CALL SpDeallocate_SpRowCol(Bl_tmp)
!    CALL SpDeallocate_SpRowCol(Rd_tmp)
!    CALL SpDeallocate_SpRowCol(OP_crop_bound_T)

!    CALL SpNullify_SpRowCol(Bl_tmp)
!    CALL SpNullify_SpRowCol(Rd_tmp)
!    CALL SpNullify_SpRowCol(OP_crop_bound_T)

!  END IF

  ALLOCATE(self%bc_if)

  CALL make_halo_fldinds(self%bc_if%halo, self)

  CALL make_sendrecv_bnds(self%bc_if%send_bnds, self%bc_if%recv_bnds, &
                          self, blockranks)

  self%bc_if%myrank = self%myrank

!  CALL SpDeallocate_SpRowCol(Lapl3d_bnd_tmp)
!  CALL SpDeallocate_SpRowCol(Grad3d_bnbd_tmp)
!  CALL SpDeallocate_SpRowCol(Div3d_bnd_tmp)
!  CALL SpDeallocate_SpRowCol(intc2f_bnd_tmp)
!  CALL SpDeallocate_SpRowCol(eye)
!  CALL SpDeallocate_SpRowCol(eye_tmp)

!  CALL SpNullify_SpRowCol(Lapl3d_bnd_tmp)
!  CALL SpNullify_SpRowCol(Grad3d_bnbd_tmp)
!  CALL SpNullify_SpRowCol(Div3d_bnd_tmp)
!  CALL SpNullify_SpRowCol(intc2f_bnd_tmp)
!  CALL SpNullify_SpRowCol(eye)
!  CALL SpNullify_SpRowCol(eye_tmp)

END SUBROUTINE init_boundcomm_interface

SUBROUTINE set_cell_type(subdom)

  IMPLICIT NONE

  CLASS(SubDomain) :: subdom

  INTEGER :: iblock, jblock
  INTEGER :: i, j, k, ind
  INTEGER :: n_tmp, m_tmp
  INTEGER :: i_st, i_end, j_st, j_end, k_st, k_end

  ALLOCATE(subdom%inds1d_type(subdom%ncells_tmp))
  subdom%inds1d_type(:) = -1

  subdom%nbound = 0
  subdom%nghost = 0
  DO iblock = 1, subdom%nblocks
    subdom%blocks(iblock)%nghost = 0
    subdom%blocks(iblock)%nbound = 0

    IF (subdom%blockiscomp(iblock) .EQV. .TRUE.) THEN
      DO i = 1, UBOUND(subdom%blocks(iblock)%x, dim=1)
        DO j = 1, UBOUND(subdom%blocks(iblock)%y, dim=1)
          DO k = 1, UBOUND(subdom%blocks(iblock)%z, dim=1)
            subdom%inds1d_type(IndexC3block(i, j, k, subdom%blocks, iblock, check=.TRUE.)) = 1
          END DO
        END DO
      END DO

      DO jblock = 1, subdom%nblocks
        IF (subdom%blockiscomp(jblock)) CYCLE

        IF ((subdom%blocks(iblock)%cedge_w(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .FALSE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                    MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
                   MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
                    MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)
          DO j = j_st, j_end
            DO k = k_st, k_end
              ind = IndexC3block(1, j, k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 2) THEN
                subdom%inds1d_type(ind) = 2
                subdom%nbound = subdom%nbound + 1
                subdom%blocks(iblock)%nbound = subdom%blocks(iblock)%nbound + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_e(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .FALSE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                    MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
                   MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
                    MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)
          DO j = j_st, j_end
            DO k = k_st, k_end
              ind = IndexC3block(UBOUND(subdom%blocks(iblock)%x, dim=1), j, k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 2) THEN
                subdom%inds1d_type(ind) = 2
                subdom%nbound = subdom%nbound + 1
                subdom%blocks(iblock)%nbound = subdom%blocks(iblock)%nbound + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_s(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .FALSE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
                   MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
                    MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
                   MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
                    MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO k = k_st, k_end
              ind = IndexC3block(i, 1, k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 2) THEN
                subdom%inds1d_type(ind) = 2
                subdom%nbound = subdom%nbound + 1
                subdom%blocks(iblock)%nbound = subdom%blocks(iblock)%nbound + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_n(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .FALSE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
                   MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
                    MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
                   MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
                    MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO k = k_st, k_end
              ind = IndexC3block(i, UBOUND(subdom%blocks(iblock)%y, dim=1), k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 2) THEN
                subdom%inds1d_type(ind) = 2
                subdom%nbound = subdom%nbound + 1
                subdom%blocks(iblock)%nbound = subdom%blocks(iblock)%nbound + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_b(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .FALSE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
                   MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
                    MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                   MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO j = j_st, j_end
              ind = IndexC3block(i, j, 1, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 2) THEN
                subdom%inds1d_type(ind) = 2
                subdom%nbound = subdom%nbound + 1
                subdom%blocks(iblock)%nbound = subdom%blocks(iblock)%nbound + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_t(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .FALSE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
                   MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
                    MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                    MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO j = j_st, j_end
              ind = IndexC3block(i, j, UBOUND(subdom%blocks(iblock)%z, dim=1), subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 2) THEN
                subdom%inds1d_type(ind) = 2
                subdom%nbound = subdom%nbound + 1
                subdom%blocks(iblock)%nbound = subdom%blocks(iblock)%nbound + 1
              END IF
            END DO
          END DO
        END IF
      END DO
    ELSE

      DO jblock = 1, subdom%nblocks
        IF ((subdom%blocks(iblock)%cedge_w(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .TRUE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                    MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
                   MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
                    MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)

          DO j = j_st, j_end
            DO k = k_st, k_end
              ind = IndexC3block(1, j, k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 3) THEN
                subdom%inds1d_type(ind) = 3
                subdom%nghost = subdom%nghost + 1
                subdom%blocks(iblock)%nghost = subdom%blocks(iblock)%nghost + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_e(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .TRUE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                    MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
                   MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
                    MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)
          DO j = j_st, j_end
            DO k = k_st, k_end
              ind = IndexC3block(UBOUND(subdom%blocks(iblock)%x, dim=1), j, k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 3) THEN
                subdom%inds1d_type(ind) = 3
                subdom%nghost = subdom%nghost + 1
                subdom%blocks(iblock)%nghost = subdom%blocks(iblock)%nghost + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_s(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .TRUE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
                   MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
                    MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
                   MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
                    MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO k = k_st, k_end
              ind = IndexC3block(i, 1, k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 3) THEN
                subdom%inds1d_type(ind) = 3
                subdom%nghost = subdom%nghost + 1
                subdom%blocks(iblock)%nghost = subdom%blocks(iblock)%nghost + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_n(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .TRUE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
            MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
            MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%z, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%z2, dim=1)
          k_st = MAX(findloc_real(subdom%blocks(iblock)%z2, &
            MAX(subdom%blocks(iblock)%z2(1), subdom%blocks(jblock)%z2(1))) - 1, 1)
          k_end = MIN(findloc_real(subdom%blocks(iblock)%z2, &
            MIN(subdom%blocks(iblock)%z2(n_tmp), subdom%blocks(jblock)%z2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO k = k_st, k_end
              ind = IndexC3block(i, UBOUND(subdom%blocks(iblock)%y, dim=1), k, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 3) THEN
                subdom%inds1d_type(ind) = 3
                subdom%nghost = subdom%nghost + 1
                subdom%blocks(iblock)%nghost = subdom%blocks(iblock)%nghost + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_b(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .TRUE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
                   MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
                    MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                    MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO j = j_st, j_end
              ind = IndexC3block(i, j, 1, subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 3) THEN
                subdom%inds1d_type(ind) = 3
                subdom%nghost = subdom%nghost + 1
                subdom%blocks(iblock)%nghost = subdom%blocks(iblock)%nghost + 1
              END IF
            END DO
          END DO
        END IF

        IF ((subdom%blocks(iblock)%cedge_t(jblock) .EQV. .TRUE.) .AND. (subdom%blockiscomp(jblock) .EQV. .TRUE.)) THEN
          n_tmp = UBOUND(subdom%blocks(iblock)%x, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%x2, dim=1)
          i_st = MAX(findloc_real(subdom%blocks(iblock)%x2, &
                   MAX(subdom%blocks(iblock)%x2(1), subdom%blocks(jblock)%x2(1))) - 1, 1)
          i_end = MIN(findloc_real(subdom%blocks(iblock)%x2, &
                    MIN(subdom%blocks(iblock)%x2(n_tmp), subdom%blocks(jblock)%x2(m_tmp))), n_tmp)
          n_tmp = UBOUND(subdom%blocks(iblock)%y, dim=1)
          m_tmp = UBOUND(subdom%blocks(jblock)%y2, dim=1)
          j_st = MAX(findloc_real(subdom%blocks(iblock)%y2, &
                   MAX(subdom%blocks(iblock)%y2(1), subdom%blocks(jblock)%y2(1))) - 1, 1)
          j_end = MIN(findloc_real(subdom%blocks(iblock)%y2, &
                    MIN(subdom%blocks(iblock)%y2(n_tmp), subdom%blocks(jblock)%y2(m_tmp))), n_tmp)
          DO i = i_st, i_end
            DO j = j_st, j_end
              ind = IndexC3block(i, j, UBOUND(subdom%blocks(iblock)%z, dim=1), subdom%blocks, iblock, check=.TRUE.)
              IF (.NOT. subdom%inds1d_type(ind) .EQ. 3) THEN
                subdom%inds1d_type(ind) = 3
                subdom%nghost = subdom%nghost + 1
                subdom%blocks(iblock)%nghost = subdom%blocks(iblock)%nghost + 1
              END IF
            END DO
          END DO
        END IF
      END DO
    END IF
  END DO


END SUBROUTINE set_cell_type


SUBROUTINE set_face_type(subdom)
  IMPLICIT NONE

  CLASS(SubDomain) :: subdom

  INTEGER :: iblock, jblock
  INTEGER :: i, j, k, ind
  INTEGER :: n_tmp, m_tmp
  INTEGER :: i_st, i_end, j_st, j_end, k_st, k_end
  INTEGER :: nz, ny, nx
  REAL(Realkind), POINTER :: x2(:), y2(:), z2(:), x2_tmp(:), y2_tmp(:), z2_tmp(:)

  ALLOCATE(subdom%indsface1d_type(subdom%nfaces_tmp))
  subdom%indsface1d_type(:) = 0


  DO iblock = 1, subdom%nblocks
    nz = subdom%blocks(iblock)%fld_shape(1)
    ny = subdom%blocks(iblock)%fld_shape(2)
    nx = subdom%blocks(iblock)%fld_shape(3)

    x2 => subdom%blocks(iblock)%x2
    y2 => subdom%blocks(iblock)%y2
    z2 => subdom%blocks(iblock)%z2

    IF (subdom%blockiscomp(iblock) .EQV. .TRUE.) THEN
      DO jblock = 1, subdom%nblocks
        IF (subdom%blockiscomp(jblock) .EQV. .TRUE.) CYCLE

        x2_tmp => subdom%blocks(jblock)%x2
        y2_tmp => subdom%blocks(jblock)%y2
        z2_tmp => subdom%blocks(jblock)%z2

        IF (subdom%blocks(iblock)%cedge_w(jblock) .EQV. .TRUE.) THEN
          j_st = MAX(findloc_real(y2, MAX(y2(1), y2_tmp(1))) -1, 1)
          j_end = MIN(findloc_real(y2, MIN(y2(UBOUND(y2, 1)), y2_tmp(UBOUND(y2_tmp, 1)))), ny)
          k_st = MAX(findloc_real(z2, MAX(z2(1), z2_tmp(1))) -1, 1)
          k_end = MIN(findloc_real(z2, MIN(z2(UBOUND(z2, 1)), z2_tmp(UBOUND(z2_tmp, 1)))), nz)
          DO j = j_st, j_end
            DO k = k_st, k_end
              ind = IndexU3block(1, j, k, subdom%blocks, iblock, check=.TRUE.)
              subdom%indsface1d_type(ind) = 1
            END DO
          END DO
        END IF

        IF (subdom%blocks(iblock)%cedge_e(jblock) .EQV. .TRUE.) THEN
          j_st = MAX(findloc_real(y2, MAX(y2(1), y2_tmp(1))) -1, 1)
          j_end = MIN(findloc_real(y2, MIN(y2(UBOUND(y2, 1)), y2_tmp(UBOUND(y2_tmp, 1)))), ny)
          k_st = MAX(findloc_real(z2, MAX(z2(1), z2_tmp(1))) -1, 1)
          k_end = MIN(findloc_real(z2, MIN(z2(UBOUND(z2, 1)), z2_tmp(UBOUND(z2_tmp, 1)))), nz)
          DO j = j_st, j_end
            DO k = k_st, k_end
              ind = IndexU3block(nx + 1, j, k, subdom%blocks, iblock, check=.TRUE.)
              subdom%indsface1d_type(ind) = 1
            END DO
          END DO
        END IF

        IF (subdom%blocks(iblock)%cedge_s(jblock) .EQV. .TRUE.) THEN
          i_st = MAX(findloc_real(x2, MAX(x2(1), x2_tmp(1))) -1, 1)
          i_end = MIN(findloc_real(x2, MIN(x2(UBOUND(x2, 1)), x2_tmp(UBOUND(x2_tmp, 1)))), nx)
          k_st = MAX(findloc_real(z2, MAX(z2(1), z2_tmp(1))) -1, 1)
          k_end = MIN(findloc_real(z2, MIN(z2(UBOUND(z2, 1)), z2_tmp(UBOUND(z2_tmp, 1)))), nz)
          DO i = i_st, i_end
            DO k = k_st, k_end
              ind = IndexV3block(i, 1, k, subdom%blocks, iblock, check=.TRUE.)
              subdom%indsface1d_type(ind) = 1
            END DO
          END DO
        END IF

        IF (subdom%blocks(iblock)%cedge_n(jblock) .EQV. .TRUE.) THEN
          i_st = MAX(findloc_real(x2, MAX(x2(1), x2_tmp(1))) -1, 1)
          i_end = MIN(findloc_real(x2, MIN(x2(UBOUND(x2, 1)), x2_tmp(UBOUND(x2_tmp, 1)))), nx)
          k_st = MAX(findloc_real(z2, MAX(z2(1), z2_tmp(1))) -1, 1)
          k_end = MIN(findloc_real(z2, MIN(z2(UBOUND(z2, 1)), z2_tmp(UBOUND(z2_tmp, 1)))), nz)
          DO i = i_st, i_end
            DO k = k_st, k_end
              ind = IndexV3block(i, ny + 1, k, subdom%blocks, iblock, check=.TRUE.)
              subdom%indsface1d_type(ind) = 1
            END DO
          END DO
        END IF

        IF (subdom%blocks(iblock)%cedge_b(jblock) .EQV. .TRUE.) THEN
          i_st = MAX(findloc_real(x2, MAX(x2(1), x2_tmp(1))) -1, 1)
          i_end = MIN(findloc_real(x2, MIN(x2(UBOUND(x2, 1)), x2_tmp(UBOUND(x2_tmp, 1)))), nx)
          j_st = MAX(findloc_real(y2, MAX(y2(1), y2_tmp(1))) -1, 1)
          j_end = MIN(findloc_real(y2, MIN(y2(UBOUND(y2, 1)), y2_tmp(UBOUND(y2_tmp, 1)))), ny)
          DO i = i_st, i_end
            DO j = j_st, j_end
              ind = IndexW3block(i, j, 1, subdom%blocks, iblock, check=.TRUE.)
              subdom%indsface1d_type(ind) = 1
            END DO
          END DO
        END IF

        IF (subdom%blocks(iblock)%cedge_t(jblock) .EQV. .TRUE.) THEN
          i_st = MAX(findloc_real(x2, MAX(x2(1), x2_tmp(1))) -1, 1)
          i_end = MIN(findloc_real(x2, MIN(x2(UBOUND(x2, 1)), x2_tmp(UBOUND(x2_tmp, 1)))), nx)
          j_st = MAX(findloc_real(y2, MAX(y2(1), y2_tmp(1))) -1, 1)
          j_end = MIN(findloc_real(y2, MIN(y2(UBOUND(y2, 1)), y2_tmp(UBOUND(y2_tmp, 1)))), ny)
          DO i = i_st, i_end
            DO j = j_st, j_end
              ind = IndexW3block(i, j, nz + 1, subdom%blocks, iblock, check=.TRUE.)
              subdom%indsface1d_type(ind) = 1
            END DO
          END DO
        END IF
      END DO
    END IF
  END DO

END SUBROUTINE set_face_type


SUBROUTINE make_sendrecv_bnds(send_bnds, recv_bnds, my_subdom, blockranks)
  ! Make boundary objects for point-to-point communication

  IMPLICIT NONE

  TYPE(Bound), POINTER, INTENT(inout) :: send_bnds
  TYPE(Bound), POINTER, INTENT(inout) :: recv_bnds
  TYPE(SubDomain), INTENT(in) :: my_subdom
  INTEGER, INTENT(in) :: blockranks(:)

  TYPE(Bound), POINTER :: send_current, recv_current

  INTEGER, ALLOCATABLE :: send_sizes(:)
  INTEGER, ALLOCATABLE :: send_nblocks(:)
  INTEGER, ALLOCATABLE :: send_reqs(:)

  INTEGER :: nranks, irank, jrank, rank
  INTEGER :: ranks(my_subdom%nblocks)

  INTEGER :: i, j, k, ind
  INTEGER :: iblock, jblock, nblocks_comm, iblock_comm
  INTEGER :: ighost_full, ighost, nghost
  INTEGER :: icell, ncells

  LOGICAL :: first_recv


  nranks = MAXVAL(blockranks) + 1

  first_recv = .TRUE.

  recv_current => NULL()
  send_current => NULL()

  irank = 1
  ranks = -1
  DO iblock = 1, my_subdom%nblocks
    IF (my_subdom%blocks(iblock)%nghost .GT. 0) THEN
      rank = my_subdom%blocks(iblock)%myrank
      IF (.NOT. isin(ranks, rank)) THEN
        ranks(irank) = rank
        irank = irank + 1
      END IF
    END IF
  END DO

  irank = irank - 1

  DO jrank = 1, irank
    nblocks_comm = 0
    rank = ranks(jrank)
    nghost = 0
    DO iblock = 1, my_subdom%nblocks
      IF (my_subdom%blocks(iblock)%nghost .GT. 0 .AND. my_subdom%blocks(iblock)%myrank == rank) THEN
        nghost = nghost + my_subdom%blocks(iblock)%nghost
        nblocks_comm = nblocks_comm + 1
      END IF
    END DO

    IF (first_recv .EQV. .TRUE.) THEN
      ALLOCATE(recv_bnds)
      ALLOCATE(send_bnds)
      recv_current => recv_bnds
      send_current => send_bnds
      first_recv = .FALSE.
    ELSE
      ALLOCATE(recv_current%next)
      ALLOCATE(send_current%next)
      recv_current => recv_current%next
      send_current => send_current%next
    END IF

    ALLOCATE(recv_current%fld_data(nghost))
    ALLOCATE(recv_current%fld_inds(nghost))
    ALLOCATE(recv_current%blockfld_inds(nghost))
    ALLOCATE(recv_current%blockids(nblocks_comm))
    ALLOCATE(recv_current%blockptr(nblocks_comm + 1))
    recv_current%blockptr(1)= 1

    iblock_comm = 1
    ighost = 1
    ighost_full = 1
    DO iblock = 1, my_subdom%nblocks
      IF (my_subdom%blocks(iblock)%nghost .GT. 0) THEN
        IF (my_subdom%blocks(iblock)%myrank == rank) THEN
          recv_current%blockids(iblock_comm) = my_subdom%blockids_compghst(iblock)
          DO i = 1, my_subdom%blocks(iblock)%fld_shape(3)
            DO j = 1, my_subdom%blocks(iblock)%fld_shape(2)
              DO k = 1, my_subdom%blocks(iblock)%fld_shape(1)
                ind = IndexC3block(i, j, k, my_subdom%blocks, iblock, check=.TRUE.)
                IF (my_subdom%inds1d_type(ind) == 3) THEN
                  recv_current%fld_inds(ighost) = ighost_full
                  recv_current%blockfld_inds(ighost) = IndexC3(i, j, k, my_subdom%blocks(iblock)%fld_shape(3), &
                                                                     my_subdom%blocks(iblock)%fld_shape(2), &
                                                                     my_subdom%blocks(iblock)%fld_shape(1))


                  ighost = ighost + 1
                  ighost_full = ighost_full + 1
                END IF
              END DO
            END DO
          END DO
          iblock_comm = iblock_comm + 1
          recv_current%blockptr(iblock_comm) = ighost
        ELSE
          ighost_full = ighost_full + my_subdom%blocks(iblock)%nghost
        END IF

      END IF
    END DO

    recv_current%rank_comm = rank
    recv_current%tag = rank * nranks + my_subdom%myrank

    send_current%rank_comm = rank
    send_current%tag = my_subdom%myrank * nranks + rank

  END DO


  ALLOCATE(send_sizes(irank))
  ALLOCATE(send_nblocks(irank))
  ALLOCATE(send_reqs(irank))

  !!!Exchange metadata

  recv_current => recv_bnds
  send_current => send_bnds

  !Exchange array sizes

  IF (ASSOCIATED(recv_current)) THEN
    irank = 1
    CALL MPI_ISEND(SIZE(recv_current%fld_data), 1, MPI_INT, &
                   recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

    CALL MPI_IRECV(send_sizes(irank), 1, MPI_INT, &
                   recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next
      irank = irank + 1
      CALL MPI_ISEND(SIZE(recv_current%fld_data), 1, MPI_INT, &
                     recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

      CALL MPI_IRECV(send_sizes(irank), 1, MPI_INT, &
                     recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)
    END DO

  END IF

  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN
    irank = 1

    CALL MPI_WAIT(recv_current%req, status, MPIErr)
    CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next

      irank = irank + 1
      CALL MPI_WAIT(recv_current%req, status, MPIErr)
      CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    END DO

  END IF


  !Exchange number of blocks

  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN
    irank = 1
    CALL MPI_ISEND(SIZE(recv_current%blockids), 1, MPI_INT, &
                   recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)
    CALL MPI_IRECV(send_nblocks(irank), 1, MPI_INT, &
                   recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next
      irank = irank + 1

      CALL MPI_ISEND(SIZE(recv_current%blockids), 1, MPI_INT, &
                     recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

      CALL MPI_IRECV(send_nblocks(irank), 1, MPI_INT, &
                     recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)
    END DO
  END IF


  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN
    irank = 1

    CALL MPI_WAIT(recv_current%req, status, MPIErr)
    CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next

      irank = irank + 1
      CALL MPI_WAIT(recv_current%req, status, MPIErr)
      CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    END DO

  END IF

  !Exchange block indices



  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN

    irank = 1
    ALLOCATE(send_current%blockids(send_nblocks(irank)))


    CALL MPI_ISEND(recv_current%blockids, SIZE(recv_current%blockids), MPI_INT, &
                   recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

    CALL MPI_IRECV(send_current%blockids, SIZE(send_current%blockids), MPI_INT, &
                   recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next
      irank = irank + 1

      ALLOCATE(send_current%blockids(send_nblocks(irank)))

      CALL MPI_ISEND(recv_current%blockids, SIZE(recv_current%blockids), MPI_INT, &
                     recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

      CALL MPI_IRECV(send_current%blockids, SIZE(send_current%blockids), MPI_INT, &
                     recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)
    END DO
  END IF

  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN
    irank = 1

    CALL MPI_WAIT(recv_current%req, status, MPIErr)
    CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next

      irank = irank + 1
      CALL MPI_WAIT(recv_current%req, status, MPIErr)
      CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    END DO
  END IF


  !Exchange block pointer

  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN

    irank = 1

    ALLOCATE(send_current%blockptr(send_nblocks(irank) + 1))

    CALL MPI_ISEND(recv_current%blockptr, SIZE(recv_current%blockptr), MPI_INT, &
                   recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

    CALL MPI_IRECV(send_current%blockptr, SIZE(send_current%blockptr), MPI_INT, &
                   recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next
      irank = irank + 1

      ALLOCATE(send_current%blockptr(send_nblocks(irank) + 1))

      CALL MPI_ISEND(recv_current%blockptr, SIZE(recv_current%blockptr), MPI_INT, &
                     recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

      CALL MPI_IRECV(send_current%blockptr, SIZE(send_current%blockptr), MPI_INT, &
                     recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)
    END DO
  END IF

  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN
    irank = 1

    CALL MPI_WAIT(recv_current%req, status, MPIErr)
    CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next

      irank = irank + 1
      CALL MPI_WAIT(recv_current%req, status, MPIErr)
      CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    END DO

  END IF

  !Exchange block field indices

  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN

    irank = 1

    ALLOCATE(send_current%blockfld_inds(send_sizes(irank)))

    CALL MPI_ISEND(recv_current%blockfld_inds, SIZE(recv_current%blockfld_inds), MPI_INT, &
                   recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

    CALL MPI_IRECV(send_current%blockfld_inds, SIZE(send_current%blockfld_inds), MPI_INT, &
                   recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next
      irank = irank + 1

      ALLOCATE(send_current%blockfld_inds(send_sizes(irank)))

      CALL MPI_ISEND(recv_current%blockfld_inds, SIZE(recv_current%blockfld_inds), MPI_INT, &
                     recv_current%rank_comm, recv_current%tag, MPI_COMM_WORLD, recv_current%req, MPIErr)

      CALL MPI_IRECV(send_current%blockfld_inds, SIZE(send_current%blockfld_inds), MPI_INT, &
                     recv_current%rank_comm, send_current%tag, MPI_COMM_WORLD, send_reqs(irank), MPIErr)
    END DO
  END IF

  recv_current => recv_bnds
  send_current => send_bnds

  IF (ASSOCIATED(recv_current)) THEN
    irank = 1

    CALL MPI_WAIT(recv_current%req, status, MPIErr)
    CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    DO WHILE (ASSOCIATED(recv_current%next))

      recv_current => recv_current%next
      send_current => send_current%next

      irank = irank + 1
      CALL MPI_WAIT(recv_current%req, status, MPIErr)
      CALL MPI_WAIT(send_reqs(irank), status, MPIErr)

    END DO

  END IF

  ! compute the final boundary field indices to send

  send_current => send_bnds
  IF (ASSOCIATED(send_current)) THEN

    ALLOCATE(send_current%fld_inds(SIZE(send_current%blockfld_inds)))
    ALLOCATE(send_current%fld_data(SIZE(send_current%blockfld_inds)))

    icell = 1

    DO iblock = 1, SIZE(send_current%blockids)
      ncells = 0
      DO jblock = 1, my_subdom%nblocks
        IF (my_subdom%blockiscomp(jblock) .EQV. .TRUE.) THEN
          IF (my_subdom%blockids_compghst(jblock) == send_current%blockids(iblock)) THEN
            DO i = send_current%blockptr(iblock), send_current%blockptr(iblock + 1) - 1
               send_current%fld_inds(icell) = send_current%blockfld_inds(i) + ncells
               icell = icell + 1
            END DO
          ELSE
            ncells = ncells + my_subdom%blocks(jblock)%ncells
          END IF
        END IF
      END DO
    END DO

    DO WHILE (ASSOCIATED(send_current%next))

      send_current => send_current%next
      irank = irank + 1

      ALLOCATE(send_current%fld_inds(SIZE(send_current%blockfld_inds)))
      ALLOCATE(send_current%fld_data(SIZE(send_current%blockfld_inds)))


      icell = 1

      DO iblock = 1, SIZE(send_current%blockids)
        ncells = 0
        DO jblock = 1, my_subdom%nblocks
          IF (my_subdom%blockiscomp(jblock) .EQV. .TRUE.) THEN
            IF (my_subdom%blockids_compghst(jblock) == send_current%blockids(iblock)) THEN
              DO i = send_current%blockptr(iblock), send_current%blockptr(iblock + 1) - 1
                 send_current%fld_inds(icell) = send_current%blockfld_inds(i) + ncells
                 icell = icell + 1
              END DO
            ELSE
              ncells = ncells + my_subdom%blocks(jblock)%ncells
            END IF
          END IF
        END DO
      END DO

    END DO
  END IF

  DEALLOCATE(send_sizes)
  DEALLOCATE(send_nblocks)
  DEALLOCATE(send_reqs)

END SUBROUTINE make_sendrecv_bnds


SUBROUTINE make_halo_fldinds(halo, subdom)
  !make the halo layer

  IMPLICIT NONE

  TYPE(HaloType), INTENT(inout) :: halo
  TYPE(SubDomain), INTENT(in) :: subdom
  INTEGER :: i, j, k, nz, ny, nx, ind, iblock
  INTEGER :: icell_full, icell_bnd, iface_full, iface_bnd
  INTEGER :: nbound_face

  nbound_face = SUM(subdom%indsface1d_type)

  halo%myrank = subdom%myrank

  ALLOCATE(halo%hdata(subdom%nghost))
  ALLOCATE(halo%finds(subdom%nbound))
  ALLOCATE(halo%fdata(subdom%nbound))
  ALLOCATE(halo%ginds(nbound_face))
  ALLOCATE(halo%gdata(nbound_face))


  icell_full = 1
  icell_bnd = 1

  iface_full = 1
  iface_bnd = 1

  DO iblock = 1, subdom%nblocks

    IF (subdom%blockiscomp(iblock)) THEN

      nz = subdom%blocks(iblock)%fld_shape(1)
      ny = subdom%blocks(iblock)%fld_shape(2)
      nx = subdom%blocks(iblock)%fld_shape(3)

      DO i = 1, nx
        DO j = 1, ny
          DO k = 1, nz
            ind = IndexC3block(i, j, k, subdom%blocks, iblock, check=.TRUE.)
            IF (subdom%inds1d_type(ind) .EQ. 2) THEN
              halo%finds(icell_bnd) = icell_full
              icell_bnd = icell_bnd + 1
            END IF
            icell_full = icell_full + 1
          END DO
        END DO
      END DO

      DO i = 1, nx + 1
        DO j = 1, ny
          DO k = 1, nz
            ind = IndexU3block(i, j, k, subdom%blocks, iblock, check=.TRUE.)
            IF (subdom%indsface1d_type(ind) .EQ. 1) THEN
              halo%ginds(iface_bnd) = iface_full
              iface_bnd = iface_bnd + 1
            END IF
            iface_full = iface_full + 1
          END DO
        END DO
      END DO

      DO i = 1, nx
        DO j = 1, ny + 1
          DO k = 1, nz
            ind = IndexV3block(i, j, k, subdom%blocks, iblock, check=.TRUE.)
            IF (subdom%indsface1d_type(ind) .EQ. 1) THEN
              halo%ginds(iface_bnd) = iface_full
              iface_bnd = iface_bnd + 1
            END IF
            iface_full = iface_full + 1
          END DO
        END DO
      END DO

      DO i = 1, nx
        DO j = 1, ny
          DO k = 1, nz + 1
            ind = IndexW3block(i, j, k, subdom%blocks, iblock, check=.TRUE.)
            IF (subdom%indsface1d_type(ind) .EQ. 1) THEN
              halo%ginds(iface_bnd) = iface_full
              iface_bnd = iface_bnd + 1
            END IF
            iface_full = iface_full + 1
          END DO
        END DO
      END DO
    END IF
  END DO

END SUBROUTINE make_halo_fldinds


FUNCTION isin(array, val)

  IMPLICIT NONE

  INTEGER, INTENT(in) :: array(:)
  INTEGER, INTENT(in) :: val
  LOGICAL :: isin
  INTEGER :: i

  isin = .FALSE.
  DO i = 1, SIZE(array)
    IF (array(i) == val) THEN
      isin = .TRUE.
      EXIT
    END IF
  END DO

END FUNCTION isin

FUNCTION dot_para(a, b)
  IMPLICIT NONE

  REAL(Realkind), INTENT(in) :: a(:), b(:)
  REAL(Realkind) :: dot_para, x_loc
  REAL(Realkind) :: sendbuf(NumProcs), recvbuf(NumProcs)
 
  INTEGER :: i

  x_loc = 0
  DO i = LBOUND(a, 1), UBOUND(a, 1)
    x_loc = x_loc + a(i) * b(i)
  END DO

  sendbuf(:) = x_loc
  CALL MPI_ALLTOALL(sendbuf, 1, MPI_RealKind, recvbuf, 1, MPI_RealKind, MPI_COMM_WORLD, MPIErr)

  dot_para = SUM(recvbuf)

END FUNCTION dot_para



END MODULE Subdom_Mod
